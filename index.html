<!DOCTYPE html>
<!--
  ============================================================================
  LED Wall Calculator
  © 2025 Gabriel Labrecque
  Fearless Wanderer Productions

  This software is dual-licensed:

  - Open Source use under the MIT License (see LICENSE-OPEN.txt).
  - Commercial use, redistribution, or sale requires a commercial license from Gabriel Labrecque.

  All rights reserved. Unauthorized copying, modification, distribution, or use outside the terms of these licenses is prohibited.
  ============================================================================
-->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="LED Calc">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0a0a0a">
  <meta name="description" content="LED Wall Calculator - Professional LED panel configuration tool">
  <!-- Cache control - prevent aggressive caching -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>LED Wall Calculator – Mobile v2</title>

  <!-- PWA Manifest (inline base64) -->
  <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkxFRCBXYWxsIENhbGN1bGF0b3IiLAogICJzaG9ydF9uYW1lIjogIkxFRCBDYWxjIiwKICAiZGVzY3JpcHRpb24iOiAiUHJvZmVzc2lvbmFsIExFRCBwYW5lbCBjb25maWd1cmF0aW9uIHRvb2wiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzBhMGEwYSIsCiAgInRoZW1lX2NvbG9yIjogIiMwYTBhMGEiLAogICJvcmllbnRhdGlvbiI6ICJhbnkiCn0=">

  <!-- iOS Icons - Generated PNG via canvas for iOS compatibility -->
  <link rel="apple-touch-icon" id="appleTouchIcon" href="">
  <script>
    (function() {
      var canvas = document.createElement('canvas');
      canvas.width = 180;
      canvas.height = 180;
      var ctx = canvas.getContext('2d');
      // Dark background with rounded corners (drawn as full rect since iOS clips it)
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, 180, 180);
      // Green "GLAB" text
      ctx.fillStyle = '#10b981';
      ctx.font = 'bold 52px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('GLAB', 90, 95);
      // Set the icon
      var link = document.getElementById('appleTouchIcon');
      if (link) link.href = canvas.toDataURL('image/png');
    })();
  </script>

  <!-- Comic book style fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Permanent+Marker&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0; padding: 0; }

    /* ==================== MOBILE-FIRST BASE STYLES ==================== */
    :root {
      --safe-area-top: env(safe-area-inset-top, 0px);
      --safe-area-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-left: env(safe-area-inset-left, 0px);
      --safe-area-right: env(safe-area-inset-right, 0px);
      --bottom-nav-height: 70px;
      --header-height: 56px;
      --primary: #10b981;
      --primary-hover: #059669;
      --accent-color: #10b981;
      --bg-color: #111827;
      --comic-dark: #1a1a1a;
      --comic-panel: #262626;
      --card-bg: #262626;
      --border-color: #000000;
      --text-color: #e0e0e0;
      --muted-color: #9ca3af;
    }

    body {
      font-family: 'Roboto Condensed', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      padding: 12px;
      padding-top: calc(var(--header-height) + var(--safe-area-top) + 12px);
      padding-bottom: calc(var(--bottom-nav-height) + var(--safe-area-bottom) + 24px);
      padding-left: calc(var(--safe-area-left) + 12px);
      padding-right: calc(var(--safe-area-right) + 12px);
      color: var(--text-color);
      background: var(--bg-color);
      -webkit-text-size-adjust: 100%;
      min-height: 100vh;
      font-size: 16px;
      line-height: 1.5;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
      position: relative;
    }

    /* Halftone pattern overlay */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      opacity: 0.15;
      background-image: radial-gradient(circle, #333 1px, transparent 1px);
      background-size: 20px 20px;
    }

    /* Gradient overlay at bottom */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      background: linear-gradient(to bottom, transparent 0%, transparent 60%, rgba(0,0,0,0.4) 100%);
    }

    /* Comic text outline utility */
    .text-outline-black {
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    /* Comic box shadows */
    .shadow-comic {
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
    }
    .shadow-comic-sm {
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    /* Mobile Header - Comic Style */
    .mobile-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: calc(var(--header-height) + var(--safe-area-top));
      padding-top: var(--safe-area-top);
      background: var(--comic-dark);
      border-bottom: 4px solid #000;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-left: calc(var(--safe-area-left) + 16px);
      padding-right: calc(var(--safe-area-right) + 16px);
      z-index: 1000;
    }

    .mobile-header h1 {
      font-size: 26px;
      margin: 0;
      font-family: 'Bangers', cursive;
      color: var(--primary);
      letter-spacing: 3px;
      text-shadow:
        2px 2px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000;
      -webkit-text-stroke: 1px black;
    }

    .mobile-header-actions {
      display: flex;
      gap: 12px;
    }

    .mobile-header-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      color: var(--primary);
      font-size: 22px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      transition: color 0.2s;
    }

    .mobile-header-btn .material-symbols-outlined {
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 rgba(0,0,0,1);
    }

    .mobile-header-btn:hover {
      color: #34d399;
    }

    .mobile-header-btn:active {
      color: #34d399;
    }

    /* Update Available Banner */
    .update-banner {
      position: fixed;
      top: calc(var(--header-height) + var(--safe-area-top));
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #059669 0%, #10b981 100%);
      border-bottom: 3px solid #000;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      z-index: 999;
      transform: translateY(-100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .update-banner.visible {
      transform: translateY(0);
      opacity: 1;
    }

    .update-banner-text {
      font-family: 'Bangers', cursive;
      font-size: 16px;
      color: white;
      text-shadow: 1px 1px 0 #000;
      letter-spacing: 1px;
    }

    .update-banner-btn {
      background: #fff;
      color: #059669;
      border: 2px solid #000;
      border-radius: 4px;
      padding: 6px 14px;
      font-family: 'Bangers', cursive;
      font-size: 14px;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 2px 2px 0 #000;
      transition: all 0.1s;
      white-space: nowrap;
    }

    .update-banner-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .update-banner-close {
      background: transparent;
      border: none;
      color: white;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
      text-shadow: 1px 1px 0 #000;
    }

    /* Refresh button glow when update available */
    .mobile-menu-refresh.update-available {
      animation: updatePulse 1.5s ease-in-out infinite;
      color: #10b981 !important;
    }

    @keyframes updatePulse {
      0%, 100% {
        box-shadow: 0 0 5px #10b981, 0 0 10px #10b981;
      }
      50% {
        box-shadow: 0 0 15px #10b981, 0 0 25px #10b981;
      }
    }

    /* Bottom Navigation - Comic Style */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: calc(var(--bottom-nav-height) + var(--safe-area-bottom));
      padding-bottom: var(--safe-area-bottom);
      background: var(--comic-dark);
      border-top: 4px solid #000;
      display: flex;
      z-index: 1000;
      padding: 8px;
      padding-bottom: calc(8px + var(--safe-area-bottom));
      gap: 8px;
    }

    .nav-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--primary);
      text-decoration: none;
      font-size: 13px;
      font-family: 'Bangers', cursive;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      padding: 8px 4px;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      border: 2px solid #000;
      background: #333;
      border-radius: 4px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      text-shadow: none;
    }

    .nav-item:hover {
      background: #444;
    }

    .nav-item:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .nav-item.active {
      background: var(--primary);
      color: white;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    /* Mode Toggle (Complex/Simple) */
    .nav-mode-toggle {
      display: flex;
      flex: 2;
      border: 2px solid #000;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      background: #333;
    }

    .nav-toggle-btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 4px;
      background: #333;
      color: var(--primary);
      border: none;
      border-right: 2px solid #000;
      cursor: pointer;
      font-family: 'Bangers', cursive;
      font-size: 13px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      transition: all 0.1s;
    }

    .nav-toggle-btn:last-child {
      border-right: none;
    }

    .nav-toggle-btn:hover {
      background: #444;
    }

    .nav-toggle-btn.active {
      background: var(--primary);
      color: white;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .nav-item-icon {
      font-size: 16px;
      margin-bottom: 2px;
      display: none;
    }

    .nav-item-label {
      font-size: 13px;
      line-height: 1;
    }

    /* Layouts Toggle Container (for switching between Standard/Power/Data/Structure) */
    .layouts-toggle-container {
      position: sticky;
      top: calc(var(--header-height) + var(--safe-area-top));
      background: #222;
      padding: 12px;
      z-index: 100;
      border-bottom: 4px solid #000;
      margin: -12px -12px 12px -12px;
    }

    .layouts-toggle-container .toggle-group {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .layouts-toggle-container .toggle-btn {
      flex: 1;
      min-width: 70px;
      padding: 10px 12px;
      font-size: 12px;
    }

    /* Comic title style */
    h1 {
      margin-bottom: 6px;
      color: var(--primary);
      font-size: 24px;
      font-family: 'Bangers', cursive;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 2px 2px 0px rgba(0,0,0,1);
    }

    .muted { color: var(--muted-color); font-size: 14px; line-height: 1.4; margin-bottom: 16px; }

    .main-container {
      border: none;
      padding: 0;
      border-radius: 2px;
      background: #222;
      border: 4px solid #000;
      border-top: 0;
      position: relative;
      z-index: 1;
      padding: 12px;
    }

    /* Single column layout for mobile */
    .two-column-layout {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Comic Style Section Boxes */
    .section-box {
      background: var(--comic-panel);
      border: 4px solid #000;
      border-radius: 2px;
      padding: 16px;
      padding-top: 28px;
      margin-bottom: 16px;
      margin-top: 12px;
      overflow: visible;
      position: relative;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
    }

    .section-title {
      position: absolute;
      top: -16px;
      left: 16px;
      background: #222;
      border: 1px solid var(--primary);
      padding: 4px 10px;
      margin: 0;
      font-family: 'Bangers', cursive;
      font-size: 16px;
      font-weight: normal;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--primary);
      transform: rotate(-2deg);
      cursor: default;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .section-title::after {
      content: none;
    }

    .section-box.collapsed .section-title::after {
      transform: none;
    }

    .section-content {
      padding: 0;
      transition: none;
      overflow: visible;
    }

    .section-box.collapsed .section-content {
      max-height: none;
      padding-top: 0;
      padding-bottom: 0;
    }

    label {
      display: block;
      color: #d1d5db;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    label span {
      display: block;
      margin-bottom: 4px;
      margin-left: 2px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      font-size: 11px;
      color: #9ca3af;
      text-transform: uppercase;
    }
    
    /* Input styling */
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 12px 14px;
      font-size: 16px; /* Prevents iOS zoom on focus */
      font-family: 'Roboto Condensed', sans-serif;
      background: #333;
      color: #fff;
      border: 2px solid #000;
      border-radius: 0;
      -webkit-appearance: none;
      appearance: none;
      min-height: 48px; /* Touch-friendly */
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    select {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2310b981'%3E%3Cpath d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3), 2px 2px 0px 0px rgba(0,0,0,1);
    }

    /* Hide number input spinners by default */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Compact input fields - still touch friendly */
    .compact-input {
      width: 90px !important;
    }

    .compact-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .compact-row label {
      margin-bottom: 0;
      flex: 1;
      min-width: 80px;
    }

    .compact-row-tight {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    .compact-row-tight label {
      margin-bottom: 0;
    }

    .three-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    .three-inputs label {
      margin-bottom: 0;
    }

    input[type="checkbox"], input[type="radio"] {
      width: 24px;
      height: 24px;
      margin: 0;
      cursor: pointer;
      accent-color: var(--primary);
    }

    .inline-group {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .inline-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-size: 14px;
      min-height: 44px; /* Touch target */
    }

    .two-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .two-inputs label {
      margin-bottom: 0;
    }

    /* Mobile-optimized buttons - Comic Style */
    button {
      padding: 12px 20px;
      font-size: 14px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      cursor: pointer;
      border-radius: 0;
      border: 2px solid #000;
      background: var(--primary);
      color: white;
      width: 100%;
      margin-bottom: 10px;
      min-height: 48px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    button:hover {
      background: var(--primary-hover);
    }

    button:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    @media (min-width: 640px) {
      button {
        width: auto;
        margin-right: 8px;
        margin-bottom: 0;
      }
    }

    /* Desktop layout adjustments */
    @media (min-width: 768px) {
      .main-container {
        max-width: 1200px;
        margin: 0; /* Align to left instead of centered */
        margin-left: 20px; /* Small left margin */
      }

      .two-column-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      .section-box {
        max-width: 100%;
      }

      .layout-container {
        max-width: 1200px;
        margin-left: 20px; /* Align to left */
        margin-right: 0;
      }

      /* Screen tabs alignment with main content */
      #screenTabsContainer {
        max-width: 1200px;
        margin-left: 20px; /* Align to left */
        margin-right: 0;
        box-sizing: border-box;
      }

      #screenTabsContainer .screen-tabs {
        padding-left: 0;
      }

      /* Canvas tabs alignment with canvas container */
      #canvasTabsContainer {
        max-width: 1200px;
        margin-left: 20px;
        margin-right: 0;
        box-sizing: border-box;
      }

      /* Bottom nav constrained width - align with left content */
      .bottom-nav {
        max-width: 600px;
        left: 20px; /* Align with left margin of content */
        transform: none;
        border-radius: 8px 8px 0 0;
        border-left: 4px solid #000;
        border-right: 4px solid #000;
      }

      .nav-item {
        flex: 0 1 100px;
      }

      /* Canvas options constrained inputs */
      #canvasContainer .section-box {
        max-width: 500px;
      }

      #canvasContainer .section-content input,
      #canvasContainer .section-content select,
      #canvasContainer .section-content button {
        max-width: 100%;
      }

      /* Layout canvases - no max-width constraint on desktop */
      #standardCanvas, #structureCanvas, #powerCanvas, #dataCanvas {
        max-width: none;
      }

      /* Layout container - no overflow scroll on desktop */
      .layout-container {
        overflow-x: visible;
      }

    }
    
    .button-row {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .result {
      margin-top: 32px;
      background: var(--comic-panel);
      padding: 16px;
      padding-top: 24px;
      border: 4px solid #000;
      border-radius: 2px;
      color: #e0e0e0;
      font-size: 13px;
      overflow: visible;
      font-family: 'Roboto Condensed', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      line-height: 1.6;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
      position: relative;
    }

    .result-section {
      margin-bottom: 16px;
    }

    .result-section-title {
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      margin-bottom: 4px;
      margin-top: 12px;
      color: var(--primary);
    }

    .result-row {
      margin: 2px 0;
    }

    .result-row strong {
      font-weight: 600;
      color: #ffffff;
    }

    .result-indent {
      margin-left: 20px;
    }

    canvas {
      border: 2px solid #000;
      margin-top: 12px;
      display: block;
      background: #fff;
    }

    /* Layout canvases - responsive on mobile */
    #standardCanvas, #structureCanvas, #powerCanvas, #dataCanvas {
      max-width: 100%;
      height: auto;
    }

    /* Canvas view can be responsive */
    #canvasView {
      max-width: 100%;
      height: auto;
      background: #000;
    }

    /* Canvas view wrapper responsive on mobile */
    #canvasViewWrapper {
      max-width: 100%;
    }

    #canvasContainer {
      overflow-x: hidden;
    }

    /* Layout container overflow handling for mobile */
    .layout-container {
      overflow-x: auto;
      overflow-y: visible;
    }

    canvas:focus {
      outline: 3px solid var(--primary);
      outline-offset: 2px;
    }

    .layout-container {
      margin-top: 32px;
      padding: 16px;
      padding-top: 24px;
      background: var(--comic-panel);
      border: 4px solid #000;
      border-radius: 0; /* Removed to fix diagonal line artifacts on Windows */
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
      position: relative;
      overflow: visible;
    }

    .layout-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .layout-title > span,
    .layout-title-text {
      position: absolute;
      top: -16px;
      left: 16px;
      background: #222;
      border: 1px solid var(--primary);
      padding: 4px 10px;
      padding-right: 32px;
      font-family: 'Bangers', cursive;
      font-size: 16px;
      font-weight: normal;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--primary);
      transform: rotate(-2deg);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
      z-index: 20;
    }
    
    .undo-redo-buttons {
      display: flex;
      gap: 8px;
      margin-left: 16px;
      margin-top: 20px;
    }
    
    .undo-redo-btn {
      padding: 6px 12px;
      font-size: 11px;
      font-family: 'Roboto Condensed', sans-serif;
      background: #333;
      color: #e0e0e0;
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .undo-redo-btn:hover:not(:disabled) {
      background: #444;
    }

    .undo-redo-btn:active:not(:disabled) {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .undo-redo-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Collapse/Expand button for layout containers */
    .layout-collapse-btn {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      min-width: 16px;
      max-width: 16px;
      min-height: 16px;
      max-height: 16px;
      aspect-ratio: 1 / 1;
      background: transparent;
      border: none;
      padding: 0;
      font-size: 10px;
      color: var(--primary);
      cursor: pointer;
      line-height: 0;
      transition: transform 0.2s ease;
      box-sizing: border-box;
      overflow: hidden;
    }

    .layout-collapse-btn.collapsed {
      transform: translateY(-50%) rotate(-90deg);
    }

    .layout-collapse-btn:hover {
      background: var(--primary);
      color: #000;
    }

    /* Desktop: position collapse button between text and right edge of header */
    @media (min-width: 768px) {
      .layout-collapse-btn {
        right: 3px;
      }
    }

    .layout-content {
      overflow: hidden;
    }

    .layout-content.collapsed {
      display: none;
    }

    .layout-container.collapsed {
      padding-bottom: 20px;
    }

    .canvas-zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-right: 16px;
    }

    .zoom-btn {
      padding: 6px 12px;
      font-size: 14px;
      font-weight: bold;
      font-family: 'Roboto Condensed', sans-serif;
      background: #333;
      color: #e0e0e0;
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.1s;
      min-width: 32px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .zoom-btn:hover {
      background: #444;
    }

    .zoom-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    #canvasZoomInput {
      width: 55px;
      padding: 6px;
      font-size: 12px;
      text-align: center;
      background: #333;
      color: #fff;
      border: 2px solid #000;
      border-radius: 0;
      font-family: 'Bangers', cursive;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    #canvasZoomInput:focus {
      outline: none;
      border-color: var(--primary);
    }

    .zoom-percent {
      font-size: 12px;
      color: #ccc;
    }
    
    .warn {
      color: #ff6b6b;
      font-weight: bold;
      font-size: 13px;
      margin-top: 12px;
    }
    
    .hint {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
    }
    
    .secondary-button {
      width: 100%;
      padding: 10px;
      background: #333;
      color: var(--primary);
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow: none;
      margin-bottom: 0;
      min-height: auto;
    }

    .secondary-button:hover {
      background: #444;
    }

    .secondary-button:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .secondary-button.active {
      background: var(--primary);
      color: #fff;
      border: 2px solid #000 !important;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1) !important;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }
    
    .canvas-with-options {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 20px;
      align-items: start;
    }
    
    @media (max-width: 1200px) {
      .canvas-with-options {
        grid-template-columns: 1fr;
      }
    }
    
    .bumper-controls {
      margin-top: 10px;
      padding: 10px;
      background: #333;
      border-radius: 4px;
    }
    
    .bumper-column-input {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    .bumper-column-input input {
      width: 80px;
    }
    
    .weight-display {
      margin-top: 12px;
      padding: 10px;
      background: #1a1a1a;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .weight-item {
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    
    .weight-item:last-child {
      border-bottom: none;
    }
    
    /* Structure Manual Mode Toggle */
    .structure-mode-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding: 8px 12px;
      background: #333;
      border-radius: 6px;
    }
    
    .structure-mode-hint {
      font-size: 12px;
      color: #888;
      margin-left: auto;
    }
    
    .structure-selection-info {
      padding: 8px 12px;
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 4px;
      margin-bottom: 12px;
      font-size: 12px;
      color: #10b981;
      display: none;
    }
    
    .structure-selection-info.visible {
      display: block;
    }
    
    /* Structure Layout with info panel below */
    .structure-layout-wrapper {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .structure-canvas-area {
      width: 100%;
    }
    
    .structure-info-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    
    .structure-info-box {
      background: #1a1a1a;
      border-radius: 6px;
      padding: 12px;
      font-size: 12px;
    }
    
    .structure-info-box.weights {
      border-left: 3px solid #4a9eff;
    }
    
    .structure-info-box.plates {
      border-left: 3px solid #6fc276;
    }
    
    .structure-info-box.ground-support {
      border-left: 3px solid #00CED1;
    }
    
    .structure-info-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .structure-info-title.weights { color: #4a9eff; }
    .structure-info-title.plates { color: #6fc276; }
    .structure-info-title.ground-support { color: #00CED1; }
    
    .weight-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    
    .weight-row:last-child {
      border-bottom: none;
    }
    
    .weight-label {
      color: #aaa;
    }
    
    .weight-value {
      font-weight: 600;
      color: #fff;
    }
    
    .plates-row {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
    }
    
    .plates-label {
      color: #aaa;
    }
    
    .plates-value {
      font-weight: 600;
      color: #fff;
    }
    
    .plates-total {
      border-top: 1px solid #3a5a3a;
      margin-top: 6px;
      padding-top: 6px;
    }
    
    @media (max-width: 600px) {
      .structure-info-panel {
        grid-template-columns: 1fr;
      }

      /* Constrain bumper toggle buttons width on mobile */
      #useBumpersBtn, #use4WayBumpersBtn {
        max-width: 120px;
        flex: none;
      }

      #manualBumperToggle {
        max-width: 140px;
        font-size: 10px;
        padding: 6px 8px;
      }
    }
    
    /* Toggle Buttons - Comic Style */
    .toggle-group, .unit-toggle-group {
      display: flex;
      gap: 8px;
    }

    /* Toggle buttons */
    .toggle-btn, .unit-toggle-btn {
      padding: 10px 16px;
      font-size: 13px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      background: #333;
      color: #9ca3af;
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.1s;
      min-width: 44px;
      min-height: 44px;
      text-align: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      width: auto;
      margin-bottom: 0;
    }

    .toggle-btn:hover, .unit-toggle-btn:hover {
      color: #fff;
      background: #444;
    }

    /* Slider toggle (merged toggle buttons) */
    .slider-toggle {
      display: flex;
      border: 2px solid #000;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      background: #333;
    }

    .slider-toggle-btn {
      padding: 10px 14px;
      font-size: 13px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      background: transparent;
      color: #9ca3af;
      border: none;
      border-right: 2px solid #000;
      cursor: pointer;
      transition: all 0.15s;
      flex: 1;
      min-height: 44px;
      text-align: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      text-shadow: none;
      box-shadow: none;
      width: auto;
      margin-bottom: 0;
    }

    /* Desktop: constrain toggle width */
    @media (min-width: 769px) {
      .slider-toggle {
        display: inline-flex;
      }
      .slider-toggle-btn {
        flex: none;
      }
    }

    .slider-toggle-btn:last-child {
      border-right: none;
    }

    .slider-toggle-btn.active {
      background: var(--primary);
      color: #fff;
      border-right: 2px solid #000;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .slider-toggle-btn.active:last-child {
      border-right: none;
    }

    .slider-toggle-btn:hover:not(.active) {
      background: #444;
      color: #fff;
    }

    /* Number input with spinner arrows */
    .number-input-with-arrows {
      display: flex;
      border: 2px solid #000;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      background: #333;
    }

    .number-input-with-arrows input {
      flex: 1;
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 14px;
      padding: 6px 4px;
      text-align: center;
      min-width: 40px;
      width: 45px;
      box-shadow: none;
      min-height: auto;
    }

    .number-input-with-arrows input:focus {
      outline: none;
      box-shadow: none;
    }

    .number-input-arrows {
      display: flex;
      flex-direction: column;
      border-left: 2px solid #000;
      background: #222;
      width: 28px;
    }

    .number-input-arrows button {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--primary);
      cursor: pointer;
      padding: 0;
      margin: 0;
      min-height: 20px;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      box-shadow: none;
      text-shadow: none;
      transition: background 0.1s;
    }

    .number-input-arrows button:first-child {
      border-bottom: 2px solid #000;
    }

    .number-input-arrows button:hover {
      background: #333;
    }

    .number-input-arrows button:active {
      background: #444;
      transform: none;
    }

    .toggle-btn:active, .unit-toggle-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .toggle-btn.active, .unit-toggle-btn.active {
      background: var(--primary);
      color: #fff;
      border: 2px solid #000;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .toggle-btn.active:hover, .unit-toggle-btn.active:hover {
      background: var(--primary-hover);
    }

    .unit-toggles-row {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .toggle-label, .unit-toggle-label {
      font-family: 'Roboto Condensed', sans-serif;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      color: #9ca3af;
      margin-right: 6px;
    }

    /* Modal Dialog Styles - Comic Style */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    #requestItemModal {
      z-index: 10001;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-dialog {
      background: var(--comic-panel);
      border: 4px solid #000;
      border-radius: 2px;
      padding: 16px;
      max-width: 420px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #000;
    }

    .modal-title {
      font-size: 18px;
      font-family: 'Bangers', cursive;
      font-weight: normal;
      letter-spacing: 1px;
      color: var(--primary);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .modal-close {
      background: none;
      border: 2px solid #000;
      color: #ff6b6b;
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      line-height: 28px;
      text-align: center;
      border-radius: 2px;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .modal-close:hover {
      background: #ff6b6b;
      color: #fff;
    }

    .modal-close:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .modal-body {
      margin-bottom: 12px;
    }

    .manage-custom-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
      border-bottom: 2px solid #444;
      padding-bottom: 8px;
    }

    .manage-tab {
      flex: 1;
      padding: 8px 12px;
      background: #333;
      border: 2px solid #000;
      color: #888;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: none;
    }

    .manage-tab.active {
      background: var(--primary);
      color: #000;
    }

    .manage-tab:hover:not(.active) {
      background: #444;
      color: #fff;
    }

    .manage-tab-content {
      min-height: 100px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding-top: 10px;
      border-top: 1px solid #444;
    }
    
    .modal-input-group {
      margin-bottom: 8px;
    }
    
    .modal-input-group label {
      display: block;
      margin-bottom: 3px;
      color: #e0e0e0;
      font-size: 11px;
      font-weight: 500;
    }
    
    .modal-input-group input[type="text"],
    .modal-input-group input[type="number"] {
      width: 100%;
      padding: 5px 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
    }
    
    .modal-input-group input:focus {
      outline: none;
      border-color: #0a66c2;
    }
    
    .modal-input-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    .modal-input-group .hint {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
    }
    
    .checkbox-group,
    .modal-checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
      font-size: 12px;
    }

    .checkbox-group input[type="checkbox"],
    .modal-checkbox-group input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }

    .checkbox-group label,
    .modal-checkbox-group label {
      color: #e0e0e0;
      font-size: 12px;
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
      border: 2px solid #000;
      padding: 8px 16px;
      border-radius: 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
      width: auto;
      margin-bottom: 0;
      min-height: auto;
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-primary:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .btn-secondary {
      background: #333;
      color: #e0e0e0;
      border: 2px solid #000;
      padding: 8px 16px;
      border-radius: 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow: none;
      width: auto;
      margin-bottom: 0;
      min-height: auto;
    }

    .btn-secondary:hover {
      background: #444;
    }

    .btn-secondary:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .btn-danger {
      background: #dc2626;
      color: white;
      border: 2px solid #000;
      padding: 10px 20px;
      border-radius: 0;
      cursor: pointer;
      font-size: 14px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
      width: auto;
      margin-bottom: 0;
      min-height: auto;
    }

    .btn-danger:hover {
      background: #b91c1c;
    }

    .btn-danger:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }
    
    .custom-item-list {
      margin-top: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .custom-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #333;
      border: 1px solid #444;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    
    .custom-item:hover {
      background: #3a3a3a;
    }
    
    .custom-item-name {
      flex: 1;
      color: #e0e0e0;
      font-size: 14px;
    }
    
    .custom-item-actions {
      display: flex;
      gap: 8px;
    }
    
    .btn-small {
      padding: 4px 12px;
      font-size: 12px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      border-radius: 0;
      cursor: pointer;
      border: 2px solid #000;
      background: #333;
      color: #e0e0e0;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .btn-small:hover {
      background: #555;
    }

    .btn-small.danger {
      background: #c53030;
      border-color: #000;
      color: white;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .btn-small.danger:hover {
      background: #a02828;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .checkbox-group label {
      margin: 0;
      cursor: pointer;
      user-select: none;
    }
    
    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      color: #e0e0e0;
      font-size: 13px;
      transition: background 0.2s;
    }
    
    .context-menu-item:hover {
      background: #3a3a3a;
    }
    
    /* ==================== SCREEN TABS STYLES - Comic Style ==================== */
    .screen-tabs-container {
      display: flex;
      align-items: flex-end;
      padding: 8px 8px 0 8px;
      gap: 8px;
      overflow-x: visible; /* Allow wrapping instead of scrolling */
      background: var(--comic-dark);
    }

    .screen-tabs {
      display: flex;
      gap: 4px; /* Reduced gap for tighter spacing */
      margin-bottom: 0;
      flex-wrap: wrap; /* Allow wrapping to new rows */
      border-bottom: none;
      padding-top: 14px; /* Offset for first row negative margin */
      padding-bottom: 0;
      align-items: flex-end;
    }

    .screen-tab {
      padding: 10px 16px;
      background: var(--comic-panel);
      border: 4px solid #000;
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.1s;
      position: relative;
      top: 0;
      color: #fff;
      min-height: 44px;
      margin-top: -10px; /* Overlap tabs when they wrap - pulls rows up */
    }

    .screen-tab:hover {
      background: #333;
    }

    .screen-tab.active {
      background: var(--comic-panel);
      border-color: #000;
      color: var(--primary);
      z-index: 10;
    }

    .screen-tab-name {
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      font-size: 13px;
      white-space: nowrap;
    }

    .screen-tab-edit {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 12px;
      border-radius: 2px;
      width: auto;
      margin: 0;
      min-height: auto;
      min-width: auto;
      box-shadow: none;
    }

    .screen-tab-edit:hover {
      color: #fff;
    }

    .screen-tab-close {
      background: none !important;
      border: none !important;
      color: #ff6b6b;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 18px;
      line-height: 1;
      border-radius: 2px;
      width: auto !important;
      margin: 0 !important;
      min-height: 24px;
      min-width: 24px;
      box-shadow: none !important;
      text-shadow: none !important;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .screen-tab-close:hover {
      color: #ff4444;
      background: rgba(255, 107, 107, 0.2) !important;
    }

    .screen-tab-close:active {
      transform: none;
    }

    .screen-tab-add {
      padding: 8px 12px;
      background: var(--primary);
      border: 4px solid #000;
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.1s;
      position: relative;
      top: 4px;
      min-height: 44px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .screen-tab-add:hover {
      background: var(--primary-hover);
    }

    .screen-tab-add:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }
    /* ==================== END SCREEN TABS STYLES ==================== */
    
    /* Header with config buttons */
    .page-header {
      display: flex;
      justify-content: flex-end;
      align-items: flex-start;
      margin-bottom: 6px;
      padding-top: 50px; /* Space for background image title */
    }
    
    .page-header h1 {
      margin: 0;
    }
    
    .config-buttons {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 6px;
    }
    
    .config-buttons input[type="text"] {
      padding: 6px 10px;
      font-size: 12px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      width: 150px;
    }
    
    .config-buttons input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.7);
    }
    
    .config-btn {
      padding: 8px 14px;
      font-size: 12px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      cursor: pointer;
      border-radius: 0;
      border: 2px solid #000;
      color: white;
      transition: all 0.1s;
      white-space: nowrap;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .config-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .config-btn.save {
      background: var(--primary);
    }

    .config-btn.save:hover {
      background: var(--primary-hover);
    }

    .config-btn.load {
      background: #3498db;
    }

    .config-btn.load:hover {
      background: #2980b9;
    }

    .config-btn.export-pdf {
      background: #8e44ad;
    }

    .config-btn.export-pdf:hover {
      background: #7d3c98;
    }
    
    .header-buttons-row {
      display: flex;
      align-items: center;
    }

    /* Hide desktop-only elements on mobile */
    .desktop-only {
      display: none;
    }

    /* Mobile Menu Overlay - Comic Style */
    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .mobile-menu-overlay.active {
      display: block;
      opacity: 1;
    }

    .mobile-menu {
      position: absolute;
      top: 0;
      right: 0;
      width: 85%;
      max-width: 320px;
      height: 100%;
      background: var(--comic-dark);
      border-left: 4px solid #000;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .mobile-menu-overlay.active .mobile-menu {
      transform: translateX(0);
    }

    .mobile-menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      padding-top: calc(var(--safe-area-top) + 16px);
      border-bottom: 4px solid #000;
      font-size: 20px;
      font-family: 'Bangers', cursive;
      letter-spacing: 2px;
      color: var(--primary);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .mobile-menu-close {
      width: 44px;
      height: 44px;
      border: 2px solid #000;
      background: transparent;
      color: #ff6b6b;
      font-size: 24px;
      cursor: pointer;
      border-radius: 0; /* Removed to fix diagonal line artifacts on Windows */
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-menu-close:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .mobile-menu-refresh {
      width: 44px;
      height: 44px;
      border: 2px solid #000;
      background: transparent;
      color: var(--primary);
      font-size: 28px;
      cursor: pointer;
      border-radius: 0; /* Removed to fix diagonal line artifacts on Windows */
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      margin-left: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-menu-refresh:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .mobile-menu-content {
      padding: 16px 20px;
      padding-bottom: calc(var(--safe-area-bottom) + 20px);
    }

    .mobile-menu-section {
      margin-bottom: 24px;
    }

    .mobile-menu-label {
      font-size: 11px;
      font-weight: 700;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }

    .mobile-menu-btn {
      width: 100%;
      padding: 10px 12px;
      margin-bottom: 8px;
      background: #333;
      border: 2px solid #000;
      border-radius: 0; /* Removed to fix diagonal line artifacts on Windows */
      color: var(--primary);
      font-size: 13px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      text-align: left;
      cursor: pointer;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      text-shadow: none;
      min-height: auto;
    }

    .mobile-menu-btn.accent {
      color: var(--accent-color);
    }

    .mobile-menu-btn-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .mobile-menu-btn-row .mobile-menu-btn {
      flex: 1;
      margin-bottom: 0;
      text-align: center;
    }

    .mobile-menu-btn:hover {
      background: var(--primary);
      color: #fff;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .mobile-menu-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .mobile-menu-btn.install-btn {
      background: var(--primary);
      color: #fff;
      font-weight: normal;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .mobile-menu-info {
      font-size: 12px;
      color: var(--muted-color);
      margin-bottom: 4px;
    }

    /* View Containers - Mobile optimized */
    .view-container {
      display: none;
    }

    .view-container.active {
      display: block;
    }

    /* Mobile canvas wrapper */
    .mobile-canvas-wrapper {
      width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      border: 2px solid #000;
      border-radius: 2px;
      background: #000;
    }

    /* Landscape orientation hint */
    .orientation-hint {
      display: none;
      padding: 12px 16px;
      background: rgba(16, 185, 129, 0.15);
      border: 2px solid var(--primary);
      border-radius: 2px;
      margin-bottom: 12px;
      font-size: 13px;
      color: var(--primary);
    }

    @media (orientation: portrait) {
      .orientation-hint.show-in-portrait {
        display: block;
      }
    }

    /* Touch canvas controls */
    .touch-zoom-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .touch-zoom-btn {
      flex: 1;
      min-width: 70px;
      padding: 12px;
      background: #333;
      border: 2px solid #000;
      border-radius: 0;
      color: var(--text-color);
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      font-size: 18px;
      cursor: pointer;
    }

    .touch-zoom-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    /* Mobile-friendly context menus - Comic Style */
    #panelContextMenu,
    #bumperContextMenu {
      min-width: 250px !important;
      border-radius: 2px !important;
      border: 2px solid #000 !important;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1) !important;
      overflow: hidden;
    }

    #panelContextMenu > div,
    #bumperContextMenu > div,
    .context-menu-item {
      padding: 14px 16px;
      font-size: 14px;
      font-family: 'Roboto Condensed', sans-serif;
      font-weight: 700;
      min-height: 48px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #444;
    }

    /* Mobile hint text */
    .mobile-hint {
      display: block;
      padding: 10px 16px;
      background: rgba(16, 185, 129, 0.15);
      border: 2px solid var(--primary);
      border-radius: 0; /* Removed to fix diagonal line artifacts on Windows */
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--primary);
    }

    /* Hide desktop hints, show mobile hints */
    .hint:not(.mobile-hint) {
      display: none;
    }

  </style>
</head>
<body>
<!-- Custom Panel Modal -->
<div id="customPanelModal" class="modal-overlay">
  <div class="modal-dialog">
    <div class="modal-header">
      <h2 class="modal-title" id="customPanelModalTitle">Add Custom Panel</h2>
      <button class="modal-close" onclick="closeCustomPanelModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="modal-input-group">
        <label>Panel Brand</label>
        <input type="text" id="customPanelBrand" placeholder="e.g., ROE Visual">
      </div>
      
      <div class="modal-input-group">
        <label>Panel Name</label>
        <input type="text" id="customPanelName" placeholder="e.g., Black Pearl BP2">
      </div>
      
      <div class="modal-input-group">
        <label id="labelPixelPitch">Pixel Pitch (mm)</label>
        <input type="number" id="customPanelPixelPitch" step="0.01" placeholder="e.g., 2.84">
      </div>

      <div class="modal-input-row">
        <div class="modal-input-group">
          <label id="labelPanelWidth">Panel Width (mm)</label>
          <input type="number" id="customPanelWidth" step="0.1" placeholder="e.g., 500">
        </div>
        <div class="modal-input-group">
          <label id="labelPanelHeight">Panel Height (mm)</label>
          <input type="number" id="customPanelHeight" step="0.1" placeholder="e.g., 500">
        </div>
      </div>

      <div class="modal-input-group">
        <label id="labelPanelDepth">Panel Depth (mm)</label>
        <input type="number" id="customPanelDepth" step="0.1" placeholder="e.g., 90">
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Resolution Width (px)</label>
          <input type="number" id="customPanelResX" placeholder="e.g., 176">
        </div>
        <div class="modal-input-group">
          <label>Resolution Height (px)</label>
          <input type="number" id="customPanelResY" placeholder="e.g., 176">
        </div>
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Max Power (W)</label>
          <input type="number" id="customPanelPowerMax" step="1" placeholder="e.g., 250">
        </div>
        <div class="modal-input-group">
          <label>Avg Power (W)</label>
          <input type="number" id="customPanelPowerAvg" step="1" placeholder="e.g., 125">
        </div>
      </div>
      
      <div class="modal-input-group">
        <label>Brightness (nits)</label>
        <input type="number" id="customPanelBrightness" placeholder="e.g., 5000">
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Max Panels Hanging</label>
          <input type="number" id="customPanelMaxHanging" placeholder="e.g., 20">
        </div>
        <div class="modal-input-group">
          <label>Max Panels Stacking</label>
          <input type="number" id="customPanelMaxStacking" placeholder="e.g., 12">
        </div>
      </div>

      <div class="modal-input-group">
        <label id="labelPanelWeight">Panel Weight (kg)</label>
        <input type="number" id="customPanelWeight" step="0.1" placeholder="e.g., 8.5">
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="customPanelRemovableFrame" onchange="updateFrameWeightFields()">
        <label for="customPanelRemovableFrame">Has Removable Frame</label>
      </div>

      <div id="frameWeightFields" style="display: none;">
        <div class="modal-input-row">
          <div class="modal-input-group">
            <label id="labelFrameWeight">Frame Weight (kg)</label>
            <input type="number" id="customPanelFrameWeight" step="0.1" placeholder="e.g., 1.2">
          </div>
          <div class="modal-input-group">
            <label id="labelWeightNoFrame">Weight Without Frame (kg)</label>
            <input type="number" id="customPanelWeightNoFrame" step="0.1" placeholder="e.g., 7.3">
          </div>
        </div>
      </div>

      <div class="modal-input-row">
        <div class="modal-input-group">
          <label id="label1wBumper">1W Bumper Weight (lbs)</label>
          <input type="number" id="customPanel1wBumper" step="0.1" placeholder="e.g., 5.5">
        </div>
        <div class="modal-input-group">
          <label id="label2wBumper">2W Bumper Weight (lbs)</label>
          <input type="number" id="customPanel2wBumper" step="0.1" placeholder="e.g., 8.8">
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" onclick="closeCustomPanelModal()">Cancel</button>
      <button class="btn-primary" onclick="saveCustomPanel()">Save Panel</button>
    </div>
  </div>
</div>

<!-- PDF Export Options Modal -->
<div id="pdfExportModal" class="modal-overlay">
  <div class="modal-dialog" style="max-width: 360px;">
    <div class="modal-header">
      <h2 class="modal-title" id="pdfExportModalTitle">Export Options</h2>
      <button class="modal-close" onclick="closePdfExportModal()">&times;</button>
    </div>
    <div class="modal-body">
      <p style="color: #888; font-size: 11px; margin-bottom: 10px;">Select which sections to include:</p>
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportSpecs" checked style="width: 16px; height: 16px; accent-color: var(--primary);">
          <span style="font-size: 12px;">Specifications</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportGearList" checked style="width: 16px; height: 16px; accent-color: var(--primary);">
          <span style="font-size: 12px;">Gear List</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportStandard" checked style="width: 16px; height: 16px; accent-color: var(--primary);">
          <span style="font-size: 12px;">Standard Layout</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportPower" checked style="width: 16px; height: 16px; accent-color: var(--primary);">
          <span style="font-size: 12px;">Power Layout</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportData" checked style="width: 16px; height: 16px; accent-color: var(--primary);">
          <span style="font-size: 12px;">Data Layout</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportStructure" checked style="width: 16px; height: 16px; accent-color: var(--primary);">
          <span style="font-size: 12px;">Structure Layout</span>
        </label>
      </div>
      <hr style="border: none; border-top: 1px solid #444; margin: 14px 0 10px 0;">
      <p style="color: #888; font-size: 11px; margin-bottom: 10px;">Print options:</p>
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportEcoFriendly" style="width: 16px; height: 16px; accent-color: var(--primary);" onchange="if(this.checked) document.getElementById('pdfExportGreyscale').checked = false;">
          <span style="font-size: 12px;">Eco Friendly</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="pdfExportGreyscale" style="width: 16px; height: 16px; accent-color: var(--primary);" onchange="if(this.checked) document.getElementById('pdfExportEcoFriendly').checked = false;">
          <span style="font-size: 12px;">Greyscale</span>
        </label>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" onclick="closePdfExportModal()">Cancel</button>
      <button class="btn-primary" id="pdfExportModalBtn" onclick="confirmPdfExport()">Export</button>
    </div>
  </div>
</div>

<!-- Request Item Modal -->
<div id="requestItemModal" class="modal-overlay">
  <div class="modal-dialog">
    <div class="modal-header">
      <h2 class="modal-title" id="requestItemModalTitle">Request Panel/Processor</h2>
      <button class="modal-close" onclick="closeRequestItemModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="modal-input-group">
        <label>Request Type</label>
        <div class="slider-toggle" style="margin-top: 4px;">
          <button type="button" class="slider-toggle-btn active" id="requestTypePanelBtn" onclick="setRequestType('panel')" style="padding: 8px 16px;">Panel</button>
          <button type="button" class="slider-toggle-btn" id="requestTypeProcessorBtn" onclick="setRequestType('processor')" style="padding: 8px 16px;">Processor</button>
        </div>
      </div>

      <div class="modal-input-group">
        <label>Brand / Manufacturer</label>
        <input type="text" id="requestBrand" placeholder="e.g., ROE Visual, Brompton, NovaStar">
      </div>

      <div class="modal-input-group">
        <label>Model Name</label>
        <input type="text" id="requestModel" placeholder="e.g., Black Pearl 2, Tessera SX40">
      </div>

      <div class="modal-input-group">
        <label>Additional Info (optional)</label>
        <textarea id="requestNotes" placeholder="Any other details, specs, or links to spec sheets..." style="width: 100%; min-height: 60px; resize: vertical; padding: 8px; border-radius: 4px; border: 1px solid #444; background: #2a2a2a; color: #fff;"></textarea>
      </div>

      <div class="hint" style="margin-top: 8px; text-align: center; color: #888;">
        This will open your email app with a pre-filled request.
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" onclick="closeRequestItemModal()">Cancel</button>
      <button class="btn-primary" onclick="sendItemRequest()">Send Request</button>
    </div>
  </div>
</div>

<!-- Manage Custom Items Modal -->
<div id="manageCustomModal" class="modal-overlay">
  <div class="modal-dialog">
    <div class="modal-header">
      <h2 class="modal-title">Manage Custom Panels</h2>
      <button class="modal-close" onclick="closeManageCustomModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div id="manageCustomPanelsContent" class="manage-tab-content"></div>
    </div>
    <div class="modal-footer" style="justify-content: space-between;">
      <button class="btn-secondary" onclick="openRequestItemModal()" style="background: transparent; border: 1px solid var(--accent-color); color: var(--accent-color);">Request New Item</button>
      <button class="btn-primary" onclick="closeManageCustomModal()">Done</button>
    </div>
  </div>
</div>

<!-- Mobile Header -->
<header class="mobile-header">
  <h1>LED CALCULATOR</h1>
  <div class="mobile-header-actions">
    <button class="mobile-header-btn" onclick="document.getElementById('loadConfigInput').click()" title="Load Config">
      <span class="material-symbols-outlined">folder</span>
    </button>
    <button class="mobile-header-btn" onclick="saveConfiguration()" title="Save Config">
      <span class="material-symbols-outlined">save</span>
    </button>
    <button class="mobile-header-btn" onclick="toggleMobileMenu()" title="Menu">
      <span class="material-symbols-outlined">menu</span>
    </button>
  </div>
</header>

<!-- Update Available Banner -->
<div id="updateBanner" class="update-banner">
  <span class="update-banner-text">New version <span id="updateVersionText"></span></span>
  <button class="update-banner-btn" onclick="hardRefreshApp()">Tap to Update</button>
  <button class="update-banner-close" onclick="hideUpdateBanner()">&times;</button>
</div>

<!-- Mobile Menu Overlay -->
<div id="mobileMenuOverlay" class="mobile-menu-overlay" onclick="closeMobileMenu()">
  <div class="mobile-menu" onclick="event.stopPropagation()">
    <div class="mobile-menu-header">
      <div style="display: flex; flex-direction: column; align-items: flex-start;">
        <span>Settings</span>
        <span id="menuVersionNumber" style="font-size: 10px; color: rgba(255,255,255,0.6); margin-top: 2px;"></span>
      </div>
      <button class="mobile-menu-refresh" onclick="hardRefreshApp();" title="Refresh App">&#x21bb;</button>
      <button class="mobile-menu-close" onclick="closeMobileMenu()">&times;</button>
    </div>
    <div class="mobile-menu-content">
      <div class="mobile-menu-section">
        <div class="mobile-menu-label">Configuration</div>
        <input type="text" id="configName" placeholder="Config name..." style="margin-bottom: 12px;">
        <div class="mobile-menu-btn-row">
          <button class="mobile-menu-btn" onclick="saveConfiguration(); closeMobileMenu();">Save</button>
          <button class="mobile-menu-btn" onclick="document.getElementById('loadConfigInput').click()">Load</button>
          <input type="file" id="loadConfigInput" accept=".ledconfig" style="display: none;" onchange="loadConfiguration(event); closeMobileMenu();">
          <button id="btnExportPDF" class="mobile-menu-btn accent" onclick="closeMobileMenu();">Export</button>
        </div>
      </div>
      <div class="mobile-menu-section">
        <div class="mobile-menu-label">Custom Items</div>
        <button class="mobile-menu-btn" onclick="openProcessorRequestModal(); closeMobileMenu();">Request Custom Processor</button>
        <button class="mobile-menu-btn" onclick="openCustomPanelModal(); closeMobileMenu();">Add Custom Panel</button>
        <button class="mobile-menu-btn accent" onclick="openManageCustomModal(); closeMobileMenu();">Manage Custom Panels</button>
      </div>
      <div class="mobile-menu-section">
        <div class="mobile-menu-label" style="color: var(--accent-color);">App Info</div>
        <div class="mobile-menu-info">An LED wall calculator for planning LED video wall installations. Calculate equipment needs, visualize layouts, generate gear lists, and export detailed PDF reports.</div>
        <div class="mobile-menu-info" style="color: #d47a7a; font-size: 10px;">The calculations provided by this app are approximations intended for planning and estimation purposes only. They do not constitute professional structural analysis or engineering certification. Users are responsible for verifying all specifications and consulting qualified professionals before implementation. The developer assumes no liability for any damages, injuries, or losses arising from the use of this application.</div>
        <div class="mobile-menu-info">© 2025 Gabriel Labrecque<br>Fearless Wanderer Productions</div>
        <button class="mobile-menu-btn install-btn" id="installPwaBtn" style="display: none;" onclick="installPwa()">📲 Install App</button>
      </div>
    </div>
  </div>
</div>

<!-- Legacy page header (hidden on mobile) -->
<div class="page-header desktop-only">
  <div>
    <!-- Title and description hidden - they're in the background image -->
  </div>
  <div class="header-buttons-row">
    <div class="config-buttons">
      <button class="config-btn save" onclick="saveConfiguration()">💾 Save</button>
      <button class="config-btn load" onclick="document.getElementById('loadConfigInput').click()">📂 Load</button>
    </div>
  </div>
</div>


  <!-- Screen Tabs Container -->
  <div id="screenTabsContainer" style="display: flex; align-items: flex-end; gap: 4px;"><div id="screenAddBtn" class="screen-tab-add" onclick="addNewScreen()" title="Add new screen" style="flex-shrink: 0; margin-left: auto;">+</div></div>

  <!-- Screen Rename Modal -->
  <div id="screenRenameModal" class="modal-overlay">
    <div class="modal-dialog" style="max-width: 400px;">
      <div class="modal-header">
        <h2 class="modal-title">Edit Screen</h2>
        <button class="modal-close" onclick="closeScreenRenameModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="modal-input-group">
          <label>Screen Name</label>
          <input type="text" id="screenRenameInput" placeholder="e.g., Main IMAG">
        </div>
        <div class="modal-input-group">
          <label>Primary Color</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="color" id="screenColorInput" style="width: 60px; height: 40px; border: 1px solid #444; border-radius: 4px; background: #2a2a2a; cursor: pointer;">
            <span id="screenColorPreview" style="flex: 1; padding: 8px 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; font-family: monospace; font-size: 12px;"></span>
          </div>
        </div>
        <div class="modal-input-group">
          <label>Secondary Color</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="color" id="screenColor2Input" style="width: 60px; height: 40px; border: 1px solid #444; border-radius: 4px; background: #2a2a2a; cursor: pointer;">
            <span id="screenColor2Preview" style="flex: 1; padding: 8px 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; font-family: monospace; font-size: 12px;"></span>
          </div>
          <div class="hint">Panels alternate between primary and secondary colors in Standard Layout and Canvas View</div>
        </div>
      </div>
      <div class="modal-footer" style="display: flex; gap: 8px; justify-content: flex-end;">
        <button class="btn-secondary" onclick="closeScreenRenameModal()">Cancel</button>
        <button class="btn-primary" onclick="saveScreenRename()">Save</button>
        <button class="btn-secondary" onclick="duplicateScreen()" style="background: #3498db; color: #fff; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;">Duplicate</button>
      </div>
    </div>
  </div>

  <div class="main-container">
    <div class="two-column-layout">
      
      <!-- LEFT COLUMN -->
      <div>
        
        <!-- Panel Type -->
        <div class="section-box">
          <div class="section-title">Panel Type</div>
          <label style="margin-bottom: 0;">
            <select id="panelType" style="width: 100%; font-size: 14px;">
              <option value="BP2_V2">ROE Black Pearl BP2 V2</option>
              <option value="CB5_MKII">ROE Carbon CB5 MKII</option>
              <option value="CB5_MKII_HALF">ROE Carbon CB5 MKII Half</option>
              <option value="MC7H">ROE MC7H</option>
              <option value="BO3">ROE Black Onyx BO3</option>
              <option value="BM4_MATTE">ROE Black Marble BM4</option>
              <option value="DM2_6">ROE DM2.6</option>
              <option value="INFILED_AMT8_3">INFiLED AMT 8.3</option>
            </select>
          </label>
        </div>

        <!-- CB5 Half Panel Row Toggle (only visible when CB5 MKII is selected) -->
        <div id="cb5HalfPanelToggle" style="display: none; margin-top: 8px;">
          <div class="toggle-group">
            <button type="button" class="toggle-btn" id="addCB5HalfRowBtn" onclick="toggleCB5HalfRow()">+ Half Panel Row</button>
          </div>
        </div>

        <!-- Connecting Plates Section (CB5 MKII / DM2.6) -->
        <div id="connectingPlatesSection" style="display: none; margin-top: 8px;">
          <div class="section-box">
            <div class="section-title">Panel Connection Method</div>
            
            <!-- CB5 MKII can choose -->
            <div id="cb5ConnectionChoice" style="display: none;">
              <div class="toggle-group">
                <button type="button" class="toggle-btn active" id="connectionAirframeBtn" onclick="setConnectionMethod('airframe')">Air Frame</button>
                <button type="button" class="toggle-btn" id="connectionPlatesBtn" onclick="setConnectionMethod('plates')">Plates</button>
              </div>
            </div>
            
            <!-- DM2.6 always uses plates -->
            <div id="dm26ConnectionInfo" style="display: none;">
              <button type="button" class="toggle-btn active" style="pointer-events: none; opacity: 1; width: auto; padding: 8px 16px;">Connecting Plates</button>
              <div class="hint" style="color: #888; margin-top: 6px;">
                DM2.6 panels use connecting plates only
              </div>
            </div>
            
            <!-- Plate Weight Inputs (hidden - now auto-calculated) -->
            <div id="plateWeightInputs" style="display: none;">
              <!-- Plate weights are now automatically calculated:
                   2-Way Plate: 0.5 kg each
                   4-Way Plate: 0.8 kg each
              -->
            </div>
          </div>
        </div>

        <!-- Dimensions Section -->
        <div class="section-box">
          <div class="section-title">Dimensions</div>

          <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
            <div class="slider-toggle">
              <button type="button" class="slider-toggle-btn active" id="dimModePanelsBtn" onclick="setDimensionMode('panels')">Panels</button>
              <button type="button" class="slider-toggle-btn" id="dimModeSizeBtn" onclick="setDimensionMode('size')">Size</button>
            </div>
            <div class="slider-toggle">
              <button type="button" class="slider-toggle-btn active" id="unitImperial" onclick="setUnitSystem('imperial')">Imperial</button>
              <button type="button" class="slider-toggle-btn" id="unitMetric" onclick="setUnitSystem('metric')">Metric</button>
            </div>
          </div>

          <!-- Aspect Ratio Lock -->
          <div style="margin-bottom: 12px;">
            <span class="toggle-label" style="display: block; margin-bottom: 4px; font-size: 10px;">Aspect Ratio Lock <span id="arHint" style="color: #10b981; font-style: italic; display: none;">(input width for auto height)</span></span>
            <div class="slider-toggle">
              <button type="button" class="slider-toggle-btn active" id="arNoneBtn" onclick="setAspectRatio('none')" style="padding: 8px 10px; font-size: 12px;">None</button>
              <button type="button" class="slider-toggle-btn" id="ar169Btn" onclick="setAspectRatio('16:9')" style="padding: 8px 10px; font-size: 12px;">16:9</button>
              <button type="button" class="slider-toggle-btn" id="ar43Btn" onclick="setAspectRatio('4:3')" style="padding: 8px 10px; font-size: 12px;">4:3</button>
              <button type="button" class="slider-toggle-btn" id="arCustomBtn" onclick="setAspectRatio('custom')" style="padding: 8px 10px; font-size: 12px;">Custom</button>
            </div>
            <!-- Custom Aspect Ratio Inputs (hidden by default) -->
            <div id="customAspectRatioInputs" style="display: none; margin-top: 8px;">
              <div class="two-inputs" style="max-width: 160px;">
                <label>
                  <span>Width</span>
                  <input type="number" id="customARWidth" min="1" placeholder="16" style="width: 60px; color: #6b7280;" onfocus="this.style.color='#fff'" onblur="if(!this.value)this.style.color='#6b7280'">
                </label>
                <label>
                  <span>Height</span>
                  <input type="number" id="customARHeight" min="1" placeholder="10" style="width: 60px; color: #6b7280;" onfocus="this.style.color='#fff'" onblur="if(!this.value)this.style.color='#6b7280'">
                </label>
              </div>
            </div>
          </div>

          <div id="panelCountInputs">
            <div class="two-inputs" style="max-width: 200px;">
              <label>
                <span>Panels Wide</span>
                <input type="number" id="panelsWide" min="1">
              </label>
              <label>
                <span>Panels High</span>
                <input type="number" id="panelsHigh" min="1">
              </label>
            </div>
          </div>

          <div id="wallSizeInputs" style="display: none;">
            <div class="two-inputs" style="max-width: 200px;">
              <label>
                <span>Wall Width</span>
                <input type="number" id="wallWidth" min="0.1" step="0.01">
              </label>
              <label>
                <span>Wall Height</span>
                <input type="number" id="wallHeight" min="0.1" step="0.01">
              </label>
            </div>
          </div>
        </div>

        <!-- Power Section -->
        <div class="section-box" id="powerSection">
          <div class="section-title">Power</div>

          <!-- Row 1: Power Basis and Phase toggles -->
          <div class="compact-row" style="margin-bottom: 12px;">
            <div style="flex: 0 0 auto;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px;">Power Basis</span>
              <div class="slider-toggle">
                <button type="button" class="slider-toggle-btn active" id="powerMaxBtn" onclick="setPowerType('max')">Max</button>
                <button type="button" class="slider-toggle-btn" id="powerAvgBtn" onclick="setPowerType('avg')">Avg</button>
              </div>
              <select id="powerType" style="display: none;">
                <option value="max" selected>Max</option>
                <option value="avg">Average</option>
              </select>
            </div>
            <div style="flex: 0 0 auto;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px;">Phase</span>
              <div class="slider-toggle">
                <button type="button" class="slider-toggle-btn active" id="phase3Btn" onclick="setPhase(3)">3Ø</button>
                <button type="button" class="slider-toggle-btn" id="phase1Btn" onclick="setPhase(1)">1Ø</button>
              </div>
              <select id="phase" style="display: none;">
                <option value="1">1-phase</option>
                <option value="3" selected>3-phase</option>
              </select>
            </div>
          </div>

          <!-- Row 2: Voltage, Breaker, Max/Circuit -->
          <div class="compact-row">
            <div style="flex: 0 0 auto;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px;">Voltage</span>
              <div class="number-input-with-arrows">
                <input type="number" id="voltage" value="208">
                <div class="number-input-arrows">
                  <button type="button" onclick="adjustNumberInput('voltage', 1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                  </button>
                  <button type="button" onclick="adjustNumberInput('voltage', -1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                  </button>
                </div>
              </div>
            </div>
            <div style="flex: 0 0 auto;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px;">Breaker</span>
              <div class="number-input-with-arrows">
                <input type="number" id="breaker" value="20">
                <div class="number-input-arrows">
                  <button type="button" onclick="adjustNumberInput('breaker', 1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                  </button>
                  <button type="button" onclick="adjustNumberInput('breaker', -1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                  </button>
                </div>
              </div>
            </div>
            <div style="flex: 0 0 auto;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px;">Max/Circuit</span>
              <div class="number-input-with-arrows">
                <input type="number" id="maxPanelsPerCircuit" min="1" step="1" placeholder="21">
                <div class="number-input-arrows">
                  <button type="button" onclick="adjustNumberInput('maxPanelsPerCircuit', 1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                  </button>
                  <button type="button" onclick="adjustNumberInput('maxPanelsPerCircuit', -1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Data Section -->
        <div class="section-box" id="dataSection">
          <div class="section-title">Data</div>

          <!-- Row 1: Processor -->
          <div style="margin-bottom: 8px;">
            <label style="margin-bottom: 0;">
              <span>Processor</span>
              <select id="processor" style="width: 100%;">
                <option value="Brompton_SX40">Brompton SX40</option>
                <option value="Brompton_S8">Brompton S8</option>
                <option value="Brompton_M2">Brompton M2</option>
                <option value="Brompton_S4">Brompton S4</option>
                <option value="Brompton_T1">Brompton T1</option>
                <option value="Brompton_SQ200">Brompton SQ200</option>
                <option value="NovaStar_MX40_Pro">NovaStar MX40 Pro</option>
              </select>
            </label>
          </div>

          <!-- Direct/Indirect Mode Toggle (MX40 Pro only) -->
          <div id="mx40ModeToggleRow" style="display: none; margin-bottom: 8px;">
            <span class="toggle-label" style="display: block; margin-bottom: 4px; font-size: 10px;">Connection Mode</span>
            <div class="slider-toggle" style="display: inline-flex;">
              <button type="button" class="slider-toggle-btn active" id="mx40DirectBtn" onclick="setMX40Mode('direct')" style="padding: 6px 10px; font-size: 11px; min-height: 32px;">Direct</button>
              <button type="button" class="slider-toggle-btn" id="mx40IndirectBtn" onclick="setMX40Mode('indirect')" style="padding: 6px 10px; font-size: 11px; min-height: 32px;">Indirect</button>
            </div>
          </div>

          <!-- Row 2: Frame Rate, Bit Depth, Max/Data -->
          <div class="compact-row" style="margin-bottom: 8px; flex-wrap: nowrap; gap: 8px;">
            <div style="flex: 1; min-width: 0;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px; font-size: 10px;">Frame Rate</span>
              <select id="frameRate" style="width: 100%; font-size: 14px;">
                <option value="24">24 Hz</option>
                <option value="25">25 Hz</option>
                <option value="30">30 Hz</option>
                <option value="50">50 Hz</option>
                <option value="60" selected>60 Hz</option>
              </select>
            </div>
            <div style="flex: 1; min-width: 0;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px; font-size: 10px;">Bit Depth</span>
              <select id="bitDepth" style="width: 100%; font-size: 14px;">
                <option value="8" selected>8 bit</option>
                <option value="10">10 bit</option>
                <option value="12">12 bit</option>
              </select>
            </div>
            <div style="flex: 1; min-width: 0;">
              <span class="toggle-label" style="display: block; margin-bottom: 4px;">Max/Data</span>
              <div class="number-input-with-arrows" style="width: 100%; min-height: 48px;">
                <input type="number" id="maxPanelsPerData" min="1" step="1" placeholder="Auto" style="padding: 12px 8px;">
                <div class="number-input-arrows">
                  <button type="button" onclick="adjustNumberInput('maxPanelsPerData', 1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                  </button>
                  <button type="button" onclick="adjustNumberInput('maxPanelsPerData', -1)">
                    <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Row 3: Data Direction (complex mode only) -->
          <div id="dataDirectionRow" style="margin-bottom: 8px;">
            <label style="margin-bottom: 0;">
              <span>Data Direction</span>
              <select id="dataStartDir" style="width: 100%;">
                <option value="top">Top → Bottom</option>
                <option value="bottom">Bottom → Top</option>
                <option value="all_top">All from Top</option>
                <option value="all_bottom">All from Bottom</option>
              </select>
            </label>
          </div>

          <!-- Row 4: Toggle buttons (complex mode only) -->
          <div id="dataTogglesRow" class="toggle-group" style="gap: 6px;">
            <button type="button" class="toggle-btn active" id="showArrowsBtn" onclick="toggleShowArrows()" style="padding: 8px 10px; font-size: 11px; min-width: auto; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Arrows</button>
            <button type="button" class="toggle-btn active" id="redundancyBtn" onclick="toggleRedundancy()" style="padding: 8px 10px; font-size: 11px; min-width: auto; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Data Redun.</button>
            <button type="button" class="toggle-btn" id="processorRedundancyBtn" onclick="toggleProcessorRedundancy()" style="padding: 8px 10px; font-size: 11px; min-width: auto; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Proc Redun.</button>
          </div>
        </div>

      </div>

      <!-- RIGHT COLUMN -->
      <div>
        
        <!-- Structure Section -->
        <div class="section-box" id="structureSection">
          <div class="section-title">Structure</div>

          <div style="margin-bottom: 8px;">
            <label style="display: block; margin-bottom: 8px;">
              <span>Config Type</span>
              <select id="structureType" style="width: 100%; max-width: 180px;">
                <option value="hanging">Hanging</option>
                <option value="ground">Ground Stack</option>
                <option value="floor">Floor</option>
              </select>
            </label>
            <!-- Bumper Toggles Row -->
            <div class="toggle-group" style="gap: 6px;">
              <button type="button" class="toggle-btn active" id="useBumpersBtn" onclick="toggleUseBumpers()" style="padding: 6px 8px; font-size: 12px; min-width: auto; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Bumpers</button>
              <span id="fourWayBumperOption" style="display: none;">
                <button type="button" class="toggle-btn" id="use4WayBumpersBtn" onclick="toggle4WayBumpers()" style="padding: 6px 8px; font-size: 12px; min-width: auto; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">4-Way Bumpers</button>
              </span>
            </div>
          </div>
          
          <!-- Bumper Controls -->
          <div id="bumperControls">
            <div class="hint" style="font-size: 11px; margin-bottom: 0;">
              Long-press bumpers to edit • Auto-distributes by width
            </div>
          </div>
          
          <!-- Weight Display -->
          <div id="weightDisplay" class="weight-display" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 8px; color: #4a9eff;">Weight Distribution</div>
            <div id="weightContent"></div>
          </div>
        </div>
        
        <!-- Cabling section moved to Gear tab -->

      </div>

    </div>

    <div id="results" class="result">Configure your LED wall above - results update automatically.</div>
    <div id="specWarning" class="warn"></div>

    <div class="layout-container" id="standardContainer" style="display:none;">
      <div class="layout-title">
        <span>Standard Layout<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('standardContainer')" id="standardCollapseBtn" title="Minimize">▼</button></span>
        <div class="undo-redo-buttons">
          <button class="undo-redo-btn" id="undoBtn" onclick="undo()" title="Undo">Undo</button>
          <button class="undo-redo-btn" id="redoBtn" onclick="redo()" title="Redo">Redo</button>
        </div>
      </div>
      <div class="layout-content" id="standardContent">
        <div class="mobile-hint" id="standardLayoutHint">Tap to select • Tap again for options • Drag to multi-select</div>
        <canvas id="standardCanvas"></canvas>
      </div>
    </div>

    <div class="layout-container" id="powerContainer" style="display:none;">
      <div class="layout-title">
        <span>Power Layout<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('powerContainer')" id="powerCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="powerContent">
        <canvas id="powerCanvas"></canvas>
      </div>
    </div>

    <div class="layout-container" id="dataContainer" style="display:none;">
      <div class="layout-title">
        <span>Data Layout<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('dataContainer')" id="dataCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="dataContent">
        <canvas id="dataCanvas"></canvas>
      </div>
    </div>

    <div class="layout-container" id="structureContainer" style="display:none;">
      <div class="layout-title">
        <span>Structure Layout<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('structureContainer')" id="structureCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="structureContent">
      <!-- Manual Mode Toggle -->
      <div class="structure-mode-toggle">
        <button type="button" class="toggle-btn" id="manualBumperToggle" onclick="toggleManualBumperMode()" style="border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">
          Manually Distribute Bumpers
        </button>
        <div class="undo-redo-buttons" id="structureUndoRedo" style="display: none;">
          <button class="undo-redo-btn" id="structureUndoBtn" onclick="structureUndo()" title="Undo (Ctrl+Z)" style="border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Undo</button>
          <button class="undo-redo-btn" id="structureRedoBtn" onclick="structureRedo()" title="Redo (Ctrl+Y)" style="border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Redo</button>
        </div>
        <span class="structure-mode-hint" id="structureModeHint">Auto-distribution active</span>
      </div>
      
      <!-- Selection Info (shown in manual mode) -->
      <div class="structure-selection-info" id="structureSelectionInfo">
        <strong>Manual Mode:</strong> <span id="structureHintText">Tap to select • Tap again for options • Hold to drag</span>
      </div>
      
      <!-- Structure layout with canvas and info panel side by side -->
      <div class="structure-layout-wrapper">
        <div class="structure-canvas-area">
          <canvas id="structureCanvas"></canvas>
        </div>
        
        <!-- Info Panel with Weights and Plates -->
        <div class="structure-info-panel" id="structureInfoPanel" style="display: none;">
          <!-- Pickup Weights -->
          <div class="structure-info-box weights" id="structureWeightsBox">
            <div class="structure-info-title weights">Pickup Weights</div>
            <div id="structureWeightsContent"></div>
          </div>
          
          <!-- Connecting Plates -->
          <div class="structure-info-box plates" id="structurePlatesBox" style="display: none;">
            <div class="structure-info-title plates">Connecting Plates</div>
            <div id="structurePlatesContent"></div>
          </div>
          
          <!-- Ground Support Hardware -->
          <div class="structure-info-box ground-support" id="structureGroundSupportBox" style="display: none;">
            <div class="structure-info-title ground-support">Ground Support Hardware</div>
            <div id="structureGroundSupportContent"></div>
          </div>

          <!-- Floor Frames -->
          <div class="structure-info-box floor-frames" id="structureFloorFramesBox" style="display: none; border-left: 3px solid #4ecdc4;">
            <div class="structure-info-title floor-frames" style="color: #4ecdc4;">Floor Frames</div>
            <div id="structureFloorFramesContent"></div>
          </div>

          <!-- Total Structure Weight -->
          <div class="structure-info-box" id="structureTotalWeightBox" style="display: none; border-left: 3px solid #FFD700;">
            <div class="structure-info-title" style="color: #FFD700;">Total Structure Weight</div>
            <div id="structureTotalWeightContent"></div>
          </div>
        </div>
      </div>
      
      <!-- Context Menu for Bumpers -->
      <div id="bumperContextMenu" style="display:none; position:fixed; background:#2a2a2a; border:1px solid #555; border-radius:4px; padding:4px 0; box-shadow:0 2px 8px rgba(0,0,0,0.5); z-index:10000;">
        <div class="context-menu-item" onclick="changeBumperType('1w')">Change to 1W</div>
        <div class="context-menu-item" onclick="changeBumperType('2w')">Change to 2W</div>
        <div class="context-menu-item" onclick="deleteBumper()" style="color:#ff6b6b;">Delete Bumper</div>
      </div>
      </div>
    </div>
    
    <!-- Layouts Toggle Bar (for mobile layouts view) -->
    <div id="layoutsTogglesContainer" class="layouts-toggle-container" style="display: none;">
      <div class="toggle-group">
        <button type="button" class="toggle-btn active" id="layoutToggleStandard" onclick="showMobileLayout('standard')">Standard</button>
        <button type="button" class="toggle-btn" id="layoutTogglePower" onclick="showMobileLayout('power')">Power</button>
        <button type="button" class="toggle-btn" id="layoutToggleData" onclick="showMobileLayout('data')">Data</button>
        <button type="button" class="toggle-btn" id="layoutToggleStructure" onclick="showMobileLayout('structure')">Structure</button>
      </div>
    </div>

  </div>

<!-- Gear List Container (outside main-container so it can be shown as its own tab) -->
<div class="layout-container" id="gearListContainer" style="display:none; padding-top: 24px; margin-top: 32px;">
  <div class="layout-title"><span>Gear List</span></div>

  <!-- Screen Toggle Buttons -->
  <div id="gearScreenToggles" style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 16px;">
    <!-- Dynamically generated -->
  </div>

  <!-- Cabling Section -->
  <div class="section-box" id="cablingSection" style="margin-bottom: 16px;">
    <div class="section-title">Cabling</div>

    <div class="compact-row" style="margin-bottom: 8px;">
      <label style="flex: 0 0 90px;">
        <span>Wall to Floor</span>
        <input type="number" id="wallToFloor" min="0" step="0.1" placeholder="5">
      </label>
      <label style="flex: 0 0 90px;">
        <span>Distro to Wall</span>
        <input type="number" id="distroToWall" min="0" step="0.1" placeholder="10">
      </label>
    </div>

    <div class="compact-row" style="margin-bottom: 8px;">
      <label style="flex: 0 0 90px;">
        <span>Proc to Wall</span>
        <input type="number" id="processorToWall" min="0" step="0.1" placeholder="15">
      </label>
      <label style="flex: 0 0 90px;">
        <span>Server to Proc</span>
        <input type="number" id="serverToProcessor" min="0" step="0.1" placeholder="50">
      </label>
    </div>

    <div class="compact-row" style="margin-bottom: 8px;">
      <label style="flex: 0 0 90px;">
        <span>Cable Pick</span>
        <input type="number" id="cablePick" min="0" step="0.1" placeholder="0">
      </label>
    </div>

    <div style="margin-bottom: 8px;">
      <span class="toggle-label" style="display: block; margin-bottom: 4px;">Cable Drop</span>
      <div class="slider-toggle">
        <button type="button" class="slider-toggle-btn active" id="cableDropBehindBtn" onclick="setCableDropPosition('behind')">Behind</button>
        <button type="button" class="slider-toggle-btn" id="cableDropSRBtn" onclick="setCableDropPosition('sr')">SR</button>
        <button type="button" class="slider-toggle-btn" id="cableDropSLBtn" onclick="setCableDropPosition('sl')">SL</button>
      </div>
    </div>

    <div class="compact-row" style="margin-bottom: 0;">
      <button type="button" class="toggle-btn" id="distBoxOnWallBtn" onclick="toggleDistBoxOnWall()" style="padding: 8px 10px; font-size: 11px; min-width: auto; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Dist Box on Wall (C)</button>
    </div>
  </div>

  <div id="gearListContent" style="color: #e0e0e0; line-height: 1.8;"></div>
</div>

<!-- Combined View Container (outside main-container so it can be shown independently) -->
<div class="layout-container" id="combinedContainer" style="display:none; padding-top: 24px; margin-top: 32px; overflow: visible;">
  <!-- Combined View Title -->
  <div class="layout-title"><span>Combined View</span></div>
  <!-- Hint Box -->
  <div style="background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; padding: 4px 10px; font-size: 11px; color: #10b981; margin-bottom: 16px; display: inline-block;">
    Toggle screens below to view combined specs
  </div>

  <!-- Screen Toggle Buttons -->
  <div id="combinedScreenToggles" style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 16px;">
    <!-- Screen toggle buttons will be dynamically generated here -->
  </div>

  <!-- Combined Layouts Container -->
  <div id="combinedLayoutsWrapper" style="overflow-x: auto; margin-bottom: 20px;">
    <!-- Standard Layout -->
    <div class="layout-container" id="combinedStandardContainer" style="margin-bottom: 20px;">
      <div class="layout-title">
        <span>Standard Layout (Combined)<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('combinedStandardContainer')" id="combinedStandardCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="combinedStandardContent">
        <!-- Interaction Hints -->
        <div id="combinedInteractionHints" style="background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; padding: 6px 10px; margin-bottom: 10px; font-size: 10px; color: #10b981; line-height: 1.5;">
          <span id="combinedHintsDesktop" style="display: none;"><strong>Panels:</strong> Right-click for options, double-click to delete/restore &nbsp;|&nbsp; <strong>Screens:</strong> Enable Manual Adjust, then drag to move</span>
          <span id="combinedHintsMobile" style="display: none;"><strong>Panels:</strong> Tap to select, tap again for options &nbsp;|&nbsp; <strong>Screens:</strong> Enable Manual Adjust, then drag to move</span>
        </div>
        <!-- Position Controls -->
        <div id="combinedPositionControls" style="display: flex; flex-wrap: nowrap; gap: 6px; margin-bottom: 10px; align-items: center;">
          <div class="slider-toggle" style="display: inline-flex;">
            <button type="button" class="slider-toggle-btn" id="resetPositionsBtn" onclick="resetCombinedPositions()" style="padding: 6px 10px; font-size: 11px; min-height: 32px;">Reset</button>
            <button type="button" class="slider-toggle-btn" id="manualAdjustBtn" onclick="toggleManualAdjust()" style="padding: 6px 10px; font-size: 11px; min-height: 32px;">Manual Adjust</button>
          </div>
          <!-- Zoom Controls (matching Canvas View style) -->
          <div id="combinedZoomControls" style="display: inline-flex; align-items: stretch; gap: 4px;">
            <button class="toggle-btn" onclick="adjustCombinedZoom(-10)" title="Zoom Out" style="padding: 6px 10px; height: 32px; font-size: 14px; box-sizing: border-box;">−</button>
            <input type="number" id="combinedZoomInput" value="100" min="50" max="200" step="10" onchange="setCombinedZoom(parseInt(this.value))" title="Enter zoom percentage" style="width: 55px; padding: 4px; height: 32px; text-align: center; box-sizing: border-box; border: 2px solid #000; font-size: 11px;">
            <button class="toggle-btn" onclick="adjustCombinedZoom(10)" title="Zoom In" style="padding: 6px 10px; height: 32px; font-size: 14px; box-sizing: border-box;">+</button>
          </div>
        </div>
        <div id="combinedStandardCanvasWrapper" style="overflow-x: auto;">
          <canvas id="combinedStandardCanvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Power Layout -->
    <div class="layout-container" id="combinedPowerContainer" style="margin-bottom: 20px;">
      <div class="layout-title">
        <span>Power Layout (Combined)<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('combinedPowerContainer')" id="combinedPowerCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="combinedPowerContent">
        <div id="combinedPowerCanvasWrapper" style="overflow-x: auto;">
          <canvas id="combinedPowerCanvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Data Layout -->
    <div class="layout-container" id="combinedDataContainer" style="margin-bottom: 20px;">
      <div class="layout-title">
        <span>Data Layout (Combined)<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('combinedDataContainer')" id="combinedDataCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="combinedDataContent">
        <div id="combinedDataCanvasWrapper" style="overflow-x: auto;">
          <canvas id="combinedDataCanvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Structure Layout -->
    <div class="layout-container" id="combinedStructureContainer" style="margin-bottom: 20px;">
      <div class="layout-title">
        <span>Structure Layout (Combined)<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('combinedStructureContainer')" id="combinedStructureCollapseBtn" title="Minimize">▼</button></span>
      </div>
      <div class="layout-content" id="combinedStructureContent">
        <div id="combinedStructureCanvasWrapper" style="overflow-x: auto;">
          <canvas id="combinedStructureCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Combined Specs -->
  <div class="layout-container" id="combinedSpecsContainer" style="margin-bottom: 20px;">
    <div class="layout-title">
      <span>Combined Specifications<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('combinedSpecsContainer')" id="combinedSpecsCollapseBtn" title="Minimize">▼</button></span>
    </div>
    <div class="layout-content">
      <div style="display: flex; gap: 16px; margin-bottom: 12px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto;">
          <span class="toggle-label" style="display: block; margin-bottom: 4px;">Power Basis</span>
          <div class="slider-toggle">
            <button type="button" class="slider-toggle-btn active" id="combinedPowerMaxBtn" onclick="setCombinedPowerType('max')">Max</button>
            <button type="button" class="slider-toggle-btn" id="combinedPowerAvgBtn" onclick="setCombinedPowerType('avg')">Avg</button>
          </div>
        </div>
        <div style="flex: 0 0 auto;">
          <span class="toggle-label" style="display: block; margin-bottom: 4px;">Phase</span>
          <div class="slider-toggle">
            <button type="button" class="slider-toggle-btn active" id="combinedPhase3Btn" onclick="setCombinedPhase(3)">3Ø</button>
            <button type="button" class="slider-toggle-btn" id="combinedPhase1Btn" onclick="setCombinedPhase(1)">1Ø</button>
          </div>
        </div>
      </div>
      <div id="combinedSpecsContent" style="color: #e0e0e0; line-height: 1.8;"></div>
    </div>
  </div>

  <!-- Combined Gear List -->
  <div class="layout-container" id="combinedGearListContainer" style="margin-bottom: 20px;">
    <div class="layout-title">
      <span>Gear List<button class="layout-collapse-btn" onclick="toggleLayoutCollapse('combinedGearListContainer')" id="combinedGearListCollapseBtn" title="Minimize">▼</button></span>
    </div>
    <div class="layout-content">
      <div id="combinedGearListContent" style="color: #e0e0e0; line-height: 1.8;"></div>
    </div>
  </div>

</div>

<!-- Canvas Tabs Container (outside canvas container, normal flow like screen tabs) -->
<div id="canvasTabsContainer" style="display: none; align-items: flex-end; gap: 4px;">
  <!-- Canvas tabs and + button will be dynamically generated here -->
</div>

<!-- Canvas Container (outside main-container so it can be shown independently) -->
<div class="layout-container" id="canvasContainer" style="display:none; padding: 12px; padding-top: 48px; margin-top: 0; border-top: 0; overflow: visible;">
  <!-- Canvas View Title with Tabs -->
  <div class="layout-title">
    <span style="top: 0px;">Canvas View</span>
  </div>

  <!-- Zoom and Undo/Redo Controls -->
  <div style="display: flex; gap: 6px; margin-bottom: 12px; align-items: stretch;">
    <button class="toggle-btn" onclick="zoomCanvas(-0.25)" title="Zoom Out" style="flex: 1; padding: 8px 4px; height: 44px; font-size: 16px; box-sizing: border-box;">−</button>
    <input type="number" id="canvasZoomInput" value="100" min="50" max="500" step="10" onchange="setCanvasZoom(this.value)" title="Enter zoom percentage" style="flex: 1; padding: 8px 4px; height: 44px; text-align: center; box-sizing: border-box; border: 2px solid #000;">
    <button class="toggle-btn" onclick="zoomCanvas(0.25)" title="Zoom In" style="flex: 1; padding: 8px 4px; height: 44px; font-size: 16px; box-sizing: border-box;">+</button>
    <button class="toggle-btn" onclick="resetCanvasZoom()" title="Reset Zoom" style="flex: 1; padding: 8px 4px; height: 44px; box-sizing: border-box;">Reset</button>
    <button class="toggle-btn" id="canvasUndoBtn" onclick="undoCanvasMove()" title="Undo Canvas Move" style="flex: 1; padding: 8px 4px; height: 44px; box-sizing: border-box;">Undo</button>
    <button class="toggle-btn" id="canvasRedoBtn" onclick="redoCanvasMove()" title="Redo Canvas Move" style="flex: 1; padding: 8px 4px; height: 44px; box-sizing: border-box;">Redo</button>
  </div>

  <div style="display: flex; flex-direction: column; gap: 16px;">
    <!-- Canvas View -->
    <div>
      <div id="canvasViewWrapper" style="width: 100%; padding-bottom: 56.25%; /* 16:9 */ height: 0; overflow: hidden; border: 2px solid #444; background: #000; position: relative;">
        <div id="canvasViewport" style="position: absolute; top:0; left:0; width:100%; height:100%; transform-origin: 0 0; cursor: grab;">
          <canvas id="canvasView" style="display: block; width:100%; height:100%;"></canvas>
        </div>
      </div>
      <div style="color:#888; margin-top:8px; font-size:11px;">Pinch to zoom • Drag to pan when zoomed • Drag screens to reposition</div>
      <div style="color:#ccc; margin-top:4px; font-size:13px;" id="canvasInfo"></div>
    </div>

    <!-- Canvas Options -->
    <div class="section-box" style="margin-bottom: 0;">
      <div class="section-title">Canvas Options</div>
      <div class="section-content">
        <!-- Row 1: Canvas Size -->
        <label style="margin-bottom: 8px;">
          <span>Canvas Size</span>
          <select id="canvasSize">
            <option value="4K_UHD" selected="">4K UHD (3840x2160)</option>
            <option value="4K_DCI">4K DCI (4096x2160)</option>
            <option value="HD">HD (1920x1080)</option>
            <option value="custom">Custom</option>
          </select>
        </label>

        <div id="customCanvasInputs" style="display: none; margin-bottom: 8px;">
          <div class="two-inputs">
            <label style="margin-bottom: 0;">
              <span>Width (px)</span>
              <input type="number" id="customCanvasWidth" min="1">
            </label>
            <label style="margin-bottom: 0;">
              <span>Height (px)</span>
              <input type="number" id="customCanvasHeight" min="1">
            </label>
          </div>
        </div>

        <!-- Row 2: X Pos, Y Pos, Snap, Fine -->
        <div style="display: flex; gap: 8px; align-items: stretch; margin-bottom: 8px;">
          <div style="flex: 1;">
            <span class="toggle-label" style="display: block; margin-bottom: 4px;">X Pos</span>
            <div class="number-input-with-arrows">
              <input type="number" id="canvasX" value="0" min="0">
              <div class="number-input-arrows">
                <button type="button" onclick="adjustCanvasPosition('canvasX', 1)">
                  <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                </button>
                <button type="button" onclick="adjustCanvasPosition('canvasX', -1)">
                  <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                </button>
              </div>
            </div>
          </div>
          <div style="flex: 1;">
            <span class="toggle-label" style="display: block; margin-bottom: 4px;">Y Pos</span>
            <div class="number-input-with-arrows">
              <input type="number" id="canvasY" value="0" min="0">
              <div class="number-input-arrows">
                <button type="button" onclick="adjustCanvasPosition('canvasY', 1)">
                  <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                </button>
                <button type="button" onclick="adjustCanvasPosition('canvasY', -1)">
                  <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                </button>
              </div>
            </div>
          </div>
          <div style="display: flex; flex-direction: column; flex: 1;">
            <span class="toggle-label" style="display: block; margin-bottom: 4px; visibility: hidden;">Snap</span>
            <button type="button" class="toggle-btn active" id="snapModeBtn" onclick="toggleSnapMode()" style="width: 100%; padding: 10px 8px; min-height: 48px; box-sizing: border-box; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);">Snap</button>
          </div>
          <div style="flex: 1;">
            <span class="toggle-label" style="display: block; margin-bottom: 4px;">Fine(px)</span>
            <div class="number-input-with-arrows">
              <input type="number" id="arrowKeyIncrement" value="10" min="1" max="100">
              <div class="number-input-arrows">
                <button type="button" onclick="adjustNumberInput('arrowKeyIncrement', 1)">
                  <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_up</span>
                </button>
                <button type="button" onclick="adjustNumberInput('arrowKeyIncrement', -1)">
                  <span class="material-symbols-outlined" style="font-size: 14px;">keyboard_arrow_down</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Row 3: Filename -->
        <div style="margin-bottom: 8px;">
          <input type="text" id="canvasExportFilename" placeholder="Filename..." style="width: 100%; padding: 10px; font-size: 13px; background: #333; color: #fff; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1); min-height: 48px; box-sizing: border-box;">
        </div>

        <!-- Row 4: PNG dropdown, Export button -->
        <div style="display: flex; gap: 8px; align-items: stretch; margin-bottom: 12px;">
          <select id="canvasExportFormat" style="flex: 1; padding: 10px 8px; height: 48px; box-sizing: border-box;">
            <option value="png" selected="">PNG</option>
            <option value="jpeg">JPEG</option>
            <option value="resolume">Resolume (.xml)</option>
          </select>
          <button id="btnExportCanvas" class="config-btn" style="background: var(--primary); border: 2px solid #000; flex: 1; height: 48px; padding: 0; box-sizing: border-box;">Export</button>
        </div>

        <!-- Screen Visibility Toggles -->
        <div id="canvasScreenToggles"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
// ==================== APP VERSION & UPDATE CHECK ====================
const APP_VERSION = '2.4.7';
console.log('JavaScript loaded - v' + APP_VERSION);

// Set version number in menu when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  const menuVersion = document.getElementById('menuVersionNumber');
  if(menuVersion) menuVersion.textContent = 'v' + APP_VERSION;

  // Update layout hints based on device type
  updateLayoutHints();
  window.addEventListener('resize', updateLayoutHints);
});

// Update hint text based on mobile vs desktop
function updateLayoutHints() {
  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  const isMobile = window.innerWidth <= 768;

  // Standard layout hint
  const standardHint = document.getElementById('standardLayoutHint');
  if(standardHint) {
    if(isTouchDevice || isMobile) {
      standardHint.textContent = 'Tap to select • Tap again for options • Drag to multi-select';
    } else {
      standardHint.textContent = 'Click to select • Right-click for options • Drag to multi-select';
    }
  }

  // Structure layout hint
  const structureHint = document.getElementById('structureHintText');
  if(structureHint) {
    if(isTouchDevice || isMobile) {
      structureHint.textContent = 'Tap to select • Tap again for options • Hold to drag';
    } else {
      structureHint.textContent = 'Click to select • Right-click for options • Drag to move';
    }
  }
}

// Check for updates on app load
async function checkForUpdates() {
  try {
    // Fetch version.json with cache-busting
    const response = await fetch('version.json?_=' + Date.now(), {
      cache: 'no-store',
      headers: { 'Cache-Control': 'no-cache' }
    });

    if (!response.ok) {
      console.log('Version check: Could not fetch version.json');
      return;
    }

    const data = await response.json();
    const latestVersion = data.version;

    console.log('Version check: Current=' + APP_VERSION + ', Latest=' + latestVersion);

    if (latestVersion && latestVersion !== APP_VERSION) {
      showUpdateBanner(latestVersion);
    } else if (latestVersion === APP_VERSION) {
      // App is up to date - clear any dismissed version tracking
      localStorage.removeItem('dismissedUpdateVersion');
    }
  } catch (e) {
    console.log('Version check failed:', e.message);
  }
}

// Show update available banner
function showUpdateBanner(newVersion) {
  // Check if user already dismissed this specific version
  const dismissedVersion = localStorage.getItem('dismissedUpdateVersion');
  if (dismissedVersion === newVersion) {
    console.log('Version check: Update banner already dismissed for v' + newVersion);
    return;
  }

  const banner = document.getElementById('updateBanner');
  const versionText = document.getElementById('updateVersionText');
  if (banner && versionText) {
    versionText.textContent = 'v' + newVersion + ' available';
    banner.classList.add('visible');
    // Store the version being shown so we can track dismissal
    banner.dataset.version = newVersion;

    // Also highlight the refresh button in the menu
    const refreshBtn = document.querySelector('.mobile-menu-refresh');
    if (refreshBtn) {
      refreshBtn.classList.add('update-available');
    }
  }
}

// Hide update banner
function hideUpdateBanner() {
  const banner = document.getElementById('updateBanner');
  if (banner) {
    // Remember that user dismissed this version
    if (banner.dataset.version) {
      localStorage.setItem('dismissedUpdateVersion', banner.dataset.version);
      console.log('Update banner dismissed for v' + banner.dataset.version);
    }
    banner.classList.remove('visible');
  }
}

// Global unit settings
let displayLengthUnit = 'ft'; // 'ft' or 'm'
let displayWeightUnit = 'lbs'; // 'lbs' or 'kg'

// Unit conversion constants
const FT_TO_M = 0.3048;
const M_TO_FT = 3.28084;
const LBS_TO_KG = 0.453592;
const KG_TO_LBS = 2.20462;

// Unit system toggle function (Imperial = ft/lbs, Metric = m/kg)
function setUnitSystem(system) {
  if(system === 'imperial') {
    displayLengthUnit = 'ft';
    displayWeightUnit = 'lbs';
  } else {
    displayLengthUnit = 'm';
    displayWeightUnit = 'kg';
  }
  
  // Update button states
  document.getElementById('unitImperial').classList.toggle('active', system === 'imperial');
  document.getElementById('unitMetric').classList.toggle('active', system === 'metric');
  
  // Recalculate to update all displays
  calculate();
  
  // Update structure view weights
  if(bumpers.length > 0) {
    updatePickupWeightSummary();
  }
}

// Unit toggle functions (kept for compatibility)
function setLengthUnit(unit) {
  displayLengthUnit = unit;
  
  // Update button states if elements exist
  const unitImperial = document.getElementById('unitImperial');
  const unitMetric = document.getElementById('unitMetric');
  if(unitImperial && unitMetric) {
    unitImperial.classList.toggle('active', unit === 'ft');
    unitMetric.classList.toggle('active', unit === 'm');
  }
  
  // Recalculate to update all displays
  calculate();
}

function setWeightUnit(unit) {
  displayWeightUnit = unit;
  
  // Update button states if elements exist
  const unitImperial = document.getElementById('unitImperial');
  const unitMetric = document.getElementById('unitMetric');
  if(unitImperial && unitMetric) {
    unitImperial.classList.toggle('active', unit === 'lbs');
    unitMetric.classList.toggle('active', unit === 'kg');
  }
  
  // Recalculate to update all displays
  calculate();
  
  // Update structure view weights
  if(bumpers.length > 0) {
    updatePickupWeightSummary();
  }
}

// Helper functions for formatting values with current units
function formatLength(meters, decimals = 2) {
  if(displayLengthUnit === 'ft') {
    return (meters * M_TO_FT).toFixed(decimals) + ' ft';
  } else {
    return meters.toFixed(decimals) + ' m';
  }
}

function formatWeight(kg, decimals = 2) {
  if(displayWeightUnit === 'lbs') {
    return (kg * KG_TO_LBS).toFixed(decimals) + ' lbs';
  } else {
    return kg.toFixed(decimals) + ' kg';
  }
}

function formatWeightValue(kg, decimals = 0) {
  // Returns just the number without unit label
  if(displayWeightUnit === 'lbs') {
    return (kg * KG_TO_LBS).toFixed(decimals);
  } else {
    return kg.toFixed(decimals);
  }
}

function getWeightUnitLabel() {
  return displayWeightUnit;
}

function getLengthUnitLabel() {
  return displayLengthUnit;
}

// Dimension mode toggle
let currentDimensionMode = 'panels';
function setDimensionMode(mode) {
  currentDimensionMode = mode;
  document.getElementById('dimModePanelsBtn').classList.toggle('active', mode === 'panels');
  document.getElementById('dimModeSizeBtn').classList.toggle('active', mode === 'size');

  document.getElementById('panelCountInputs').style.display = mode === 'panels' ? 'block' : 'none';
  document.getElementById('wallSizeInputs').style.display = mode === 'size' ? 'block' : 'none';

  if(mode === 'panels') {
    syncFromPanels();
  } else {
    syncFromSize();
  }
  calculate();
}

// Aspect Ratio Lock
let currentAspectRatio = 'none';
let customARWidth = 16;
let customARHeight = 10;

function setAspectRatio(ratio) {
  const previousRatio = currentAspectRatio;
  currentAspectRatio = ratio;

  // Update toggle button states
  document.getElementById('arNoneBtn').classList.toggle('active', ratio === 'none');
  document.getElementById('ar169Btn').classList.toggle('active', ratio === '16:9');
  document.getElementById('ar43Btn').classList.toggle('active', ratio === '4:3');
  document.getElementById('arCustomBtn').classList.toggle('active', ratio === 'custom');

  // Show/hide custom inputs
  document.getElementById('customAspectRatioInputs').style.display = ratio === 'custom' ? 'block' : 'none';

  // Show/hide hint
  document.getElementById('arHint').style.display = ratio === 'none' ? 'none' : 'inline';

  // Store custom values if switching to custom
  if(ratio === 'custom') {
    customARWidth = parseInt(document.getElementById('customARWidth').value) || 16;
    customARHeight = parseInt(document.getElementById('customARHeight').value) || 10;
  }

  // Clear dimension inputs when switching between different aspect ratios (not from 'none')
  if(previousRatio !== 'none' && previousRatio !== ratio) {
    document.getElementById('panelsWide').value = '';
    document.getElementById('panelsHigh').value = '';
    document.getElementById('wallWidth').value = '';
    document.getElementById('wallHeight').value = '';
  }
}

function getAspectRatioValue() {
  // Returns the aspect ratio as width/height
  switch(currentAspectRatio) {
    case '16:9': return 16 / 9;
    case '4:3': return 4 / 3;
    case 'custom':
      customARWidth = parseInt(document.getElementById('customARWidth').value) || 16;
      customARHeight = parseInt(document.getElementById('customARHeight').value) || 10;
      return customARWidth / customARHeight;
    default: return null; // 'none' - no aspect ratio lock
  }
}

// Apply aspect ratio lock when width changes - calculates height
function applyAspectRatioFromWidth() {
  const aspectRatio = getAspectRatioValue();
  if(!aspectRatio) return; // No aspect ratio lock

  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  if(!p || !p.res_x || !p.res_y) return;

  if(currentDimensionMode === 'panels') {
    // Panels mode: calculate panels high based on panels wide and pixel aspect ratio
    const pwInput = document.getElementById('panelsWide').value;

    // If width is empty, clear height too
    if(pwInput === '' || pwInput === null) {
      document.getElementById('panelsHigh').value = '';
      syncFromPanels();
      return;
    }

    const pw = parseInt(pwInput) || 0;
    if(pw <= 0) return;

    // Total pixels wide
    const totalPixelsWide = pw * p.res_x;
    // Calculate pixels high for target aspect ratio
    const targetPixelsHigh = totalPixelsWide / aspectRatio;
    // Round to nearest panel count
    const ph = Math.max(1, Math.round(targetPixelsHigh / p.res_y));

    document.getElementById('panelsHigh').value = ph;
    syncFromPanels();
    saveCurrentScreenData(); // Save to screen data before calculate
    calculate(); // Trigger calculation to populate wall on canvas
  } else {
    // Size mode: calculate wall height based on wall width
    const wallWidthInput = document.getElementById('wallWidth').value;

    // If width is empty, clear height too
    if(wallWidthInput === '' || wallWidthInput === null) {
      document.getElementById('wallHeight').value = '';
      syncFromSize();
      return;
    }

    const wallWidth = parseFloat(wallWidthInput) || 0;
    if(wallWidth <= 0) return;

    const wallHeight = wallWidth / aspectRatio;
    document.getElementById('wallHeight').value = wallHeight.toFixed(2);
    syncFromSize();
    saveCurrentScreenData(); // Save to screen data before calculate
    calculate(); // Trigger calculation to populate wall on canvas
  }
}

// Phase toggle
function setPhase(phase) {
  document.getElementById('phase').value = phase;
  document.getElementById('phase3Btn').classList.toggle('active', phase === 3);
  document.getElementById('phase1Btn').classList.toggle('active', phase === 1);
  calculate();
}

// Power type toggle (Max/Avg)
function setPowerType(type) {
  document.getElementById('powerType').value = type;
  document.getElementById('powerMaxBtn').classList.toggle('active', type === 'max');
  document.getElementById('powerAvgBtn').classList.toggle('active', type === 'avg');
  calculate();
}

// MX40 Pro connection mode toggle (Direct/Indirect)
let mx40ConnectionMode = 'direct'; // Global state for MX40 mode

function setMX40Mode(mode) {
  mx40ConnectionMode = mode;
  document.getElementById('mx40DirectBtn').classList.toggle('active', mode === 'direct');
  document.getElementById('mx40IndirectBtn').classList.toggle('active', mode === 'indirect');
  calculate();
}

// Adjust number input with arrow buttons
function adjustNumberInput(inputId, delta) {
  const input = document.getElementById(inputId);
  if (input) {
    const currentValue = parseFloat(input.value) || 0;
    const step = parseFloat(input.step) || 1;
    const min = parseFloat(input.min);
    const max = parseFloat(input.max);
    let newValue = currentValue + (delta * step);

    if (!isNaN(min) && newValue < min) newValue = min;
    if (!isNaN(max) && newValue > max) newValue = max;

    input.value = newValue;
    input.dispatchEvent(new Event('input', { bubbles: true }));
    calculate();
  }
}

// Adjust canvas X/Y position with arrow buttons
function adjustCanvasPosition(inputId, delta) {
  const input = document.getElementById(inputId);
  if (!input) return;

  // Use Fine(px) value as the step
  const fineStep = parseInt(document.getElementById('arrowKeyIncrement').value) || 10;
  const currentValue = parseInt(input.value) || 0;
  const min = parseInt(input.min) || 0;
  let newValue = currentValue + (delta * fineStep);

  if (newValue < min) newValue = min;

  input.value = newValue;
  // Dispatch input event to trigger the handleCanvasPositionChange listener
  input.dispatchEvent(new Event('input', { bubbles: true }));
}

// Show arrows toggle
let showArrowsEnabled = true;
function toggleShowArrows() {
  showArrowsEnabled = !showArrowsEnabled;
  document.getElementById('showArrowsBtn').classList.toggle('active', showArrowsEnabled);
  calculate();
}

// Redundancy toggle
let redundancyEnabled = true;
function toggleRedundancy() {
  redundancyEnabled = !redundancyEnabled;
  document.getElementById('redundancyBtn').classList.toggle('active', redundancyEnabled);
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.redundancy = redundancyEnabled;
  }
  calculate();
}

// Processor Redundancy toggle
let processorRedundancyEnabled = false;
function toggleProcessorRedundancy() {
  processorRedundancyEnabled = !processorRedundancyEnabled;
  document.getElementById('processorRedundancyBtn').classList.toggle('active', processorRedundancyEnabled);
  calculate();
}

// 4-way bumpers toggle
let use4WayBumpersEnabled = false;
function toggle4WayBumpers() {
  use4WayBumpersEnabled = !use4WayBumpersEnabled;
  document.getElementById('use4WayBumpersBtn').classList.toggle('active', use4WayBumpersEnabled);
  
  // Re-initialize bumpers
  initializeBumpers();
  calculate();
}

// Bumpers on/off toggle
function toggleUseBumpers() {
  useBumpers = !useBumpers;
  document.getElementById('useBumpersBtn').classList.toggle('active', useBumpers);
  
  // Show/hide bumper controls
  const bumperControls = document.getElementById('bumperControls');
  const fourWayOption = document.getElementById('fourWayBumperOption');
  const weightDisplay = document.getElementById('weightDisplay');
  
  if(useBumpers) {
    if(bumperControls) bumperControls.style.display = '';
    
    // Restore showTopBumper/showBottomBumper based on structure type
    const structureType = document.getElementById('structureType').value;
    if(structureType === 'hanging') {
      showTopBumper = true;
      showBottomBumper = false;
    } else {
      showTopBumper = false;
      showBottomBumper = true;
    }
    
    // Show 4-way option if CB5 panel
    const panelType = document.getElementById('panelType').value;
    const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
    if(fourWayOption && isCB5) {
      fourWayOption.style.display = 'block';
    }
    
    // Re-initialize bumpers when turned on
    initializeBumpers();
  } else {
    if(bumperControls) bumperControls.style.display = 'none';
    if(fourWayOption) fourWayOption.style.display = 'none';
    if(weightDisplay) weightDisplay.style.display = 'none';
    // Clear bumpers when turned off
    bumpers = [];
    showTopBumper = false;
    showBottomBumper = false;
  }
  
  // Redraw structure view and recalculate
  generateStructureLayout();
  calculate();
}

// Set bumpers state based on panel type
function updateBumpersForPanelType(panelType) {
  const allPanels = getAllPanels();
  const panel = allPanels[panelType];
  
  // Check if panel has uses_bumpers property set to false
  const panelUsesBumpers = panel && panel.uses_bumpers !== false;
  
  // Update state and UI
  useBumpers = panelUsesBumpers;
  document.getElementById('useBumpersBtn').classList.toggle('active', useBumpers);
  
  // Show/hide bumper controls
  const bumperControls = document.getElementById('bumperControls');
  const fourWayOption = document.getElementById('fourWayBumperOption');
  const weightDisplay = document.getElementById('weightDisplay');
  
  if(useBumpers) {
    if(bumperControls) bumperControls.style.display = '';
  } else {
    if(bumperControls) bumperControls.style.display = 'none';
    if(fourWayOption) fourWayOption.style.display = 'none';
    if(weightDisplay) weightDisplay.style.display = 'none';
    // Clear bumpers
    bumpers = [];
    showTopBumper = false;
    showBottomBumper = false;
  }
}

// Snap mode toggle
let snapModeEnabled = true;
function toggleSnapMode() {
  snapModeEnabled = !snapModeEnabled;
  document.getElementById('snapModeBtn').classList.toggle('active', snapModeEnabled);
}

// CB5 Half row toggle
let cb5HalfRowEnabled = false;
function toggleCB5HalfRow() {
  cb5HalfRowEnabled = !cb5HalfRowEnabled;
  document.getElementById('addCB5HalfRowBtn').classList.toggle('active', cb5HalfRowEnabled);

  // Update screen data so canvas view reflects the change
  if(typeof screens !== 'undefined' && screens[currentScreenId]) {
    screens[currentScreenId].data.addCB5HalfRow = cb5HalfRowEnabled;
  }

  updateSuggestedDataLimit(); // Update max/data placeholder when half panels toggled
  calculate();
  updateWeightDisplay(); // Update bumper pickup weights for half panel row
}

// Connection method toggle
let connectionMethod = 'airframe';
function setConnectionMethod(method) {
  connectionMethod = method;
  document.getElementById('connectionAirframeBtn').classList.toggle('active', method === 'airframe');
  document.getElementById('connectionPlatesBtn').classList.toggle('active', method === 'plates');
  calculate();
}

// Cable drop position
let cableDropPosition = 'behind';
function setCableDropPosition(position) {
  cableDropPosition = position;
  document.getElementById('cableDropBehindBtn').classList.toggle('active', position === 'behind');
  document.getElementById('cableDropSRBtn').classList.toggle('active', position === 'sr');
  document.getElementById('cableDropSLBtn').classList.toggle('active', position === 'sl');
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.cableDropPosition = position;
  }
  generateGearList();
}

// Dist box on wall toggle
let distBoxOnWallEnabled = false;
function toggleDistBoxOnWall() {
  distBoxOnWallEnabled = !distBoxOnWallEnabled;
  document.getElementById('distBoxOnWallBtn').classList.toggle('active', distBoxOnWallEnabled);
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.distBoxOnWall = distBoxOnWallEnabled;
  }
  generateGearList();
}

// Compatibility getters - these mimic the old checkbox behavior
function isShowArrowsChecked() { return showArrowsEnabled; }
function isRedundancyChecked() { return redundancyEnabled; }
function isUse4WayBumpersChecked() { return use4WayBumpersEnabled; }
function isSnapModeChecked() { return snapModeEnabled; }
function isCB5HalfRowChecked() { return cb5HalfRowEnabled; }
function isConnectionPlates() { return connectionMethod === 'plates'; }

let lastLayoutMode = null;

// Interactive panel knockout state
let deletedPanels = new Set(); // stores "col,row" strings
let selectedPanels = new Set(); // stores "col,row" strings for multi-select
let customCircuitAssignments = new Map(); // stores "col,row" -> circuit number
let customDataLineAssignments = new Map(); // stores "col,row" -> data line number
let isDragging = false;
let dragStartX = 0;

// Eco-friendly print mode - uses lighter colors and white backgrounds
let ecoPrintMode = false;
// Greyscale print mode - converts all colors to greyscale
let greyscalePrintMode = false;

// Canvas movement undo/redo state
let canvasMoveHistory = [];
let canvasMoveHistoryIndex = -1;
const MAX_CANVAS_HISTORY = 20;

// Structure view bumper state - NEW SYSTEM
let showTopBumper = false;
let showBottomBumper = false;
let useBumpers = true; // Toggle for enabling/disabling bumpers entirely
let manualBumperMode = false; // Toggle for manual bumper distribution mode
let selectedBumpers = new Set(); // Selected bumpers (by id) in structure view
let structureIsDragging = false;
let structureDragStartX = 0;
let structureDragStartY = 0;

// Structure view undo/redo
let structureHistory = [];
let structureHistoryIndex = -1;
const MAX_STRUCTURE_HISTORY = 30;

// Legacy bumper variables (for backward compatibility during migration)
let topBumper1wColumn = -1;
let bottomBumper1wColumn = -1;
let manualTopBumpers = [];
let manualBottomBumpers = [];

// Bumper tracking system - stores all placed bumpers with their properties
let bumpers = []; // Array of {id, type:'1w'|'2w'|'4w', position:'top'|'bottom', startCol, endCol, x, y, width, height}
let nextBumperId = 1;
let selectedBumper = null; // Currently selected bumper for editing
let hoveredBumper = null; // Bumper under mouse cursor

// Structure canvas interaction state
let structureCanvas = null;
let structureDraggingBumper = null; // Currently being dragged bumper
let structureOriginalImageData = null; // Store canvas state for quick restore
let dragStartY = 0;
let currentCanvas = null;
let currentPw = 0;
let currentPh = 0;
let panelSize = 50;
let currentPanelWidth = 50;
let currentPanelHeight = 50;

// Canvas view offset (for dragging the wall around the canvas)
let canvasOffsetX = 0;
let canvasOffsetY = 0;
let canvasZoomLevel = 1.0; // Zoom level for canvas view (1.0 = 100%)
let canvasPanX = 0; // Pan offset X
let canvasPanY = 0; // Pan offset Y
let isPanningCanvas = false;
let panStartX = 0;
let panStartY = 0;

// Context menu state
let contextMenuVisible = false;
let contextMenuX = 0;
let contextMenuY = 0;
let contextMenuBumper = null;


// Undo/Redo system
let undoHistory = [];
let redoHistory = [];
const MAX_HISTORY = 50;

function saveState() {
  const state = {
    deletedPanels: new Set(deletedPanels),
    selectedPanels: new Set(selectedPanels),
    customCircuitAssignments: new Map(customCircuitAssignments),
    customDataLineAssignments: new Map(customDataLineAssignments)
  };
  
  undoHistory.push(state);
  if(undoHistory.length > MAX_HISTORY) {
    undoHistory.shift();
  }
  
  // Clear redo history when new action is performed
  redoHistory = [];
  updateUndoRedoButtons();
}

function undo() {
  if(undoHistory.length === 0) return;
  
  // Save current state to redo history
  const currentState = {
    deletedPanels: new Set(deletedPanels),
    selectedPanels: new Set(selectedPanels),
    customCircuitAssignments: new Map(customCircuitAssignments),
    customDataLineAssignments: new Map(customDataLineAssignments)
  };
  redoHistory.push(currentState);
  
  // Restore previous state
  const previousState = undoHistory.pop();
  deletedPanels = new Set(previousState.deletedPanels);
  selectedPanels = new Set(previousState.selectedPanels);
  customCircuitAssignments = new Map(previousState.customCircuitAssignments);
  customDataLineAssignments = new Map(previousState.customDataLineAssignments);
  
  // Sync deleted panels to current screen data for canvas view
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.deletedPanels = new Set(deletedPanels);
  }
  
  // Regenerate all layouts without calling calculate (which would reset redo stack)
  generateLayout('standard');
  generateLayout('power');
  generateLayout('data');
  generateStructureLayout();
  
  // Update canvas view to reflect changes
  showCanvasView();
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateUndoRedoButtons();
}

function redo() {
  if(redoHistory.length === 0) return;
  
  // Save current state to undo history
  const currentState = {
    deletedPanels: new Set(deletedPanels),
    selectedPanels: new Set(selectedPanels),
    customCircuitAssignments: new Map(customCircuitAssignments),
    customDataLineAssignments: new Map(customDataLineAssignments)
  };
  undoHistory.push(currentState);
  
  // Restore next state
  const nextState = redoHistory.pop();
  deletedPanels = new Set(nextState.deletedPanels);
  selectedPanels = new Set(nextState.selectedPanels);
  customCircuitAssignments = new Map(nextState.customCircuitAssignments);
  customDataLineAssignments = new Map(nextState.customDataLineAssignments);
  
  // Sync deleted panels to current screen data for canvas view
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.deletedPanels = new Set(deletedPanels);
  }
  
  // Regenerate all layouts without calling calculate (which would reset redo stack)
  generateLayout('standard');
  generateLayout('power');
  generateLayout('data');
  generateStructureLayout();
  
  // Update canvas view to reflect changes
  showCanvasView();
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if(undoBtn) {
    undoBtn.disabled = undoHistory.length === 0;
  }
  if(redoBtn) {
    redoBtn.disabled = redoHistory.length === 0;
  }
}

// Resistor colors for POWER and DATA layouts only
const resistorColors = ['#964B00','#FF0000','#FFA500','#FFFF00','#008000','#0000FF','#8B00FF','#808080','#FFFFFF','#333333'];
// Standard layout colors - magenta, cyan, yellow, blue, green, red at 50% brightness
const standardColors = [
  '#800080',  // Magenta at 50% brightness
  '#008080',  // Cyan at 50% brightness
  '#808000',  // Yellow at 50% brightness
  '#000080',  // Blue at 50% brightness
  '#008000',  // Green at 50% brightness
  '#800000'   // Red at 50% brightness
];

// ----------- Specs (updated from spec sheet) -----------
const panels = {
  "BP2_V2": {brand:"ROE Visual", name:"Black Pearl BP2 V2", pixel_pitch_mm:2.84, width_m:0.5, height_m:0.5, depth_mm:90, res_x:176, res_y:176, weight_kg:9.35, power_max_w:190, power_avg_w:95, brightness_nits:1500, max_hanging:20, max_stacking:12, bumper_1w_lbs:7.38, bumper_2w_lbs:17.1, max_panels_per_circuit:8, max_panels_per_data:16, power_jumper_ft:"1'", data_jumper_ft:"1'", data_cross_jumper_ft:"2'", jumpers_builtin:false},
  "CB5_MKII": {brand:"ROE Visual", name:"Carbon CB5 MKII", pixel_pitch_mm:5.77, width_m:0.6, height_m:1.2, depth_mm:80, res_x:104, res_y:208, weight_kg:19.908, power_max_w:480, power_avg_w:240, brightness_nits:6000, max_hanging:12, max_stacking:5, bumper_1w_lbs:13.9, bumper_2w_lbs:27.5, bumper_4w_lbs:66.15, max_panels_per_circuit:3, max_panels_per_data:24, power_jumper_ft:null, data_jumper_ft:null, data_cross_jumper_ft:"3'", jumpers_builtin:true},
  "CB5_MKII_HALF": {brand:"ROE Visual", name:"Carbon CB5 MKII Half Panel", pixel_pitch_mm:5.77, width_m:0.6, height_m:0.6, depth_mm:79, res_x:104, res_y:104, weight_kg:11.748, power_max_w:250, power_avg_w:125, brightness_nits:6000, max_hanging:24, max_stacking:10, bumper_1w_lbs:13.9, bumper_2w_lbs:27.5, bumper_4w_lbs:66.15, max_panels_per_circuit:6, max_panels_per_data:48, power_jumper_ft:null, data_jumper_ft:null, data_cross_jumper_ft:"3'", jumpers_builtin:true},
  "MC7H": {brand:"ROE Visual", name:"MC7H", pixel_pitch_mm:7.5, width_m:0.6, height_m:0.6, depth_mm:90, res_x:80, res_y:80, weight_kg:14.8, power_max_w:420, power_avg_w:210, brightness_nits:5000, max_hanging:20, max_stacking:8, bumper_1w_lbs:15.44, bumper_2w_lbs:28.22, max_panels_per_circuit:4, max_panels_per_data:82, power_jumper_ft:null, data_jumper_ft:null, data_cross_jumper_ft:"3'", jumpers_builtin:true},
  "BO3": {brand:"ROE Visual", name:"Black Onyx BO3", pixel_pitch_mm:3.47, width_m:0.5, height_m:0.5, depth_mm:90, res_x:144, res_y:144, weight_kg:9.35, power_max_w:170, power_avg_w:85, brightness_nits:1500, max_hanging:20, max_stacking:8, bumper_1w_lbs:7.38, bumper_2w_lbs:17.1, max_panels_per_circuit:9, max_panels_per_data:25, power_jumper_ft:"1'", data_jumper_ft:"1'", data_cross_jumper_ft:"2'", jumpers_builtin:false},
  "BM4_MATTE": {brand:"ROE Visual", name:"Black Marble BM4 (Matte)", pixel_pitch_mm:4.76, width_m:0.61, height_m:0.61, depth_mm:140, res_x:128, res_y:128, weight_kg:17.5, power_max_w:280, power_avg_w:140, brightness_nits:2000, max_hanging:null, max_stacking:null, bumper_1w_lbs:null, bumper_2w_lbs:null, max_panels_per_circuit:5, max_panels_per_data:32, power_jumper_ft:"4'", data_jumper_ft:"4'", data_cross_jumper_ft:"4'", jumpers_builtin:false, uses_bumpers:false, is_floor_panel:true, floor_frames:{frame_1x1:{name:"1x1 (1 panel)", panels:1, weight_lbs:26.5}, frame_2x1:{name:"2x1 (2 panels)", panels:2, weight_lbs:41.9}, frame_2x2:{name:"2x2 (4 panels)", panels:4, weight_lbs:62.8}, frame_3x2:{name:"3x2 (6 panels)", panels:6, weight_lbs:80.5}}},
  "DM2_6": {brand:"ROE Visual", name:"DM2.6", pixel_pitch_mm:2.6, width_m:0.5, height_m:0.5, depth_mm:80, res_x:192, res_y:192, weight_kg:5.76, power_max_w:180, power_avg_w:90, brightness_nits:1500, max_hanging:20, max_stacking:12, bumper_1w_lbs:7.38, bumper_2w_lbs:17.1, max_panels_per_circuit:8, max_panels_per_data:14, power_jumper_ft:"1.5'", data_jumper_ft:"1.5'", data_cross_jumper_ft:"3'", jumpers_builtin:false},
  "INFILED_AMT8_3": {brand:"INFiLED", name:"AMT 8.3", pixel_pitch_mm:8.33, width_m:1.0, height_m:1.0, depth_mm:107, res_x:120, res_y:120, weight_kg:15.8, power_max_w:720, power_avg_w:360, brightness_nits:5000, max_hanging:18, max_stacking:18, bumper_1w_lbs:null, bumper_2w_lbs:null, max_panels_per_circuit:2, max_panels_per_data:36, power_jumper_ft:"1.5'", data_jumper_ft:"1.5'", data_cross_jumper_ft:"4'", jumpers_builtin:false}
};

const processors = {
  "Brompton_SX40": {name:"Brompton SX40", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, pixels_per_10g:9000000, total_pixels:9000000, outputs:"4 × 10G trunks"},
  "Brompton_S8": {name:"Brompton S8", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:4500000, outputs:"8 × 1G"},
  "Brompton_M2": {name:"Brompton M2", base_pixels_1g:500000, base_framerate:60, base_bitdepth:8, total_pixels:2000000, outputs:"4 × 1G"},
  "Brompton_S4": {name:"Brompton S4", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:2070000, outputs:"4 × 1G"},
  "Brompton_T1": {name:"Brompton T1", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:525000, outputs:"1 × 1G"},
  "Brompton_SQ200": {name:"Brompton SQ200", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:36000000, outputs:"Dual 100G QSFP28"},
  "NovaStar_MX40_Pro": {name:"NovaStar MX40 Pro", base_pixels_1g:659722, base_framerate:60, base_bitdepth:8, total_pixels:9000000, outputs:"20 × 1G + 4 × 10G", pixels_1g_by_bitdepth:{8:659722, 10:494792, 12:329861}, ports_1g:20, ports_10g:4},
};

// ==================== CUSTOM PANELS AND PROCESSORS SYSTEM v24 ====================

// Storage keys
const STORAGE_KEY_CUSTOM_PANELS = 'ledcalc_custom_panels';
const STORAGE_KEY_CUSTOM_PROCESSORS = 'ledcalc_custom_processors';

// Custom panels storage
let customPanels = {};
let customProcessors = {};

// Load custom data from localStorage
function loadCustomData() {
  try {
    const panelsData = localStorage.getItem(STORAGE_KEY_CUSTOM_PANELS);
    if(panelsData) {
      customPanels = JSON.parse(panelsData);
      console.log('Loaded custom panels:', Object.keys(customPanels).length);
    }
    
    const processorsData = localStorage.getItem(STORAGE_KEY_CUSTOM_PROCESSORS);
    if(processorsData) {
      customProcessors = JSON.parse(processorsData);
      console.log('Loaded custom processors:', Object.keys(customProcessors).length);
    }
  } catch(err) {
    console.error('Error loading custom data:', err);
  }
}

// Save custom data to localStorage
function saveCustomPanels() {
  try {
    localStorage.setItem(STORAGE_KEY_CUSTOM_PANELS, JSON.stringify(customPanels));
  } catch(err) {
    console.error('Error saving custom panels:', err);
    alert('Error saving custom panel data');
  }
}

function saveCustomProcessors() {
  try {
    localStorage.setItem(STORAGE_KEY_CUSTOM_PROCESSORS, JSON.stringify(customProcessors));
  } catch(err) {
    console.error('Error saving custom processors:', err);
    alert('Error saving custom processor data');
  }
}

// Get all panels (built-in + custom)
function getAllPanels() {
  return {...panels, ...customPanels};
}

// Get all processors (built-in + custom)
function getAllProcessors() {
  return {...processors, ...customProcessors};
}

// Get panel height ratio (for CB5_MKII full panels which are 2:1 aspect ratio)
function getPanelHeightRatio(panelType) {
  // CB5_MKII full panels are 0.6m x 1.2m (width x height), so height = 2x width
  if(panelType === 'CB5_MKII') {
    return 2;
  }
  // All other panels are square (1:1 aspect ratio)
  return 1;
}

// Load custom data from localStorage on startup
loadCustomData();

// Helper functions to get current selections
function getCurrentPanel() {
  const allPanels = getAllPanels();
  const panelType = document.getElementById('panelType')?.value;
  return panelType ? allPanels[panelType] : null;
}

function getCurrentProcessor() {
  const allProcessors = getAllProcessors();
  const processorType = document.getElementById('processor')?.value;
  return processorType ? allProcessors[processorType] : null;
}

// Update panel dropdowns
function updatePanelDropdowns() {
  const panelSelect = document.getElementById('panelType');
  if(!panelSelect) return;

  const currentValue = panelSelect.value;
  const allPanels = getAllPanels();

  // Clear and rebuild
  panelSelect.innerHTML = '';

  // Group built-in panels by brand
  const builtInByBrand = {};
  Object.keys(panels).forEach(key => {
    const brand = panels[key].brand || 'Other';
    if(!builtInByBrand[brand]) builtInByBrand[brand] = [];
    builtInByBrand[brand].push({key, panel: panels[key]});
  });

  // Add built-in panels grouped by brand
  Object.keys(builtInByBrand).sort().forEach(brand => {
    const brandGroup = document.createElement('optgroup');
    brandGroup.label = brand;
    builtInByBrand[brand].forEach(({key, panel}) => {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = panel.name;
      brandGroup.appendChild(option);
    });
    panelSelect.appendChild(brandGroup);
  });

  // Group custom panels by brand
  if(Object.keys(customPanels).length > 0) {
    const customByBrand = {};
    Object.keys(customPanels).forEach(key => {
      const brand = customPanels[key].brand || 'Custom';
      if(!customByBrand[brand]) customByBrand[brand] = [];
      customByBrand[brand].push({key, panel: customPanels[key]});
    });

    // Add custom panels grouped by brand
    Object.keys(customByBrand).sort().forEach(brand => {
      const brandGroup = document.createElement('optgroup');
      brandGroup.label = `${brand} (Custom)`;
      customByBrand[brand].forEach(({key, panel}) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = panel.name;
        brandGroup.appendChild(option);
      });
      panelSelect.appendChild(brandGroup);
    });
  }

  // Add "Add Custom Panel" option
  const addOption = document.createElement('option');
  addOption.value = '__ADD_CUSTOM__';
  addOption.textContent = '+ Add Custom Panel...';
  addOption.style.fontWeight = 'bold';
  addOption.style.color = '#4a9eff';
  panelSelect.appendChild(addOption);

  // Restore selection
  if(currentValue && allPanels[currentValue]) {
    panelSelect.value = currentValue;
  }
}

// Update processor dropdowns
function updateProcessorDropdowns() {
  const processorSelect = document.getElementById('processor');
  if(!processorSelect) return;

  const currentValue = processorSelect.value;
  const allProcessors = getAllProcessors();

  // Clear and rebuild
  processorSelect.innerHTML = '';

  // Helper to extract brand from processor key or name
  function getProcessorBrand(key, proc) {
    if(proc.brand) return proc.brand;
    // Extract brand from key (e.g., "Brompton_SX40" -> "Brompton")
    if(key.startsWith('Brompton')) return 'Brompton';
    if(key.startsWith('NovaStar')) return 'NovaStar';
    if(key.startsWith('Megapixel')) return 'Megapixel';
    if(key.startsWith('ROE')) return 'ROE Visual';
    // Try to extract from name
    if(proc.name && proc.name.startsWith('Brompton')) return 'Brompton';
    if(proc.name && proc.name.startsWith('NovaStar')) return 'NovaStar';
    if(proc.name && proc.name.startsWith('Megapixel')) return 'Megapixel';
    if(proc.name && proc.name.startsWith('ROE')) return 'ROE Visual';
    return 'Other';
  }

  // Helper to get display name (without brand prefix)
  function getProcessorDisplayName(proc, brand) {
    let name = proc.name;
    // Remove brand prefix from name if present
    if(name.startsWith(brand + ' ')) {
      name = name.substring(brand.length + 1);
    }
    return name;
  }

  // Group built-in processors by brand
  const builtInByBrand = {};
  Object.keys(processors).forEach(key => {
    const brand = getProcessorBrand(key, processors[key]);
    if(!builtInByBrand[brand]) builtInByBrand[brand] = [];
    builtInByBrand[brand].push({key, proc: processors[key], brand});
  });

  // Add built-in processors grouped by brand
  Object.keys(builtInByBrand).sort().forEach(brand => {
    const brandGroup = document.createElement('optgroup');
    brandGroup.label = brand;
    builtInByBrand[brand].forEach(({key, proc, brand}) => {
      const option = document.createElement('option');
      option.value = key;
      let displayName = getProcessorDisplayName(proc, brand);
      // Keep "(in development)" in the name for development processors
      option.textContent = displayName;
      brandGroup.appendChild(option);
    });
    processorSelect.appendChild(brandGroup);
  });

  // Group custom processors by brand
  if(Object.keys(customProcessors).length > 0) {
    const customByBrand = {};
    Object.keys(customProcessors).forEach(key => {
      const brand = customProcessors[key].brand || 'Custom';
      if(!customByBrand[brand]) customByBrand[brand] = [];
      customByBrand[brand].push({key, proc: customProcessors[key]});
    });

    // Add custom processors grouped by brand
    Object.keys(customByBrand).sort().forEach(brand => {
      const brandGroup = document.createElement('optgroup');
      brandGroup.label = `${brand} (Custom)`;
      customByBrand[brand].forEach(({key, proc}) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = proc.name;
        brandGroup.appendChild(option);
      });
      processorSelect.appendChild(brandGroup);
    });
  }

  // Restore selection
  if(currentValue && allProcessors[currentValue]) {
    processorSelect.value = currentValue;
  }
}

// ==================== END CUSTOM STORAGE SYSTEM ====================

// Bumper weights (in kg, converted from lbs where needed)
const bumperWeights = {
  '1w': 2.5,  // kg (approximate)
  '2w': 4.0,  // kg (approximate)
  '4w': 30.0  // kg (66.15 lbs)
};

function calculateAdjustedPixelCapacity(processor, frameRate, bitDepth){
  // Check if processor has bit-depth specific capacity values (e.g., MX40 Pro)
  let baseCapacity;
  if(processor.pixels_1g_by_bitdepth && processor.pixels_1g_by_bitdepth[bitDepth]) {
    // Use exact capacity for this bit depth (already accounts for bit depth)
    baseCapacity = processor.pixels_1g_by_bitdepth[bitDepth];
    const baseFR = processor.base_framerate || 60;
    const frameRateScale = baseFR / frameRate;
    return Math.floor(baseCapacity * frameRateScale);
  }

  // Standard calculation for other processors
  baseCapacity = processor.base_pixels_1g || 525000;
  const baseFR = processor.base_framerate || 60;
  const frameRateScale = baseFR / frameRate;
  let bitDepthScale = 1.0;
  if(bitDepth === 10) bitDepthScale = 8 / 10;
  else if(bitDepth === 12) bitDepthScale = 8 / 12;
  const adjustedCapacity = baseCapacity * frameRateScale * bitDepthScale;
  return Math.floor(adjustedCapacity);
}

function toMeters(v, units){ return units==='m' ? v : v*0.3048; }
function fromMeters(m, units){ return units==='m' ? m : m/0.3048; }

function approxAspectRatio(w,h){
  const ratio=w/h;
  const common=[{n:'16:9',v:16/9},{n:'4:3',v:4/3},{n:'3:2',v:3/2},{n:'2:1',v:2/1},{n:'21:9',v:21/9},{n:'1:1',v:1}];
  for(const c of common){ if(Math.abs(ratio-c.v)/c.v<0.02) return {label:c.n, value:ratio}; }
  let best={num:Math.round(ratio*10), den:10, diff:Math.abs(ratio-Math.round(ratio*10)/10)};
  for(let den=1; den<=20; den++){ const num=Math.round(ratio*den); const diff=Math.abs(ratio-(num/den)); if(diff<best.diff){ best={num,den,diff}; } }
  return {label:`${best.num}:${best.den}`, value:ratio};
}

function showSpecWarningIfNeeded(){
  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  const warn = document.getElementById('specWarning');
  if(!p) { warn.textContent = ''; return; }
  const missingCritical = !p.width_m || !p.height_m || !p.res_x || !p.res_y || !p.power_max_w;
  warn.textContent = missingCritical ? "⚠️ Selected model has unconfirmed specs (TBD). Calculations and layouts are limited until datasheet values are confirmed." : "";
}

// Structure functions
function updateBumpersFromStructureType() {
  const structureType = document.getElementById('structureType').value;

  if(structureType === 'hanging') {
    showTopBumper = true;
    showBottomBumper = false;
  } else if(structureType === 'floor') {
    // Floor panels don't use bumpers - they use floor frames
    showTopBumper = false;
    showBottomBumper = false;
  } else { // ground
    showTopBumper = false;
    showBottomBumper = true;
  }

  // Re-initialize bumpers when structure type changes (not for floor)
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  if(pw > 0 && structureType !== 'floor') {
    initializeBumpers();
  }

  updateStructureVisualization();
  updateWeightDisplay();
}

function set1wColumn() {
  const input = document.getElementById('bumper1wColumnInput');
  const col = parseInt(input.value);
  const W = parseInt(document.getElementById('panelsWide').value) || 0;
  
  if(col >= 1 && col <= W) {
    const structureType = document.getElementById('structureType').value;
    
    if(structureType === 'hanging') {
      topBumper1wColumn = col - 1; // Convert to 0-indexed
    } else { // ground
      bottomBumper1wColumn = col - 1;
    }
    
    updateStructureVisualization();
    updateWeightDisplay();
  } else {
    alert(`Please enter a column number between 1 and ${W}`);
  }
}

function clear1wColumn() {
  const structureType = document.getElementById('structureType').value;
  
  if(structureType === 'hanging') {
    topBumper1wColumn = -1;
  } else { // ground
    bottomBumper1wColumn = -1;
  }
  
  const input = document.getElementById('bumper1wColumnInput');
  if(input) input.value = '';
  
  updateStructureVisualization();
  updateWeightDisplay();
}

function updateStructureVisualization() {
  const canvas = document.getElementById('structureCanvas');
  if(canvas && canvas.width > 0) {
    generateStructureLayout();
  }
}

function updateWeightDisplay() {
  const weightDiv = document.getElementById('weightDisplay');
  const weightContent = document.getElementById('weightContent');
  const bumperDistSelect = document.getElementById('bumperDistribution');
  
  // Return early if elements don't exist yet
  if(!weightDiv || !weightContent || !bumperDistSelect) {
    return;
  }
  
  const bumperDist = bumperDistSelect.value;
  
  if(bumperDist !== 'auto' || (!showTopBumper && !showBottomBumper)) {
    weightDiv.style.display = 'none';
    return;
  }
  
  weightDiv.style.display = 'block';
  
  const W = parseInt(document.getElementById('panelsWide').value) || 0;
  const H = parseInt(document.getElementById('panelsHigh').value) || 0;
  const panelType = document.getElementById('panelType').value;
  const allPanels = getAllPanels();
  const p = allPanels[panelType];

  if(W === 0 || H === 0 || !p) {
    weightContent.innerHTML = '<div style="color: #888;">Enter dimensions to calculate weights</div>';
    return;
  }
  
  // Check if panel has bumper weight data
  if(p.bumper_1w_lbs === null || p.bumper_1w_lbs === undefined || 
     p.bumper_2w_lbs === null || p.bumper_2w_lbs === undefined) {
    weightContent.innerHTML = '<div style="color: #888;">No bumper weight data available for this panel type</div>';
    return;
  }
  
  // Convert panel-specific bumper weights from lbs to kg
  const bumper1wKg = p.bumper_1w_lbs * 0.453592;
  const bumper2wKg = p.bumper_2w_lbs * 0.453592;
  const bumper4wKg = p.bumper_4w_lbs ? (p.bumper_4w_lbs * 0.453592) : 0;
  
  // Get correct panel weight based on connection method
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const panelWeightKg = getPanelWeight(panelType, useConnectingPlates);

  // Check if CB5 half panel row is enabled
  const hasCB5HalfRow = cb5HalfRowEnabled && panelType === 'CB5_MKII';
  const halfPanelWeightKg = hasCB5HalfRow ? getPanelWeight('CB5_MKII_HALF', useConnectingPlates) : 0;

  let html = '';

  const needsOneW = W % 2 === 1;
  const num2WBumpers = Math.floor(W / 2);

  // Check if 4-way bumpers are enabled for CB5
  const use4Way = use4WayBumpersEnabled;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const show4WayOnly = use4Way && isCB5;
  
  // Only show 2-way bumpers if NOT using 4-way bumpers
  if(!show4WayOnly) {
    if(showTopBumper) {
      html += '<div style="font-weight: bold; color: #4CAF50; margin-bottom: 4px;">Top Bumper</div>';
      
      // Show 2W bumpers
      for(let i = 0; i < num2WBumpers; i++) {
        const col1 = i * 2;
        const col2 = i * 2 + 1;
        let panelCount = 0;
        let panelWeight = 0;
        // Count full panels
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) panelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) panelCount++;
        }
        panelWeight = panelCount * panelWeightKg;
        // Add half panel row weight if enabled
        if(hasCB5HalfRow) {
          panelWeight += 2 * halfPanelWeightKg; // 2 half panels per 2W bumper
        }
        const totalWeight = panelWeight + bumper2wKg;
        html += `<div class="weight-item">Cols ${col1 + 1}-${col2 + 1} (2W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }

      // Show 1W bumper if needed
      if(needsOneW) {
        const lastCol = W - 1;
        let panelCount = 0;
        let panelWeight = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${lastCol},${row}`)) panelCount++;
        }
        panelWeight = panelCount * panelWeightKg;
        // Add half panel row weight if enabled
        if(hasCB5HalfRow) {
          panelWeight += halfPanelWeightKg; // 1 half panel for 1W bumper
        }
        const totalWeight = panelWeight + bumper1wKg;
        html += `<div class="weight-item">Col ${lastCol + 1} (1W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }

    if(showBottomBumper) {
      if(showTopBumper) html += '<div style="margin-top: 8px;"></div>';
      html += '<div style="font-weight: bold; color: #FF9800; margin-bottom: 4px;">Bottom Bumper</div>';

      // Show 2W bumpers
      for(let i = 0; i < num2WBumpers; i++) {
        const col1 = i * 2;
        const col2 = i * 2 + 1;
        let panelCount = 0;
        let panelWeight = 0;
        // Count full panels
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) panelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) panelCount++;
        }
        panelWeight = panelCount * panelWeightKg;
        // Add half panel row weight if enabled
        if(hasCB5HalfRow) {
          panelWeight += 2 * halfPanelWeightKg; // 2 half panels per 2W bumper
        }
        const totalWeight = panelWeight + bumper2wKg;
        html += `<div class="weight-item">Cols ${col1 + 1}-${col2 + 1} (2W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }

      // Show 1W bumper if needed
      if(needsOneW) {
        const lastCol = W - 1;
        let panelCount = 0;
        let panelWeight = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${lastCol},${row}`)) panelCount++;
        }
        panelWeight = panelCount * panelWeightKg;
        // Add half panel row weight if enabled
        if(hasCB5HalfRow) {
          panelWeight += halfPanelWeightKg; // 1 half panel for 1W bumper
        }
        const totalWeight = panelWeight + bumper1wKg;
        html += `<div class="weight-item">Col ${lastCol + 1} (1W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }
  }
  
  // Add 4-way bumper calculations for CB5 (replaces 2-way display when enabled)
  if(show4WayOnly && (showTopBumper || showBottomBumper) && bumper4wKg > 0) {
    
    if(showTopBumper) {
      html += '<div style="font-weight: bold; color: #4CAF50; margin-bottom: 4px;">Top Bumper (4-Way)</div>';
      
      const fourWayCount = Math.floor(W / 4);  // Each 4W covers 4 columns
      for(let i = 0; i < fourWayCount; i++) {
        // Each 4W bumper covers 4 columns: i*4, i*4+1, i*4+2, i*4+3
        const col1 = i * 4;
        const col2 = i * 4 + 1;
        const col3 = i * 4 + 2;
        const col4 = i * 4 + 3;
        
        // Count panels in all 4 columns
        let totalPanelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col3},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col4},${row}`)) totalPanelCount++;
        }
        
        // 4W bumper pickup includes: 4 columns of panels + 2x 2W bumpers + 1x 4W bumper
        let panelWeight = totalPanelCount * panelWeightKg;
        // Add half panel row weight if enabled (4 half panels per 4W bumper)
        if(hasCB5HalfRow) {
          panelWeight += 4 * halfPanelWeightKg;
        }
        const bumper2wWeight = 2 * bumper2wKg;  // Two 2W bumpers (27.5 lbs each for CB5)
        const bumper4wWeight = bumper4wKg;      // One 4W bumper (66.15 lbs for CB5)
        const totalWeight = panelWeight + bumper2wWeight + bumper4wWeight;

        html += `<div class="weight-item">Cols ${col1 + 1}-${col4 + 1} (4W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }

    if(showBottomBumper) {
      if(showTopBumper) html += '<div style="margin-top: 8px;"></div>';
      html += '<div style="font-weight: bold; color: #FF9800; margin-bottom: 4px;">Bottom Bumper (4-Way)</div>';
      
      const fourWayCount = Math.floor(W / 4);  // Each 4W covers 4 columns
      for(let i = 0; i < fourWayCount; i++) {
        // Each 4W bumper covers 4 columns: i*4, i*4+1, i*4+2, i*4+3
        const col1 = i * 4;
        const col2 = i * 4 + 1;
        const col3 = i * 4 + 2;
        const col4 = i * 4 + 3;
        
        // Count panels in all 4 columns
        let totalPanelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col3},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col4},${row}`)) totalPanelCount++;
        }
        
        // 4W bumper pickup includes: 4 columns of panels + 2x 2W bumpers + 1x 4W bumper
        let panelWeight = totalPanelCount * panelWeightKg;
        // Add half panel row weight if enabled (4 half panels per 4W bumper)
        if(hasCB5HalfRow) {
          panelWeight += 4 * halfPanelWeightKg;
        }
        const bumper2wWeight = 2 * bumper2wKg;  // Two 2W bumpers (27.5 lbs each for CB5)
        const bumper4wWeight = bumper4wKg;      // One 4W bumper (66.15 lbs for CB5)
        const totalWeight = panelWeight + bumper2wWeight + bumper4wWeight;

        html += `<div class="weight-item">Cols ${col1 + 1}-${col4 + 1} (4W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }
  }

  weightContent.innerHTML = html;
}

function calculateTotalBumperWeight(W, H) {
  // Calculate total bumper weight based on current configuration
  let totalBumperWeight = 0;
  
  // Check if bumpers are enabled
  if(!useBumpers) {
    return 0;
  }
  
  // Use the global variable for 4-way bumpers state
  const use4Way = use4WayBumpersEnabled;
  
  const panelTypeSelect = document.getElementById('panelType');
  const panelType = panelTypeSelect ? panelTypeSelect.value : '';
  const allPanels = getAllPanels();
  const p = allPanels[panelType];

  // Return 0 if panel doesn't have bumper weight data
  if(!p || p.bumper_1w_lbs === null || p.bumper_1w_lbs === undefined || 
     p.bumper_2w_lbs === null || p.bumper_2w_lbs === undefined) {
    return 0;
  }
  
  // Convert lbs to kg for panel-specific bumper weights
  const bumper1wKg = p.bumper_1w_lbs * 0.453592;
  const bumper2wKg = p.bumper_2w_lbs * 0.453592;
  const bumper4wKg = p.bumper_4w_lbs ? (p.bumper_4w_lbs * 0.453592) : 0;
  
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  const bumperDistSelect = document.getElementById('bumperDistribution');
  const bumperDist = bumperDistSelect ? bumperDistSelect.value : 'auto';
  
  // Only calculate bumper weights if in auto mode
  if(bumperDist !== 'auto') {
    return 0;
  }
  
  // When 4-way bumpers are enabled for CB5, use different calculation
  if(use4Way && isCB5 && (showTopBumper || showBottomBumper) && bumper4wKg > 0) {
    const fourWayCount = Math.floor(W / 4);  // Each 4W covers 4 columns
    const remainingCols = W % 4;              // Leftover columns after 4W bumpers
    
    // Add 4W bumpers for top (includes 2x 2W bumpers + 1x 4W bumper per pickup)
    if(showTopBumper) {
      totalBumperWeight += fourWayCount * bumper4wKg;           // 4W bumper weight
      totalBumperWeight += fourWayCount * 2 * bumper2wKg;        // 2x 2W bumpers per 4W
      
      // Add bumpers for remaining columns (not covered by 4W)
      if(remainingCols >= 2) {
        // Add 2W bumper(s) for pairs
        const extra2W = Math.floor(remainingCols / 2);
        totalBumperWeight += extra2W * bumper2wKg;
      }
      if(remainingCols % 2 === 1) {
        // Add 1W bumper for the last odd column
        totalBumperWeight += bumper1wKg;
      }
    }
    
    // Add 4W bumpers for bottom (includes 2x 2W bumpers + 1x 4W bumper per pickup)
    if(showBottomBumper) {
      totalBumperWeight += fourWayCount * bumper4wKg;           // 4W bumper weight
      totalBumperWeight += fourWayCount * 2 * bumper2wKg;        // 2x 2W bumpers per 4W
      
      // Add bumpers for remaining columns (not covered by 4W)
      if(remainingCols >= 2) {
        // Add 2W bumper(s) for pairs
        const extra2W = Math.floor(remainingCols / 2);
        totalBumperWeight += extra2W * bumper2wKg;
      }
      if(remainingCols % 2 === 1) {
        // Add 1W bumper for the last odd column
        totalBumperWeight += bumper1wKg;
      }
    }
  } else {
    // Standard 2W bumper calculation (when NOT using 4-way bumpers)
    const needsOneW = W % 2 === 1;
    const num2WBumpers = Math.floor(W / 2);
    
    // Calculate top bumper weight
    if(showTopBumper) {
      // Add 2W bumpers (each covers 2 columns)
      totalBumperWeight += num2WBumpers * bumper2wKg;
      // Add 1W bumper for the remaining column if odd width
      if(needsOneW) {
        totalBumperWeight += bumper1wKg;
      }
    }
    
    // Calculate bottom bumper weight
    if(showBottomBumper) {
      // Add 2W bumpers (each covers 2 columns)
      totalBumperWeight += num2WBumpers * bumper2wKg;
      // Add 1W bumper for the remaining column if odd width
      if(needsOneW) {
        totalBumperWeight += bumper1wKg;
      }
    }
  }
  
  return totalBumperWeight;
}

// ==================== COMPREHENSIVE BUMPER MANAGEMENT SYSTEM v23 ====================

// Initialize bumpers based on structure configuration
function initializeBumpers() {
  // Skip if bumpers are disabled
  if(!useBumpers) {
    bumpers = [];
    showTopBumper = false;
    showBottomBumper = false;
    return;
  }
  
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  console.log('Initializing bumpers:', {pw, ph, use4Way, isCB5, showTopBumper, showBottomBumper});
  
  bumpers = [];
  nextBumperId = 1;
  
  // Reset the bumpersInitialized flag for current screen since we're creating fresh bumpers
  // This will be set back to true when saveCurrentScreenData() runs
  if(screens[currentScreenId] && screens[currentScreenId].data) {
    screens[currentScreenId].data.bumpersInitialized = false;
  }
  
  if(pw === 0) {
    console.log('Width is 0, skipping bumper initialization');
    return;
  }
  
  // Initialize top bumpers
  if(showTopBumper) {
    console.log('Adding top bumpers...');
    if(use4Way && isCB5) {
      // Add 4W bumpers first - each spans from center of one 2W to center of next 2W
      // This covers 2 columns (2 panel widths) per 4W bumper
      const fourWayCount = Math.floor(pw / 4);
      for(let i = 0; i < fourWayCount; i++) {
        // Each 4W spans from center of 2W at (i*4, i*4+1) to center of 2W at (i*4+2, i*4+3)
        // First 2W center: (i*4 + 0.5 + i*4 + 1.5)/2 = i*4 + 1
        // Second 2W center: (i*4 + 2.5 + i*4 + 3.5)/2 = i*4 + 3
        bumpers.push({
          id: nextBumperId++,
          type: '4w',
          position: 'top',
          startCol: i * 4 + 1,      // Center of first 2W: 1, 5, 9...
          endCol: i * 4 + 3         // Center of second 2W: 3, 7, 11...
        });
      }
      
      // Add 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'top',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'top',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
    } else {
      // Just 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'top',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'top',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
    }
  }
  
  // Initialize bottom bumpers
  if(showBottomBumper) {
    console.log('Adding bottom bumpers...');
    if(use4Way && isCB5) {
      // Add 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'bottom',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'bottom',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
      
      // Add 4W bumpers - each spans from center of one 2W to center of next 2W
      const fourWayCount = Math.floor(pw / 4);
      for(let i = 0; i < fourWayCount; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '4w',
          position: 'bottom',
          startCol: i * 4 + 1,      // Center of first 2W: 1, 5, 9...
          endCol: i * 4 + 3         // Center of second 2W: 3, 7, 11...
        });
      }
    } else {
      // Just 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'bottom',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'bottom',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
    }
  }
  
  console.log(`Initialized ${bumpers.length} bumpers:`, bumpers);
}

// Get bumper at mouse position
function getBumperAtMouse(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  
  // Check bumpers in reverse order (top-most first)
  for(let i = bumpers.length - 1; i >= 0; i--) {
    const bumper = bumpers[i];
    
    // Check if bumper has position data (use undefined check, not falsy check since y can be 0)
    if(bumper.x === undefined || bumper.y === undefined || 
       bumper.width === undefined || bumper.height === undefined) continue;
    
    if(x >= bumper.x && x <= bumper.x + bumper.width &&
       y >= bumper.y && y <= bumper.y + bumper.height) {
      return bumper;
    }
  }
  
  return null;
}

// Create and show context menu
function showBumperContextMenu(bumper, x, y) {
  hideContextMenu();
  
  const menu = document.createElement('div');
  menu.id = 'bumperContextMenu';
  menu.style.cssText = `
    position: fixed;
    left: ${x}px;
    top: ${y}px;
    background: #2a2a2a;
    border: 1px solid #555;
    border-radius: 6px;
    padding: 4px 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    z-index: 10000;
    min-width: 180px;
    font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
  `;
  
  const options = [];
  
  // Type-specific options
  if(bumper.type === '2w') {
    options.push({
      label: `Replace with 1W Bumper`,
      action: () => replaceBumperType(bumper.id, '1w')
    });
    
    // Add option to move ladder hardware to other column (only for bottom 2W bumpers)
    if(bumper.position === 'bottom') {
      const currentLadderCol = bumper.ladderColumn === 'right' ? 'right (col ' + (bumper.endCol + 1) + ')' : 'left (col ' + (bumper.startCol + 1) + ')';
      const targetCol = bumper.ladderColumn === 'right' ? 'left' : 'right';
      const targetColNum = bumper.ladderColumn === 'right' ? bumper.startCol + 1 : bumper.endCol + 1;
      options.push({
        label: `Move Ladder to Col ${targetColNum}`,
        action: () => toggleBumperLadderColumn(bumper.id)
      });
    }
  } else if(bumper.type === '1w') {
    options.push({
      label: `Replace with 2W Bumper`,
      action: () => replaceBumperType(bumper.id, '2w')
    });
  }
  
  options.push({ separator: true });
  
  options.push({
    label: `Delete Bumper`,
    danger: true,
    action: () => deleteBumper(bumper.id)
  });
  
  options.forEach(opt => {
    if(opt.separator) {
      const sep = document.createElement('div');
      sep.style.cssText = 'height: 1px; background: #444; margin: 4px 0;';
      menu.appendChild(sep);
    } else {
      const item = document.createElement('div');
      item.textContent = opt.label;
      item.style.cssText = `
        padding: 8px 16px;
        cursor: pointer;
        color: ${opt.danger ? '#ff6b6b' : '#e0e0e0'};
        font-size: 13px;
      `;
      
      item.addEventListener('mouseenter', function() {
        this.style.background = opt.danger ? '#4a2020' : '#3a3a3a';
      });
      
      item.addEventListener('mouseleave', function() {
        this.style.background = 'transparent';
      });
      
      item.addEventListener('click', function(e) {
        e.stopPropagation();
        opt.action();
        hideContextMenu();
      });
      
      menu.appendChild(item);
    }
  });
  
  document.body.appendChild(menu);
  contextMenuVisible = true;
  
  // Adjust if off-screen
  const menuRect = menu.getBoundingClientRect();
  if(menuRect.right > window.innerWidth) {
    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
  }
  if(menuRect.bottom > window.innerHeight) {
    menu.style.top = (window.innerHeight - menuRect.height - 10) + 'px';
  }
}

// Toggle which column the ladder hardware is on for a 2W bumper
function toggleBumperLadderColumn(bumperId) {
  const bumper = bumpers.find(b => b.id === bumperId);
  if(!bumper || bumper.type !== '2w') return;
  
  // Toggle between left (default/undefined) and right
  bumper.ladderColumn = bumper.ladderColumn === 'right' ? 'left' : 'right';
  
  // Redraw structure layout
  generateStructureLayout();
}

function hideContextMenu() {
  const menu = document.getElementById('bumperContextMenu');
  if(menu && menu.parentNode) {
    menu.parentNode.removeChild(menu);
  }
  contextMenuVisible = false;
}

// Toggle manual bumper distribution mode
function toggleManualBumperMode() {
  manualBumperMode = !manualBumperMode;
  
  const toggleBtn = document.getElementById('manualBumperToggle');
  const hintSpan = document.getElementById('structureModeHint');
  const selectionInfo = document.getElementById('structureSelectionInfo');
  const undoRedoDiv = document.getElementById('structureUndoRedo');
  
  if(manualBumperMode) {
    toggleBtn.classList.add('active');
    toggleBtn.textContent = '✓ Manual Mode Active';
    hintSpan.textContent = 'Click bumpers to select';
    selectionInfo.classList.add('visible');
    undoRedoDiv.style.display = 'flex';
    
    // Save initial state when entering manual mode
    saveStructureState();
    updateStructureUndoRedoButtons();
  } else {
    toggleBtn.classList.remove('active');
    toggleBtn.textContent = 'Manually Distribute Bumpers';
    hintSpan.textContent = 'Auto-distribution active';
    selectionInfo.classList.remove('visible');
    undoRedoDiv.style.display = 'none';
    
    // Clear selections when exiting manual mode
    selectedBumpers.clear();
    selectedBumper = null;
  }
  
  // Redraw to show/hide selection highlights
  generateStructureLayout();
}

// Get panel at mouse position in structure canvas
function getStructurePanelAtMouse(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);

  // Get proper panel dimensions for structure layout
  const panelType = document.getElementById('panelType').value;
  const heightRatio = getPanelHeightRatio(panelType);
  const size = panelSize; // Base size for scaling
  const panelWidth = size;
  const panelHeight = size * heightRatio;
  
  const {pw, ph} = getEffectivePanelCountsForLayout();

  // Calculate panel Y offset (accounting for top bumpers)
  const bumperHeight = Math.max(30, size * 0.8);
  const fourWayHeight = Math.max(15, size * 0.4);
  const fourWayGap = Math.max(3, size * 0.1);
  const use4Way = use4WayBumpersEnabled;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  let panelYOffset = 0;
  if(showTopBumper) {
    panelYOffset += bumperHeight;
    if(use4Way && isCB5) panelYOffset += fourWayHeight + fourWayGap;
  }
  
  // Check if click is in panel area
  if(y < panelYOffset || y >= panelYOffset + ph * panelHeight) return null;
  if(x < 0 || x >= pw * panelWidth) return null;
  
  const col = Math.floor(x / panelWidth);
  const row = Math.floor((y - panelYOffset) / panelHeight);
  
  if(col < 0 || col >= pw || row < 0 || row >= ph) return null;
  
  const panelKey = `${col},${row}`;
  
  // Don't select deleted panels
  if(deletedPanels.has(panelKey)) return null;
  
  return {
    col: col,
    row: row,
    key: panelKey,
    x: col * panelWidth,
    y: panelYOffset + row * panelHeight
  };
}

// Get all panels in a rectangle (for drag selection in structure view)
function getStructurePanelsInRect(startX, startY, endX, endY) {
  const canvas = document.getElementById('structureCanvas');
  if(!canvas) return [];
  
  const rect = canvas.getBoundingClientRect();
  const x1 = (Math.min(startX, endX) - rect.left) * (canvas.width / rect.width);
  const y1 = (Math.min(startY, endY) - rect.top) * (canvas.height / rect.height);
  const x2 = (Math.max(startX, endX) - rect.left) * (canvas.width / rect.width);
  const y2 = (Math.max(startY, endY) - rect.top) * (canvas.height / rect.height);

  const size = panelSize; // Use global panelSize for consistent sizing
  const {pw, ph} = getEffectivePanelCountsForLayout();

  // Calculate panel Y offset
  const bumperHeight = Math.max(30, size * 0.8);
  const fourWayHeight = Math.max(15, size * 0.4);
  const fourWayGap = Math.max(3, size * 0.1);
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  let panelYOffset = 0;
  if(showTopBumper) {
    panelYOffset += bumperHeight;
    if(use4Way && isCB5) panelYOffset += fourWayHeight + fourWayGap;
  }
  
  const panels = [];
  
  for(let col = 0; col < pw; col++) {
    for(let row = 0; row < ph; row++) {
      const panelX = col * size;
      const panelY = panelYOffset + row * size;
      
      // Check if panel intersects with selection rectangle
      if(panelX + size > x1 && panelX < x2 && 
         panelY + size > y1 && panelY < y2) {
        const panelKey = `${col},${row}`;
        if(!deletedPanels.has(panelKey)) {
          panels.push({
            col: col,
            row: row,
            key: panelKey
          });
        }
      }
    }
  }
  
  return panels;
}

// Update the structure selection info display
function updateStructureSelectionInfo() {
  const infoDiv = document.getElementById('structureSelectionInfo');
  if(!infoDiv) return;
  
  if(!manualBumperMode) {
    infoDiv.classList.remove('visible');
    return;
  }
  
  const bumperCount = selectedBumpers.size;
  
  let text = '<strong>Manual Mode:</strong> ';
  
  if(bumperCount === 0) {
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const isMobile = window.innerWidth <= 768;
    if(isTouchDevice || isMobile) {
      text += '<span id="structureHintText">Tap to select • Tap again for options • Hold to drag</span>';
    } else {
      text += '<span id="structureHintText">Click to select • Right-click for options • Drag to move</span>';
    }
  } else {
    text += `Selected: ${bumperCount} bumper${bumperCount > 1 ? 's' : ''}`;
  }

  infoDiv.innerHTML = text;
  infoDiv.classList.add('visible');
}

// Structure undo/redo functions
function saveStructureState() {
  // Don't save if not in manual mode
  if(!manualBumperMode) return;
  
  // Create a deep copy of the bumpers array
  const state = {
    bumpers: bumpers.map(b => ({...b})),
    nextBumperId: nextBumperId
  };
  
  // Remove any states after current index (when we make a new change after undoing)
  if(structureHistoryIndex < structureHistory.length - 1) {
    structureHistory = structureHistory.slice(0, structureHistoryIndex + 1);
  }
  
  // Add new state
  structureHistory.push(state);
  
  // Limit history size
  if(structureHistory.length > MAX_STRUCTURE_HISTORY) {
    structureHistory.shift();
  } else {
    structureHistoryIndex++;
  }
  
  updateStructureUndoRedoButtons();
}

function structureUndo() {
  if(structureHistoryIndex <= 0) return;
  
  structureHistoryIndex--;
  restoreStructureState(structureHistory[structureHistoryIndex]);
}

function structureRedo() {
  if(structureHistoryIndex >= structureHistory.length - 1) return;
  
  structureHistoryIndex++;
  restoreStructureState(structureHistory[structureHistoryIndex]);
}

function restoreStructureState(state) {
  if(!state) return;
  
  // Restore bumpers
  bumpers = state.bumpers.map(b => ({...b}));
  nextBumperId = state.nextBumperId;
  
  // Clear selections
  selectedBumpers.clear();
  selectedBumper = null;
  
  // Redraw
  generateStructureLayout();
  updateWeightDisplay();
  updateStructureUndoRedoButtons();
  updateStructureSelectionInfo();
}

function updateStructureUndoRedoButtons() {
  const undoBtn = document.getElementById('structureUndoBtn');
  const redoBtn = document.getElementById('structureRedoBtn');
  
  if(undoBtn) {
    undoBtn.disabled = structureHistoryIndex <= 0;
  }
  if(redoBtn) {
    redoBtn.disabled = structureHistoryIndex >= structureHistory.length - 1;
  }
}

// Bumper manipulation functions
function replaceBumperType(bumperId, newType) {
  const bumper = bumpers.find(b => b.id === bumperId);
  if(!bumper) return;
  
  saveStructureState(); // Save before change
  bumper.type = newType;
  generateStructureLayout();
  updateWeightDisplay();
  calculate();
}

function deleteBumper(bumperId) {
  saveStructureState(); // Save before change
  bumpers = bumpers.filter(b => b.id !== bumperId);
  selectedBumpers.delete(bumperId);
  generateStructureLayout();
  updateWeightDisplay();
  calculate();
}

function startMovingBumper(bumperId) {
  const bumper = bumpers.find(b => b.id === bumperId);
  if(!bumper) return;
  
  selectedBumper = bumper;
  // Visual feedback will be added in the draw function
  generateStructureLayout();
}

function addBumperAtColumn(position, type, column) {
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  if(column < 0 || column >= pw) return;
  
  let endCol = column;
  if(type === '2w' || type === '4w') {
    endCol = column + 1;
    // Make sure we don't exceed panel width
    if(endCol >= pw) {
      endCol = pw - 1;
    }
  }
  
  // Check if bumper already exists at this position
  const exists = bumpers.some(b => 
    b.position === position && 
    b.type === type && 
    b.startCol === column
  );
  
  if(!exists) {
    saveStructureState(); // Save before change
    bumpers.push({
      id: nextBumperId++,
      type: type,
      position: position,
      startCol: column,
      endCol: endCol
    });
    
    generateStructureLayout();
    updateWeightDisplay();
    calculate();
  }
}

// Show empty area context menu for adding bumpers
function showEmptyAreaContextMenu(position, column, x, y) {
  hideContextMenu();
  
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  
  const menu = document.createElement('div');
  menu.id = 'bumperContextMenu';
  menu.style.cssText = `
    position: fixed;
    left: ${x}px;
    top: ${y}px;
    background: #2a2a2a;
    border: 1px solid #555;
    border-radius: 6px;
    padding: 4px 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    z-index: 10000;
    min-width: 180px;
    font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
  `;
  
  const options = [
    {
      label: `Add 2W Bumper at Columns ${column + 1}-${column + 2}`,
      action: () => addBumperAtColumn(position, '2w', column)
    },
    {
      label: `Add 1W Bumper at Column ${column + 1}`,
      action: () => addBumperAtColumn(position, '1w', column)
    }
  ];
  
  // Add 4W option for CB5 panels
  if(isCB5 && column + 1 < pw) {
    options.push({
      label: `Add 4W Bumper at Columns ${column + 1}-${column + 2}`,
      action: () => addBumperAtColumn(position, '4w', column)
    });
  }
  
  options.forEach(opt => {
    const item = document.createElement('div');
    item.textContent = opt.label;
    item.style.cssText = `
      padding: 8px 16px;
      cursor: pointer;
      color: #e0e0e0;
      font-size: 13px;
    `;
    
    item.addEventListener('mouseenter', function() {
      this.style.background = '#3a3a3a';
    });
    
    item.addEventListener('mouseleave', function() {
      this.style.background = 'transparent';
    });
    
    item.addEventListener('click', function(e) {
      e.stopPropagation();
      opt.action();
      hideContextMenu();
    });
    
    menu.appendChild(item);
  });
  
  document.body.appendChild(menu);
  contextMenuVisible = true;
  
  // Adjust if off-screen
  const menuRect = menu.getBoundingClientRect();
  if(menuRect.right > window.innerWidth) {
    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
  }
  if(menuRect.bottom > window.innerHeight) {
    menu.style.top = (window.innerHeight - menuRect.height - 10) + 'px';
  }
}

// ==================== END BUMPER MANAGEMENT SYSTEM ====================

function syncFromPanels(){
  const allPanels = getAllPanels();
  const p=allPanels[document.getElementById('panelType').value];
  if(!p) return;
  const units = displayLengthUnit; // Use global unit setting
  const pwInput = document.getElementById('panelsWide').value;
  const phInput = document.getElementById('panelsHigh').value;
  const wallWidthEl = document.getElementById('wallWidth');
  const wallHeightEl = document.getElementById('wallHeight');
  
  // If either panel value is empty, clear the corresponding wall dimension
  if(!pwInput && wallWidthEl) {
    wallWidthEl.value = '';
  }
  if(!phInput && wallHeightEl) {
    wallHeightEl.value = '';
  }
  
  // Only sync if both panel values are actually entered
  if(!pwInput || !phInput) return;
  
  const pw=Math.max(1,parseInt(pwInput)||1);
  const ph=Math.max(1,parseInt(phInput)||1);
  if(!p.width_m || !p.height_m){ return; }
  const wM=pw*p.width_m, hM=ph*p.height_m;
  if(wallWidthEl) wallWidthEl.value = fromMeters(wM, units).toFixed(2);
  if(wallHeightEl) wallHeightEl.value = fromMeters(hM, units).toFixed(2);
}

function syncFromSize(){
  const allPanels = getAllPanels();
  const p=allPanels[document.getElementById('panelType').value];
  if(!p) return;
  const units = displayLengthUnit; // Use global unit setting
  const wallWidthEl = document.getElementById('wallWidth');
  const wallHeightEl = document.getElementById('wallHeight');
  const wInput = wallWidthEl ? wallWidthEl.value : '';
  const hInput = wallHeightEl ? wallHeightEl.value : '';
  const panelsWideEl = document.getElementById('panelsWide');
  const panelsHighEl = document.getElementById('panelsHigh');
  
  // If either wall dimension is empty, clear the corresponding panel count
  if(!wInput && panelsWideEl) {
    panelsWideEl.value = '';
  }
  if(!hInput && panelsHighEl) {
    panelsHighEl.value = '';
  }
  
  // Only sync if both wall dimensions are actually entered
  if(!wInput || !hInput) return;
  
  const w = parseFloat(wInput);
  const h = parseFloat(hInput);
  if(!p.width_m || !p.height_m || w <= 0 || h <= 0){ return; }
  const wM = toMeters(w, units);
  const hM = toMeters(h, units);
  const pw = Math.max(1, Math.round(wM / p.width_m));
  const ph = Math.max(1, Math.round(hM / p.height_m));
  if(panelsWideEl) panelsWideEl.value = pw;
  if(panelsHighEl) panelsHighEl.value = ph;
}

function getEffectivePanelCounts(){
  const allPanels = getAllPanels();
  const p=allPanels[document.getElementById('panelType').value];
  if(!p) return {pw:0, ph:0, entered:{wM:0,hM:0}, snapped:{wM:0,hM:0}};
  const units = displayLengthUnit; // Use global unit setting
  const wallWidthEl = document.getElementById('wallWidth');
  const wallHeightEl = document.getElementById('wallHeight');
  const w = wallWidthEl ? (parseFloat(wallWidthEl.value)||0) : 0;
  const h = wallHeightEl ? (parseFloat(wallHeightEl.value)||0) : 0;
  if(w>0 && h>0 && p.width_m && p.height_m){
    const wM=toMeters(w, units), hM=toMeters(h, units);
    const pw=Math.max(1, Math.round(wM / p.width_m));
    const ph=Math.max(1, Math.round(hM / p.height_m));
    return {pw, ph, entered:{w, h, units}, snapped:{wM:pw*p.width_m, hM:ph*p.height_m}};
  }else{
    const pw=Math.max(1,parseInt(document.getElementById('panelsWide').value)||1);
    const ph=Math.max(1,parseInt(document.getElementById('panelsHigh').value)||1);
    return {pw, ph, entered:null, snapped:{wM:p.width_m?pw*p.width_m:0, hM:p.height_m?ph*p.height_m:0}};
  }
}

function calculateActualDataLines(pw, ph, panelsPerDataLine, startDir) {
  // Collect all custom data line numbers in use first
  const usedCustomDataLines = new Set();
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++) {
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey) && customDataLineAssignments.has(panelKey)) {
        usedCustomDataLines.add(customDataLineAssignments.get(panelKey) - 1);
      }
    }
  }
  
  // Build panel assignments based on start direction
  let maxDataLine = -1;
  
  if(startDir === 'all_top') {
    // Each column is its own data line
    let autoDataLineCounter = 0;
    for(let c=0; c<pw; c++){
      while(usedCustomDataLines.has(autoDataLineCounter)) {
        autoDataLineCounter++;
      }
      
      for(let r=0; r<ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          const dataLine = customDataLineAssignments.has(panelKey) 
            ? customDataLineAssignments.get(panelKey) - 1
            : autoDataLineCounter;
          if(dataLine > maxDataLine) maxDataLine = dataLine;
        }
      }
      autoDataLineCounter++;
    }
  } else if(startDir === 'all_bottom') {
    // Each column is its own data line
    let autoDataLineCounter = 0;
    for(let c=0; c<pw; c++){
      while(usedCustomDataLines.has(autoDataLineCounter)) {
        autoDataLineCounter++;
      }
      
      for(let r=ph-1; r>=0; r--) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          const dataLine = customDataLineAssignments.has(panelKey) 
            ? customDataLineAssignments.get(panelKey) - 1
            : autoDataLineCounter;
          if(dataLine > maxDataLine) maxDataLine = dataLine;
        }
      }
      autoDataLineCounter++;
    }
  } else {
    // Serpentine: top or bottom
    // Use per-panel counting to match generateLayout visualization
    const startFromTop = (startDir === 'top');
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;
    
    // Skip initial custom data lines
    while(usedCustomDataLines.has(autoDataLineCounter)) {
      autoDataLineCounter++;
    }
    
    // Build serpentine path
    let currentColumn = 0;
    let serpentineGoingDown = startFromTop;
    
    while(currentColumn < pw) {
      // Process panels in this column in serpentine order
      const rows = serpentineGoingDown 
        ? Array.from({length: ph}, (_, i) => i) 
        : Array.from({length: ph}, (_, i) => ph - 1 - i);
      
      for(const r of rows) {
        const panelKey = `${currentColumn},${r}`;
        if(deletedPanels.has(panelKey)) continue;
        
        let dataLine;
        if(customDataLineAssignments.has(panelKey)) {
          dataLine = customDataLineAssignments.get(panelKey) - 1;
        } else {
          // Find next available data line number (skip over custom assignments)
          while(usedCustomDataLines.has(autoDataLineCounter)) {
            autoDataLineCounter++;
          }
          
          dataLine = autoDataLineCounter;
          panelsInCurrentAutoDataLine++;
          
          // Move to next data line when we reach the limit
          if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
            autoDataLineCounter++;
            panelsInCurrentAutoDataLine = 0;
            
            // Skip over any custom data lines
            while(usedCustomDataLines.has(autoDataLineCounter)) {
              autoDataLineCounter++;
            }
          }
        }
        
        if(dataLine > maxDataLine) maxDataLine = dataLine;
      }
      
      // Move to next column and toggle direction
      currentColumn++;
      serpentineGoingDown = !serpentineGoingDown;
    }
  }
  
  // Return total number of data lines
  return maxDataLine + 1;
}

// ==================== CONNECTING PLATES FUNCTIONS ====================

function getPanelWeight(panelType, useConnectingPlates) {
  // Get base panel weight
  const allPanels = getAllPanels();
  const p = allPanels[panelType];
  if (!p) return 0;
  
  // If using connecting plates, CB5 panels don't have air frames
  if (useConnectingPlates) {
    if (panelType === 'CB5_MKII') {
      // Full CB5 panel WITHOUT air frame is 26.74 lbs = 12.13 kg
      return 12.13;
    } else if (panelType === 'CB5_MKII_HALF') {
      // Half CB5 panel WITHOUT air frame is 14.75 lbs = 6.69 kg
      return 6.69;
    }
  }
  
  // Return standard weight with air frame
  return p.weight_kg || 0;
}

function shouldUseConnectingPlates(panelType) {
  // DM2.6 always uses connecting plates
  if (panelType === 'DM2_6') {
    return true;
  }
  
  // CB5 MKII and CB5 MKII HALF can choose
  if (panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF') {
    return connectionMethod === 'plates';
  }
  
  return false;
}

function calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg) {
  // For perimeter-only 2-way plates and interior + bumper 4-way plates:
  
  // 2-way plates (yellow) on perimeter:
  // - Left edge: (ph-1) plates between vertically adjacent panels
  // - Right edge: (ph-1) plates between vertically adjacent panels
  // - Top/Bottom edge: (pw-1) plates between horizontally adjacent panels
  // - 2 plates at top-left and top-right where panels meet bumpers (or bottom if ground stacking)
  // Note: Corner plates are part of the edge counts, not separate
  const perimeterVertical = 2 * (ph - 1); // Left + Right edges
  const perimeterHorizontal = (pw - 1); // Top or Bottom edge
  const bumperEdgePlates = 2; // Vertical plates at left/right where they meet bumpers
  const total2way = perimeterVertical + perimeterHorizontal + bumperEdgePlates;
  
  // 4-way plates (red):
  // - Interior intersections: (pw-1) × (ph-1)
  // - Bumper-to-panel connections: (pw-1) plates at top or bottom row
  const interior4way = (pw - 1) * (ph - 1);
  const bumper4way = (pw - 1);
  const total4way = interior4way + bumper4way;
  
  // Calculate weights
  const weight2way = total2way * plate2wayKg;
  const weight4way = total4way * plate4wayKg;
  const totalPlateWeight = weight2way + weight4way;
  
  return {
    perimeterVertical,
    perimeterHorizontal,
    bumperEdgePlates,
    total2way,
    interior4way,
    bumper4way,
    total4way,
    weight2way,
    weight4way,
    totalPlateWeight
  };
}

function updatePlatesDisplay(useConnectingPlates, pw, ph, plate2wayKg, plate4wayKg) {
  // This function now just triggers the structure panel update
  // The actual display is handled by updateStructurePlatesDisplay()
  // which is called from updatePickupWeightSummary()
  
  // If structure view is visible, it will update automatically
  // Just call the structure plates display update
  updateStructurePlatesDisplay();
}

function updateConnectingPlatesVisibility(panelType) {
  const platesSection = document.getElementById('connectingPlatesSection');
  const cb5Choice = document.getElementById('cb5ConnectionChoice');
  const dm26Info = document.getElementById('dm26ConnectionInfo');
  
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const isDM26 = panelType === 'DM2_6';
  
  if (isCB5 || isDM26) {
    platesSection.style.display = 'block';
    
    if (isCB5) {
      // CB5 can choose between air frame and connecting plates
      cb5Choice.style.display = 'block';
      dm26Info.style.display = 'none';
    } else if (isDM26) {
      // DM2.6 always uses plates (no choice)
      cb5Choice.style.display = 'none';
      dm26Info.style.display = 'block';
      
      // Force plates selection for DM2.6
      const platesRadio = document.querySelector('input[name="connectionMethod"][value="plates"]');
      if (platesRadio) platesRadio.checked = true;
    }
  } else {
    platesSection.style.display = 'none';
  }
}

function resetCalculator() {
  // Clear the current screen's stored data so it doesn't get restored
  if(typeof screens !== 'undefined' && typeof currentScreenId !== 'undefined' && screens[currentScreenId]) {
    // Reset the screen data to defaults
    screens[currentScreenId].data = {
      panelsWide: '',
      panelsHigh: '',
      wallWidth: '',
      wallHeight: '',
      units: 'ft',
      dimensionMode: 'panels',
      panelType: document.getElementById('panelType').value, // Keep the newly selected panel type
      voltage: 208,
      breaker: 20,
      phase: '3',
      derate: false,
      powerType: 'max',
      maxPanelsPerCircuit: '',
      processor: 'Brompton_SX40',
      frameRate: 60,
      bitDepth: 8,
      maxPanelsPerData: '',
      dataStartDir: 'top',
      showArrows: true,
      redundancy: true,
      processorRedundancy: false,
      structureType: 'hanging',
      useBumpers: true,
      use4WayBumpers: false,
      deletedPanels: new Set(),
      bumpers: [],
      canvasX: 0,
      canvasY: 0,
      addCB5HalfRow: false,
      wallToFloor: 5,
      distroToWall: 10,
      processorToWall: 15,
      serverToProcessor: 50,
      cablePick: 0,
      cableDropPosition: 'behind',
      distBoxOnWall: false
    };
  }

  // Reset input fields to default values
  document.getElementById('panelsWide').value = '';
  document.getElementById('panelsHigh').value = '';
  document.getElementById('wallWidth').value = '';
  document.getElementById('wallHeight').value = '';
  
  // Reset units to defaults (Imperial)
  displayLengthUnit = 'ft';
  displayWeightUnit = 'lbs';
  document.getElementById('unitImperial')?.classList.add('active');
  document.getElementById('unitMetric')?.classList.remove('active');
  
  // Reset toggle states
  cb5HalfRowEnabled = false;
  document.getElementById('addCB5HalfRowBtn')?.classList.remove('active');
  
  use4WayBumpersEnabled = false;
  document.getElementById('use4WayBumpersBtn')?.classList.remove('active');
  
  redundancyEnabled = true;
  document.getElementById('redundancyBtn')?.classList.add('active');
  
  showArrowsEnabled = true;
  document.getElementById('showArrowsBtn')?.classList.add('active');
  
  snapModeEnabled = true;
  document.getElementById('snapModeBtn')?.classList.add('active');
  
  // Reset connection method to air frames (default)
  connectionMethod = 'airframe';
  document.getElementById('connectionAirframeBtn')?.classList.add('active');
  document.getElementById('connectionPlatesBtn')?.classList.remove('active');
  
  // Reset dimension mode
  currentDimensionMode = 'panels';
  document.getElementById('dimModePanelsBtn')?.classList.add('active');
  document.getElementById('dimModeSizeBtn')?.classList.remove('active');
  
  // Reset bumper distribution to auto
  const bumperDist = document.getElementById('bumperDistribution');
  if(bumperDist) bumperDist.value = 'auto';
  
  // Reset structure type to hanging
  const structureType = document.getElementById('structureType');
  if(structureType) structureType.value = 'hanging';
  
  // Reset max panels per data line
  document.getElementById('maxPanelsPerData').value = '';
  
  // Reset max panels per circuit
  document.getElementById('maxPanelsPerCircuit').value = '';
  
  // Reset cabling fields
  distBoxOnWallEnabled = false;
  document.getElementById('distBoxOnWallBtn')?.classList.remove('active');
  cableDropPosition = 'behind';
  document.getElementById('cableDropBehindBtn')?.classList.add('active');
  document.getElementById('cableDropSRBtn')?.classList.remove('active');
  document.getElementById('cableDropSLBtn')?.classList.remove('active');
  const wallToFloorEl = document.getElementById('wallToFloor');
  if(wallToFloorEl) wallToFloorEl.value = '';
  const distroToWallEl = document.getElementById('distroToWall');
  if(distroToWallEl) distroToWallEl.value = '';
  const processorToWallEl = document.getElementById('processorToWall');
  if(processorToWallEl) processorToWallEl.value = '';
  const serverToProcessorEl = document.getElementById('serverToProcessor');
  if(serverToProcessorEl) serverToProcessorEl.value = '';
  const cablePickEl = document.getElementById('cablePick');
  if(cablePickEl) cablePickEl.value = '';

  // Clear deleted panels
  deletedPanels.clear();
  
  // Clear selected panels (standard layout view)
  selectedPanels.clear();
  
  // Clear custom circuit assignments
  customCircuitAssignments.clear();
  
  // Clear custom data line assignments
  customDataLineAssignments.clear();
  
  // Reset bumpers
  bumpers = [];
  nextBumperId = 1;
  selectedBumper = null;
  hoveredBumper = null;
  
  // Reset global bumper visibility flags
  showTopBumper = true;
  showBottomBumper = false;
  
  // Reset manual bumper mode
  manualBumperMode = false;
  selectedBumpers.clear();
  structureIsDragging = false;
  structureDraggingBumper = null;
  
  // Reset structure view undo/redo
  structureHistory = [];
  structureHistoryIndex = -1;
  
  // Update manual mode UI
  const toggleBtn = document.getElementById('manualBumperToggle');
  const hintSpan = document.getElementById('structureModeHint');
  const selectionInfo = document.getElementById('structureSelectionInfo');
  const undoRedoDiv = document.getElementById('structureUndoRedo');
  if(toggleBtn) {
    toggleBtn.classList.remove('active');
    toggleBtn.textContent = 'Manually Distribute Bumpers';
  }
  if(hintSpan) hintSpan.textContent = 'Auto-distribution active';
  if(selectionInfo) selectionInfo.classList.remove('visible');
  if(undoRedoDiv) undoRedoDiv.style.display = 'none';
  
  // Reset canvas event listener flag so it can be re-attached
  const structCanvas = document.getElementById('structureCanvas');
  if(structCanvas) structCanvas._structureListenersAttached = false;
  
  // Reset legacy bumper variables
  topBumper1wColumn = -1;
  bottomBumper1wColumn = -1;
  manualTopBumpers = [];
  manualBottomBumpers = [];
  
  // Clear undo/redo stacks
  undoStack = [];
  redoStack = [];
  canvasUndoStack = [];
  canvasRedoStack = [];
  undoHistory = [];
  redoHistory = [];
  
  // Reset canvas view state
  canvasOffsetX = 0;
  canvasOffsetY = 0;
  canvasZoomLevel = 1.0;
  canvasPanX = 0;
  canvasPanY = 0;
  
  // Reset context menu state
  contextMenuVisible = false;
  hideContextMenu();
  
  // Reset results display
  document.getElementById('results').innerText = '';
  
  // Hide all layout containers (except canvasContainer if we're on canvas page)
  const layoutContainers = ['standardContainer', 'structureContainer', 'powerContainer', 'dataContainer', 'gearListContainer'];
  if(typeof currentMobileView === 'undefined' || currentMobileView !== 'canvas') {
    layoutContainers.push('canvasContainer');
  }
  layoutContainers.forEach(containerId => {
    const container = document.getElementById(containerId);
    if(container) {
      container.style.display = 'none';
    }
  });

  // Clear all canvas drawings
  const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
  canvases.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Also reset canvas dimensions
      canvas.width = 0;
      canvas.height = 0;
    }
  });
  
  // Hide pickup weight summary
  const pickupSummary = document.getElementById('pickupWeightSummary');
  if(pickupSummary) pickupSummary.style.display = 'none';
  
  // Update visibility of CB5-specific options
  updateCB5HalfPanelVisibility();
  
  // Update 4-way bumper visibility
  const fourWayOption = document.getElementById('fourWayBumperOption');
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  if(fourWayOption) {
    fourWayOption.style.display = isCB5 ? 'block' : 'none';
  }
  
  // Update connecting plates visibility
  updateConnectingPlatesVisibility(panelType);
  
  // Force immediate DOM update by reading a layout property
  document.body.offsetHeight;
  
  // Hide all layout containers AND clear their visibility with repaint (except canvasContainer if we're on canvas page)
  const layoutContainersToHide = ['standardContainer', 'structureContainer', 'powerContainer', 'dataContainer', 'gearListContainer'];
  if(typeof currentMobileView === 'undefined' || currentMobileView !== 'canvas') {
    layoutContainersToHide.push('canvasContainer');
  }
  layoutContainersToHide.forEach(containerId => {
    const container = document.getElementById(containerId);
    if(container) {
      container.style.display = 'none';
      // Force repaint by toggling a class
      container.classList.add('reset-hidden');
      void container.offsetWidth; // Force reflow
    }
  });
  
  // Clear all canvases
  const canvasesToClear = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
  canvasesToClear.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvas.width = 0;
      canvas.height = 0;
    }
  });
  
  // Show ready message - use setTimeout to ensure it runs after all other event handlers
  setTimeout(() => {
    document.getElementById('results').innerHTML = '<div style="padding: 40px; text-align: center; color: #888;">' +
      '<h3 style="color: #10b981; margin-bottom: 10px;">Ready to Configure</h3>' +
      '<p>Enter panel dimensions above to begin calculating your LED wall.</p>' +
      '</div>';
  }, 50);
}

function calculate(){
  console.log('=== calculate() called ===');
  console.log('Current screen:', currentScreenId);
  
  showSpecWarningIfNeeded();
  
  // Check if this is an empty/new screen (no dimensions entered)
  const panelsWideInput = document.getElementById('panelsWide');
  const panelsHighInput = document.getElementById('panelsHigh');
  const wallWidthInput = document.getElementById('wallWidth');
  const wallHeightInput = document.getElementById('wallHeight');
  
  const panelsWideVal = panelsWideInput ? panelsWideInput.value.trim() : '';
  const panelsHighVal = panelsHighInput ? panelsHighInput.value.trim() : '';
  const wallWidthVal = wallWidthInput ? wallWidthInput.value.trim() : '';
  const wallHeightVal = wallHeightInput ? wallHeightInput.value.trim() : '';
  
  // If all dimension fields are empty, show a helpful message
  if(!panelsWideVal && !panelsHighVal && !wallWidthVal && !wallHeightVal) {
    document.getElementById('results').innerHTML = '<div style="padding: 40px; text-align: center; color: #888;">' +
      '<h3 style="color: #10b981; margin-bottom: 10px;">Ready to Configure</h3>' +
      '<p>Enter panel dimensions above to begin calculating your LED wall.</p>' +
      '</div>';
    
    // Hide all layout containers (except canvasContainer if we're on canvas page)
    const layoutContainers = ['standardContainer', 'structureContainer', 'powerContainer', 'dataContainer', 'gearListContainer'];
    if(typeof currentMobileView === 'undefined' || currentMobileView !== 'canvas') {
      layoutContainers.push('canvasContainer');
    }
    layoutContainers.forEach(containerId => {
      const container = document.getElementById(containerId);
      if(container) {
        container.style.display = 'none';
      }
    });

    // Clear all canvases for empty screen
    const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
    canvases.forEach(canvasId => {
      const canvas = document.getElementById(canvasId);
      if(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    });
    return;
  }
  
  const allPanels = getAllPanels();
  const allProcessors = getAllProcessors();
  const panelType = document.getElementById('panelType').value;
  const p=allPanels[panelType];
  const pr=allProcessors[document.getElementById('processor').value];
  if(!p.width_m || !p.height_m || !p.res_x || !p.res_y || !p.power_max_w){
    document.getElementById('results').innerText = "Please confirm specs for this model (dimensions, resolution, power, etc.) before running calculations.";
    return;
  }
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && panelType === 'CB5_MKII';
  
  const powerType = document.getElementById('powerType').value;
  const voltage = parseFloat(document.getElementById('voltage').value)||220;
  const breaker = parseFloat(document.getElementById('breaker').value)||20;
  const phase = parseInt(document.getElementById('phase').value)||3;
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const {pw, ph, entered, snapped} = getEffectivePanelCounts();
  const units = displayLengthUnit; // Use global unit setting

  const wallWM = snapped.wM, wallHM = snapped.hM;
  const wallWF = wallWM? (wallWM/0.3048) : 0;
  const wallHF = wallHM? (wallHM/0.3048) : 0;

  const totalPanelsGrid = pw*ph;
  const activePanelsCount = totalPanelsGrid - deletedPanels.size;
  
  // Calculate mixed panel counts if CB5 half row is enabled
  let totalPanels, totalPixels, totalWeight, totalPowerW, resX, resY, adjustedWallHM, adjustedWallHF;
  
  if(hasCB5HalfRow) {
    // Get half panel specs
    const halfPanel = panels['CB5_MKII_HALF'];

    // Main panels are all full CB5 panels (pw * ph)
    const mainPanelCount = activePanelsCount; // All full panels
    const halfPanelCount = pw; // Additional half panel row at bottom

    // Calculate totals combining both panel types
    totalPanels = mainPanelCount + halfPanelCount;
    totalPixels = (mainPanelCount * (p.res_x * p.res_y)) + (halfPanelCount * (halfPanel.res_x * halfPanel.res_y));
    
    // Calculate panel weight and add bumper weight
    // Get correct panel weights based on connection method
    const useConnectingPlates = shouldUseConnectingPlates(panelType);
    const mainPanelWeightKg = getPanelWeight('CB5_MKII', useConnectingPlates);
    const halfPanelWeightKg = getPanelWeight('CB5_MKII_HALF', useConnectingPlates);
    
    const panelWeight = (mainPanelCount * mainPanelWeightKg) + (halfPanelCount * halfPanelWeightKg);
    const bumperWeight = calculateTotalBumperWeight(pw, ph);
    
    // Calculate connecting plates weight if applicable
    let plateWeight = 0;
    
    if (useConnectingPlates) {
      // Connecting plate weights (constants)
      const plate2wayKg = 0.141; // 2-way plate weight (0.31 lbs)
      const plate4wayKg = 0.249; // 4-way plate weight (0.55 lbs)
      const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
      plateWeight = plates.totalPlateWeight;
      updatePlatesDisplay(true, pw, ph, plate2wayKg, plate4wayKg);
    } else {
      updatePlatesDisplay(false, 0, 0, 0, 0);
    }
    
    totalWeight = panelWeight + bumperWeight + plateWeight;
    
    const perPanelW = powerType==='max' ? p.power_max_w : (p.power_avg_w||p.power_max_w*0.5);
    const perHalfPanelW = powerType==='max' ? halfPanel.power_max_w : (halfPanel.power_avg_w||halfPanel.power_max_w*0.5);
    totalPowerW = (mainPanelCount * perPanelW) + (halfPanelCount * perHalfPanelW);
    
    // Resolution includes both types
    resX = pw * p.res_x; // Width stays same
    resY = (ph * p.res_y) + halfPanel.res_y; // All full rows + half row

    // Adjust wall height to include half panel row
    adjustedWallHM = wallHM + halfPanel.height_m;
    adjustedWallHF = adjustedWallHM / 0.3048;
  } else {
    // Standard calculation (no half panels)
    totalPanels = activePanelsCount;
    resX = pw*p.res_x;
    resY = ph*p.res_y;
    totalPixels = activePanelsCount * (p.res_x*p.res_y);
    
    // Calculate panel weight and add bumper weight
    const useConnectingPlates = shouldUseConnectingPlates(panelType);
    const panelWeightKg = getPanelWeight(panelType, useConnectingPlates);
    
    const panelWeight = totalPanels * panelWeightKg;
    const bumperWeight = calculateTotalBumperWeight(pw, ph);
    
    // Calculate connecting plates weight if applicable
    let plateWeight = 0;
    
    if (useConnectingPlates) {
      // Connecting plate weights (constants)
      const plate2wayKg = 0.141; // 2-way plate weight (0.31 lbs)
      const plate4wayKg = 0.249; // 4-way plate weight (0.55 lbs)
      const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
      plateWeight = plates.totalPlateWeight;
      updatePlatesDisplay(true, pw, ph, plate2wayKg, plate4wayKg);
    } else {
      updatePlatesDisplay(false, 0, 0, 0, 0);
    }
    
    totalWeight = panelWeight + bumperWeight + plateWeight;
    
    const perPanelW = powerType==='max' ? p.power_max_w : (p.power_avg_w||p.power_max_w*0.5);
    totalPowerW = totalPanels * perPanelW;
    adjustedWallHM = wallHM;
    adjustedWallHF = wallHF;
  }
  
  const totalWeightLbs = totalWeight * 2.20462;

  const circuitCapacityW = voltage*breaker*derate;
  const perPanelW = powerType==='max' ? p.power_max_w : (p.power_avg_w||p.power_max_w*0.5);
  
  // Always calculate based on power settings
  const calculatedPanelsPerCircuit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
  
  // Get user override or use calculated value
  const userMaxPanelsPerCircuit = parseInt(document.getElementById('maxPanelsPerCircuit').value);
  const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;
  
  // Update placeholder to show calculated value
  const maxPanelsPerCircuitInput = document.getElementById('maxPanelsPerCircuit');
  if(maxPanelsPerCircuitInput) {
    maxPanelsPerCircuitInput.placeholder = calculatedPanelsPerCircuit.toString();
  }
  
  const columnsPerCircuit = Math.max(1, Math.floor(panelsPerCircuit / ph));
  const circuitsByColumns = Math.ceil(pw / columnsPerCircuit);

  const ampsSingle = totalPowerW / voltage;
  // For 3-phase: Total Watts / Voltage = Total Amps, then Total Amps / 3 = Amps per phase
  const totalAmps = totalPowerW / voltage;
  const ampsPerPhase = phase===3 ? (totalAmps / 3) : ampsSingle;

  const pixelsPerPanel = p.res_x*p.res_y;
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  // Using redundancyEnabled toggle state
  const redundancy = redundancyEnabled;
  const adjustedCapacity = calculateAdjustedPixelCapacity(pr, frameRate, bitDepth);
  
  // Calculate suggested panels per data line accounting for mixed panel types
  let capacityBasedPanelsPerData;
  if(hasCB5HalfRow) {
    // With half panels, we need to calculate based on average pixels per panel
    const halfPanel = panels['CB5_MKII_HALF'];
    const halfPanelPixels = halfPanel.res_x * halfPanel.res_y;
    const mainPanelCount = activePanelsCount; // All full panels
    const halfPanelCount = pw; // Additional half panel row
    const totalMixedPanels = mainPanelCount + halfPanelCount;
    const totalMixedPixels = (mainPanelCount * pixelsPerPanel) + (halfPanelCount * halfPanelPixels);
    const avgPixelsPerPanel = totalMixedPixels / totalMixedPanels;
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / avgPixelsPerPanel));
  } else {
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  }

  // Cap at 500 panels per port (Brompton Tessera hardware limit)
  const MAX_PANELS_PER_PORT = 500;
  capacityBasedPanelsPerData = Math.min(capacityBasedPanelsPerData, MAX_PANELS_PER_PORT);

  // Use the panel-specific limit if available, otherwise use capacity-based calculation
  // The auto value is the MINIMUM of capacity-based calculation and panel-specific limit
  // Apply panel's max_panels_per_data limit even when mixing with half panels
  const panelSpecificDataLimit = p.max_panels_per_data || null;
  const suggestedPanelsPerData = panelSpecificDataLimit
    ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
    : capacityBasedPanelsPerData;
  
  const userMax = parseInt(document.getElementById('maxPanelsPerData').value);
  const panelsPerDataLine = userMax>0 ? userMax : suggestedPanelsPerData;
  
  // Get data start direction
  const startDirEl = document.getElementById('dataStartDir');
  const startDir = startDirEl ? startDirEl.value : 'top';
  
  // Calculate actual data lines used (including custom assignments)
  // Use adjusted ph if CB5 half row is enabled
  const adjustedPh = hasCB5HalfRow ? ph + 1 : ph;
  const actualDataLines = calculateActualDataLines(pw, adjustedPh, panelsPerDataLine, startDir);
  const dataLines = actualDataLines;
  const portsNeeded = dataLines; // Each data line needs one port
  
  const redundancyMultiplier = redundancy ? 2 : 1;
  const portsNeededFinal = portsNeeded * redundancyMultiplier;
  const dataLinesFinal = dataLines * redundancyMultiplier;

  const ar = (wallWM&&wallHM) ? approxAspectRatio(wallWM, wallHM) : {label:"N/A", value:0};

  // Calculate weight breakdown
  const bumperWeight = calculateTotalBumperWeight(pw, ph);

  // Calculate actual panel weight (not derived from totalWeight which includes plates)
  const useConnectingPlatesForWeight = shouldUseConnectingPlates(panelType);
  let panelWeightOnly = 0;
  if(hasCB5HalfRow) {
    const mainPanelWeightKg = getPanelWeight('CB5_MKII', useConnectingPlatesForWeight);
    const halfPanelWeightKg = getPanelWeight('CB5_MKII_HALF', useConnectingPlatesForWeight);
    const mainPanelCount = activePanelsCount;
    const halfPanelCount = pw;
    panelWeightOnly = (mainPanelCount * mainPanelWeightKg) + (halfPanelCount * halfPanelWeightKg);
  } else {
    const panelWeightKg = getPanelWeight(panelType, useConnectingPlatesForWeight);
    panelWeightOnly = totalPanels * panelWeightKg;
  }
  
  // AUTOMATIC DISTRIBUTION CALCULATION
  const processorId = document.getElementById('processor').value;
  let distributionBoxName = '';
  let distributionCount = 0;
  let mx40ProcessorCount = 0;

  if(processorId === 'Brompton_SX40' && portsNeeded > 0) {
    // SX40 uses XD boxes: 10 ports per XD
    // Calculate XDs needed for main lines, then double if redundancy (separate XDs for backup)
    const baseDistributionCount = Math.ceil(portsNeeded / 10);
    distributionCount = redundancy ? baseDistributionCount * 2 : baseDistributionCount;
    distributionBoxName = 'Brompton XD';
  } else if(processorId === 'NovaStar_MX40_Pro' && portsNeeded > 0) {
    // MX40 Pro logic:
    // Direct mode: 20 ports per processor
    // Indirect mode: 10 ports per CVT box, 4 CVTs per processor max

    if(mx40ConnectionMode === 'direct') {
      // Direct mode: no CVT boxes, processor count based on ports AND pixels
      const portsPerProcessor = 20;
      const processorsByPorts = Math.ceil(portsNeededFinal / portsPerProcessor);
      const processorsByPixels = Math.ceil(totalPixels / 9000000);
      mx40ProcessorCount = Math.max(processorsByPorts, processorsByPixels);
    } else {
      // Indirect mode: CVT boxes needed
      const portsPerCVT = 10;
      distributionCount = Math.ceil(portsNeededFinal / portsPerCVT);
      distributionBoxName = 'NovaStar CVT-10 Pro';
      // Processor count: max of pixels needed OR CVT boxes needed (4 CVTs per processor)
      const processorsByPixels = Math.ceil(totalPixels / 9000000);
      const processorsByCVTs = Math.ceil(distributionCount / 4);
      mx40ProcessorCount = Math.max(processorsByPixels, processorsByCVTs);
    }
  } else if(pr.uses_distribution_box && pr.distribution_box_name && portsNeeded > 0) {
    // Custom processor with distribution box
    const portsPerBox = pr.distribution_box_ports || 10;
    distributionCount = Math.ceil(portsNeededFinal / portsPerBox);
    distributionBoxName = pr.distribution_box_name;
  }

  // Build HTML output matching the example format
  let html = '';

  // Add Specs header at the top of results (positioned to sit on the top border)
  html += `<div style="position: absolute; top: -16px; left: 16px; background: #222; border: 1px solid var(--primary); padding: 4px 10px; font-family: 'Bangers', cursive; font-size: 16px; letter-spacing: 1.5px; text-transform: uppercase; color: var(--primary); transform: rotate(-2deg);">Specs</div>`;

  // Get unit labels for display
  const lenUnit = getLengthUnitLabel();
  const wtUnit = getWeightUnitLabel();

  // Convert values based on selected units
  const panelWidthDisplay = displayLengthUnit === 'ft' ? (p.width_m * M_TO_FT).toFixed(3) : p.width_m.toFixed(3);
  const panelHeightDisplay = displayLengthUnit === 'ft' ? (p.height_m * M_TO_FT).toFixed(3) : p.height_m.toFixed(3);
  const wallWidthDisplay = displayLengthUnit === 'ft' ? wallWF.toFixed(2) : wallWM.toFixed(2);
  const wallHeightDisplay = displayLengthUnit === 'ft' ? adjustedWallHF.toFixed(2) : adjustedWallHM.toFixed(2);
  const perPanelWeightKg = getPanelWeight(panelType, useConnectingPlatesForWeight);
  const panelWeightDisplay = displayWeightUnit === 'lbs' ? (perPanelWeightKg * KG_TO_LBS).toFixed(2) : perPanelWeightKg.toFixed(2);
  const totalWeightDisplay = displayWeightUnit === 'lbs' ? totalWeightLbs.toFixed(2) : totalWeight.toFixed(2);
  const panelOnlyWeightDisplay = displayWeightUnit === 'lbs' ? (panelWeightOnly * KG_TO_LBS).toFixed(2) : panelWeightOnly.toFixed(2);
  const bumperWeightDisplay = displayWeightUnit === 'lbs' ? (bumperWeight * KG_TO_LBS).toFixed(2) : bumperWeight.toFixed(2);

  // Check if we're in simple mode
  const isSimpleMode = typeof currentAppMode !== 'undefined' && currentAppMode === 'simple';

  if(isSimpleMode) {
    // SIMPLE MODE - Condensed specs
    // Panel specs
    html += `<div class="result-section-title">PANEL</div>`;
    html += `<div class="result-row"><strong>Panel:</strong> ${p.brand} ${p.name}</div>`;
    html += `<div class="result-row"><strong>Pixel pitch:</strong> ${p.pixel_pitch_mm} mm</div>`;
    html += `<div class="result-row"><strong>Panel size:</strong> ${panelWidthDisplay} ${lenUnit} × ${panelHeightDisplay} ${lenUnit}</div>`;
    html += `<div class="result-row"><strong>Panel res:</strong> ${p.res_x} × ${p.res_y}</div>`;
    if(p.weight_kg) html += `<div class="result-row"><strong>Weight per panel:</strong> ${panelWeightDisplay} ${wtUnit}</div>`;

    // Wall specs
    html += `<br>`;
    html += `<div class="result-section-title">WALL</div>`;
    html += `<div class="result-row"><strong>Dimensions:</strong> ${wallWidthDisplay} ${lenUnit} × ${wallHeightDisplay} ${lenUnit} (${pw} × ${ph} panels)</div>`;
    html += `<div class="result-row"><strong>Panel count:</strong> ${totalPanels}</div>`;
    html += `<div class="result-row"><strong>Aspect ratio:</strong> ${ar.label}</div>`;
    html += `<div class="result-row"><strong>Wall weight:</strong> ${panelOnlyWeightDisplay} ${wtUnit}</div>`;
    html += `<div class="result-row"><strong>Pixel count:</strong> ${totalPixels.toLocaleString()} px</div>`;
    html += `<div class="result-row"><strong>Resolution:</strong> ${resX} × ${resY}</div>`;

    // Power specs
    html += `<br>`;
    html += `<div class="result-section-title">POWER (${powerType.toUpperCase()})</div>`;
    html += `<div class="result-row"><strong>Total watts:</strong> ${totalPowerW.toLocaleString()} W</div>`;
    html += `<div class="result-row"><strong>Total amps:</strong> ${ampsSingle.toFixed(2)} A @ ${voltage} V</div>`;
    if(phase === 3) html += `<div class="result-row"><strong>Amps per phase:</strong> ${ampsPerPhase.toFixed(2)} A</div>`;
    html += `<div class="result-row"><strong>Max panels per circuit:</strong> ${calculatedPanelsPerCircuit}</div>`;

    // Data specs
    html += `<br>`;
    html += `<div class="result-section-title">DATA</div>`;
    html += `<div class="result-row"><strong>Port capacity:</strong> ${adjustedCapacity.toLocaleString()} px</div>`;
    html += `<div class="result-row"><strong>Max panels per data line:</strong> ${suggestedPanelsPerData}</div>`;
  } else {
    // COMPLEX MODE - Full specs (original)
    // PANEL Section
    html += `<div class="result-row"><strong>Panel:</strong> ${p.brand} ${p.name}</div>`;
    html += `<div class="result-row"><strong>Pixel pitch:</strong> ${p.pixel_pitch_mm} mm</div>`;
    html += `<div class="result-row"><strong>Panel size:</strong> ${panelWidthDisplay} ${lenUnit} × ${panelHeightDisplay} ${lenUnit}</div>`;
    html += `<div class="result-row"><strong>Panel res:</strong> ${p.res_x} × ${p.res_y}</div>`;
    if(p.brightness_nits) html += `<div class="result-row"><strong>Brightness:</strong> ${p.brightness_nits} nits</div>`;
    if(p.weight_kg) html += `<div class="result-row"><strong>Weight per panel:</strong> ${panelWeightDisplay} ${wtUnit}</div>`;
    html += `<div class="result-row"><strong>Panel power (Max/Avg):</strong> ${p.power_max_w} W / ${p.power_avg_w} W</div>`;
    if(p.max_hanging !== null && p.max_hanging !== undefined) html += `<div class="result-row"><strong>Max hanging:</strong> ${p.max_hanging} Panels</div>`;
    if(p.max_stacking !== null && p.max_stacking !== undefined) html += `<div class="result-row"><strong>Max Stacking:</strong> ${p.max_stacking} Panels</div>`;
    if(p.bumper_1w_lbs !== null && p.bumper_1w_lbs !== undefined) {
      const b1w = displayWeightUnit === 'lbs' ? p.bumper_1w_lbs.toFixed(1) : (p.bumper_1w_lbs * LBS_TO_KG).toFixed(1);
      const b2w = displayWeightUnit === 'lbs' ? p.bumper_2w_lbs.toFixed(1) : (p.bumper_2w_lbs * LBS_TO_KG).toFixed(1);
      html += `<div class="result-row"><strong>Bumper Weights:</strong> 1W= ${b1w} ${wtUnit}, 2W= ${b2w} ${wtUnit}</div>`;
    }

    // WALL Section
    html += `<br><br>`;
    html += `<div class="result-section-title">WALL</div>`;
    html += `<div class="result-row"><strong>Dimensions:</strong> ${wallWidthDisplay} ${lenUnit} × ${wallHeightDisplay} ${lenUnit} (${pw} × ${ph} panels${hasCB5HalfRow ? ' + half row' : ''})</div>`;
    html += `<div class="result-row"><strong>Total panel count:</strong> ${totalPanels}</div>`;
    html += `<div class="result-row"><strong>Resolution:</strong> ${resX} × ${resY}</div>`;
    html += `<div class="result-row"><strong>Total pixel count:</strong> (${totalPixels.toLocaleString()} px)</div>`;
    html += `<div class="result-row"><strong>Aspect ratio:</strong> ${ar.label}</div>`;
    // Weight display with breakdown - Structure includes all structural components
    const currentStructureType = document.getElementById('structureType')?.value || 'hanging';

    // Calculate all structure weight components
    let structureWeightKg = 0;

    if(currentStructureType === 'floor' && p.is_floor_panel && p.floor_frames) {
      // Floor mode: Structure = Floor Frames
      const floorFramesArray = calculateFloorFrames(pw, ph, deletedPanels);
      const frameCounts = getFloorFrameCounts(floorFramesArray);
      if(frameCounts.frame_1x1 > 0) structureWeightKg += frameCounts.frame_1x1 * p.floor_frames.frame_1x1.weight_lbs / KG_TO_LBS;
      if(frameCounts.frame_2x1 > 0) structureWeightKg += frameCounts.frame_2x1 * p.floor_frames.frame_2x1.weight_lbs / KG_TO_LBS;
      if(frameCounts.frame_2x2 > 0) structureWeightKg += frameCounts.frame_2x2 * p.floor_frames.frame_2x2.weight_lbs / KG_TO_LBS;
      if(frameCounts.frame_3x2 > 0) structureWeightKg += frameCounts.frame_3x2 * p.floor_frames.frame_3x2.weight_lbs / KG_TO_LBS;
    } else {
      // Hanging or Ground Stack mode: Structure = Bumpers + Connecting Plates + Ground Support Hardware

      // Add bumper weight
      structureWeightKg += bumperWeight;

      // Add connecting plates weight if applicable
      const useConnectingPlatesForDisplay = shouldUseConnectingPlates(panelType);
      if(useConnectingPlatesForDisplay) {
        const plate2wayKg = 0.141;
        const plate4wayKg = 0.249;
        // Account for half panel row if CB5 with half row enabled
        const effectivePhForPlates = hasCB5HalfRow ? ph + 1 : ph;
        const plates = calculateConnectingPlates(pw, effectivePhForPlates, plate2wayKg, plate4wayKg);
        structureWeightKg += plates.totalPlateWeight;
      }

      // Add ground support hardware weight for ground stack mode
      if(currentStructureType === 'ground') {
        const groundHardware = calculateGroundSupportHardware(pw, ph);
        if(groundHardware && groundHardware.totalWeightKg) {
          structureWeightKg += groundHardware.totalWeightKg;
        }
      }
    }

    const adjustedTotalWeightKg = panelWeightOnly + structureWeightKg;
    const adjustedTotalWeightDisplay = displayWeightUnit === 'lbs' ? (adjustedTotalWeightKg * KG_TO_LBS).toFixed(2) : adjustedTotalWeightKg.toFixed(2);
    const structureWeightDisplay = displayWeightUnit === 'lbs' ? (structureWeightKg * KG_TO_LBS).toFixed(2) : structureWeightKg.toFixed(2);

    html += `<div class="result-row"><strong>Total weight:</strong> ${adjustedTotalWeightDisplay} ${wtUnit}</div>`;
    // Show weight breakdown if there's any structure weight
    const isFloorPanel = p.is_floor_panel === true;
    if(structureWeightKg > 0 || (currentStructureType === 'floor' && isFloorPanel)) {
      html += `<div class="result-row result-indent"><strong>Panels:</strong> ${panelOnlyWeightDisplay} ${wtUnit}</div>`;
      html += `<div class="result-row result-indent"><strong>Structure:</strong> ${structureWeightDisplay} ${wtUnit}</div>`;
    }

    // POWER Section
    html += `<br>`;
    html += `<div class="result-section-title">POWER (${powerType.toUpperCase()})</div>`;
    html += `<div class="result-row"><strong>Total wall power:</strong> ${totalPowerW.toLocaleString()} W</div>`;
    html += `<div class="result-row"><strong>Total amps:</strong> ${ampsSingle.toFixed(2)} A @ ${voltage} V</div>`;
    if(phase === 3) html += `<div class="result-row"><strong>Total amps per phase:</strong> ${ampsPerPhase.toFixed(2)} A @ ${voltage} V</div>`;
    html += `<div class="result-row"><strong>Max panels per circuit:</strong> ${calculatedPanelsPerCircuit}</div>`;
    html += `<div class="result-row"><strong>Estimated circuits:</strong> ${circuitsByColumns}</div>`;

    // DATA Section
    html += `<br>`;
    html += `<div class="result-section-title">DATA</div>`;
    let processorDisplayName = pr.name;
    if(pr.in_development) {
      processorDisplayName = processorDisplayName.replace('(in development)', '<span style="color: #d47a7a;">(in development)</span>');
    }
    html += `<div class="result-row"><strong>Processor:</strong> ${processorDisplayName}</div>`;
    if(distributionBoxName) {
      html += `<div class="result-row"><strong>Distribution box:</strong> ${distributionBoxName}${distributionCount > 0 ? ` (${distributionCount})` : ''}</div>`;
    }
    html += `<div class="result-row"><strong>Port Capacity:</strong> ${adjustedCapacity.toLocaleString()} px</div>`;
    html += `<div class="result-row"><strong>Max panels per data line:</strong> ${suggestedPanelsPerData}</div>`;
    html += `<div class="result-row"><strong>Estimated 1G ports needed:</strong> ${portsNeededFinal}</div>`;
    html += `<div class="result-row"><strong>Estimated data lines:</strong> ${dataLinesFinal}</div>`;
    html += `<div class="result-row"><strong>Frame Rate:</strong> ${frameRate} Hz</div>`;
    html += `<div class="result-row"><strong>Bit Depth:</strong> ${bitDepth}-bit</div>`;
    html += `<div class="result-row"><strong>Redundancy:</strong> ${redundancy ? 'Yes' : 'No'}</div>`;
  }

  document.getElementById('results').innerHTML = html;
  
  // Store calculated values for gear list to use
  if(screens[currentScreenId]) {
    screens[currentScreenId].calculatedData = {
      // Equipment
      processorName: pr.name,
      processorCount: 1,
      distributionBoxCount: distributionCount,
      distributionBoxName: distributionBoxName,
      mx40ProcessorCount: mx40ProcessorCount, // MX40-specific processor count (accounts for ports + pixels)
      panelCount: totalPanels,
      activePanels: totalPanels, // Same as totalPanels (deletedPanels already accounted for)

      // Weight (panel-only and bumper weight)
      panelWeightOnlyKg: panelWeightOnly,
      bumperWeightKg: bumperWeight,
      // Note: platesWeightKg is updated by updatePlatesDisplay()
      // Note: groundSupportWeightKg is updated by generateStructureLayout()

      // Rigging
      bumper1wCount: bumpers.filter(b => b.type === '1w').length,
      bumper2wCount: bumpers.filter(b => b.type === '2w').length,
      bumper4wCount: bumpers.filter(b => b.type === '4w').length,

      // Data
      dataLines: dataLines,
      portsNeeded: portsNeeded,
      portsNeededFinal: portsNeededFinal,
      panelsPerDataLine: panelsPerDataLine,
      totalPixels: totalPixels,

      // Power
      circuitsNeeded: circuitsByColumns,
      socaCount: Math.ceil(circuitsByColumns / 6),
      columnsPerCircuit: columnsPerCircuit
    };
  }
  
  generateLayout('standard');
  generateStructureLayout();
  generateLayout('power');
  generateLayout('data');
  showCanvasView();
  generateGearList();

  // If combined view is active, update it too
  if(currentAppMode === 'combined' && combinedSelectedScreens.size > 0) {
    renderCombinedView();
  }
}

function lightenColor(hex, percent) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  const newR = Math.min(255, Math.floor(r + (255 - r) * percent));
  const newG = Math.min(255, Math.floor(g + (255 - g) * percent));
  const newB = Math.min(255, Math.floor(b + (255 - b) * percent));
  return `#${newR.toString(16).padStart(2,'0')}${newG.toString(16).padStart(2,'0')}${newB.toString(16).padStart(2,'0')}`;
}

function hexToRgba(hex, alpha){
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function getContrastColor(hex){
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  const brightness=(r*299+g*587+b*114)/1000;
  return brightness<128?'#FFFFFF':'#000000';
}
function colorForIndex(i){
  let base=resistorColors[i%10];
  const cycle=Math.floor(i/10);
  const alpha=Math.max(0.4, 1 - cycle*0.2);
  // Use pastel colors for eco-friendly printing
  if (ecoPrintMode) {
    base = toPastelColor(base);
  }
  // Convert to greyscale for greyscale printing
  if (greyscalePrintMode) {
    base = toGreyscale(base);
    return { fill: base, text: '#000000', solid: base };
  }
  if (ecoPrintMode) {
    return { fill: base, text: '#000000', solid: base };
  }
  return { fill: hexToRgba(base, alpha), text: getContrastColor(base), solid: base };
}

// Make colors more vibrant for PDF export by increasing saturation and darkening slightly
function getVibrantColorForPDF(hexColor) {
  // Special case for white - use dark gray instead
  if(hexColor === '#FFFFFF') {
    return '#4A4A4A'; // Dark gray for white
  }
  
  // Special case for yellow - make it more saturated/darker
  if(hexColor === '#FFFF00') {
    return '#DAA520'; // Goldenrod instead of pure yellow
  }
  
  // For other colors, desaturate and lighten for ink-saving
  const r = parseInt(hexColor.slice(1,3), 16);
  const g = parseInt(hexColor.slice(3,5), 16);
  const b = parseInt(hexColor.slice(5,7), 16);
  
  // Convert to HSL for easier saturation adjustment
  const rNorm = r / 255;
  const gNorm = g / 255;
  const bNorm = b / 255;
  
  const max = Math.max(rNorm, gNorm, bNorm);
  const min = Math.min(rNorm, gNorm, bNorm);
  const l = (max + min) / 2;
  
  let h, s;
  if(max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch(max) {
      case rNorm: h = ((gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0)) / 6; break;
      case gNorm: h = ((bNorm - rNorm) / d + 2) / 6; break;
      case bNorm: h = ((rNorm - gNorm) / d + 4) / 6; break;
    }
  }
  
  // Desaturate by 50% and lighten slightly for ink-saving when printing
  s = s * 0.5;
  const newL = Math.min(0.85, l * 1.15); // Lighten slightly, max lightness of 0.85
  
  // Convert back to RGB
  function hue2rgb(p, q, t) {
    if(t < 0) t += 1;
    if(t > 1) t -= 1;
    if(t < 1/6) return p + (q - p) * 6 * t;
    if(t < 1/2) return q;
    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  }
  
  let rNew, gNew, bNew;
  if(s === 0) {
    rNew = gNew = bNew = newL;
  } else {
    const q = newL < 0.5 ? newL * (1 + s) : newL + s - newL * s;
    const p = 2 * newL - q;
    rNew = hue2rgb(p, q, h + 1/3);
    gNew = hue2rgb(p, q, h);
    bNew = hue2rgb(p, q, h - 1/3);
  }
  
  const rFinal = Math.round(rNew * 255);
  const gFinal = Math.round(gNew * 255);
  const bFinal = Math.round(bNew * 255);
  
  return `#${rFinal.toString(16).padStart(2,'0')}${gFinal.toString(16).padStart(2,'0')}${bFinal.toString(16).padStart(2,'0')}`;
}

// Get canvas as data URL for PDF
function getCanvasDataURLForPDF(canvas) {
  return canvas.toDataURL('image/jpeg', 0.85);
}

function getCanvasDescription() {
  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  const {pw, ph} = getEffectivePanelCounts();
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  // Calculate wall resolution accounting for CB5 half panels
  let wallResX, wallResY;
  if(hasCB5HalfRow) {
    const halfPanel = panels['CB5_MKII_HALF'];
    wallResX = pw * p.res_x;
    wallResY = (ph * p.res_y) + halfPanel.res_y; // All full rows + half row
  } else {
    wallResX = pw * p.res_x;
    wallResY = ph * p.res_y;
  }
  
  const canvasSize = document.getElementById('canvasSize').value;
  let canvasResX, canvasResY;
  
  if(canvasSize === 'custom') {
    canvasResX = parseInt(document.getElementById('customCanvasWidth').value) || 1920;
    canvasResY = parseInt(document.getElementById('customCanvasHeight').value) || 1080;
  } else if(canvasSize === '4K_UHD') {
    canvasResX = 3840;
    canvasResY = 2160;
  } else if(canvasSize === '4K_DCI') {
    canvasResX = 4096;
    canvasResY = 2160;
  } else if(canvasSize === 'HD') {
    canvasResX = 1920;
    canvasResY = 1080;
  } else {
    // Fallback
    canvasResX = 1920;
    canvasResY = 1080;
  }
  
  const canvasX = parseInt(document.getElementById('canvasX').value) || 0;
  const canvasY = parseInt(document.getElementById('canvasY').value) || 0;
  
  // Calculate coverage percentage
  const canvasArea = canvasResX * canvasResY;
  const wallArea = wallResX * wallResY;
  const coverage = ((canvasArea / wallArea) * 100).toFixed(1);
  
  // Get screen name from the current screen object
  const screen = screens[currentScreenId];
  const screenName = screen ? screen.name : '';
  const namePrefix = screenName ? `${screenName} - ` : '';
  
  const panelDescription = hasCB5HalfRow ? `${pw} × ${ph} + half row panels` : `${pw} × ${ph} panels`;
  
  return `${namePrefix}Wall Resolution: ${wallResX} × ${wallResY} px (${panelDescription})\nCanvas Resolution: ${canvasResX} × ${canvasResY} px\nPosition: X=${canvasX}px, Y=${canvasY}px\nCoverage: ${coverage}%`;
}

// Create outline-only version of standard layout for PDF
function createOutlineOnlyStandardCanvas() {
  const sourceCanvas = document.getElementById('standardCanvas');
  if(!sourceCanvas || sourceCanvas.width === 0) return null;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceCanvas.width;
  tempCanvas.height = sourceCanvas.height;
  const ctx = tempCanvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  
  const {pw, ph} = getEffectivePanelCounts();
  const size = panelSize;
  
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      const x = c * size;
      const y = r * size;
      
      if(deletedPanels.has(panelKey)) {
        ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
        continue;
      }

      // White fill
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Color outline - make more vibrant for PDF
      const baseColor = getStandardColorForPanel(c, r);
      const outlineColor = getVibrantColorForPDF(baseColor);
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, size, size);
      
      // Panel number
      ctx.fillStyle = '#000000';
      ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
    }
  }
  
  return tempCanvas;
}

// Create outline-only version of power layout for PDF
function createOutlineOnlyPowerCanvas() {
  const sourceCanvas = document.getElementById('powerCanvas');
  if(!sourceCanvas || sourceCanvas.width === 0) return null;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceCanvas.width;
  tempCanvas.height = sourceCanvas.height;
  const ctx = tempCanvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

  const {pw, ph} = getEffectivePanelCountsForLayout();
  const size = panelSize; // Use global panelSize for consistent sizing
  const socaLabelHeight = Math.max(60, size * 1.2);
  
  // Calculate panelsPerCircuit the same way as in calculate() function
  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  if(!p) return;
  const powerType = document.getElementById('powerType').value;
  const voltage = parseInt(document.getElementById('voltage').value) || 208;
  const breaker = parseInt(document.getElementById('breaker').value) || 20;
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const activePanelsCount = (pw * ph) - deletedPanels.size;
  const perPanelW = powerType === 'max' ? p.power_max_w : (p.power_avg_w || p.power_max_w * 0.5);
  const circuitCapacityW = voltage * breaker * derate;
  const calculatedPanelsPerCircuit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
  const userMaxPanelsPerCircuit = parseInt(document.getElementById('maxPanelsPerCircuit').value);
  const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;
  
  // Copy SOCA labels from original canvas
  const sourceCtx = sourceCanvas.getContext('2d');
  const labelData = sourceCtx.getImageData(0, 0, sourceCanvas.width, socaLabelHeight);
  ctx.putImageData(labelData, 0, 0);
  
  // STEP 1: Build list of all panels in order (column by column, top to bottom) - SAME AS ORIGINAL
  const orderedPanels = [];
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey)) {
        orderedPanels.push({
          key: panelKey,
          col: c,
          row: r,
          isCustom: customCircuitAssignments.has(panelKey),
          customCircuit: customCircuitAssignments.has(panelKey) ? customCircuitAssignments.get(panelKey) - 1 : null
        });
      }
    }
  }
  
  // STEP 2: Collect all custom circuit numbers that are in use - SAME AS ORIGINAL
  const usedCustomCircuits = new Set();
  orderedPanels.forEach(p => {
    if(p.isCustom) {
      usedCustomCircuits.add(p.customCircuit);
    }
  });
  
  // STEP 3: Assign circuit numbers - SAME AS ORIGINAL
  const panelToCircuit = new Map();
  let autoCircuitCounter = 0;
  let panelsInCurrentAutoCircuit = 0;
  
  orderedPanels.forEach(panel => {
    if(panel.isCustom) {
      // Keep custom assignment
      panelToCircuit.set(panel.key, panel.customCircuit);
    } else {
      // Find next available circuit number (skip over custom assignments)
      while(usedCustomCircuits.has(autoCircuitCounter)) {
        autoCircuitCounter++;
      }
      
      // Auto-assign to current circuit
      panelToCircuit.set(panel.key, autoCircuitCounter);
      panelsInCurrentAutoCircuit++;
      
      // Move to next circuit when we reach the limit
      if(panelsInCurrentAutoCircuit >= panelsPerCircuit) {
        autoCircuitCounter++;
        panelsInCurrentAutoCircuit = 0;
        
        // Skip over any custom circuits
        while(usedCustomCircuits.has(autoCircuitCounter)) {
          autoCircuitCounter++;
        }
      }
    }
  });
  
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Draw all panels
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      const x = c * size;
      const y = r * size + socaLabelHeight;
      
      if(deletedPanels.has(panelKey)) {
        ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
        continue;
      }

      const circuitNum = panelToCircuit.get(panelKey);
      if(circuitNum === undefined) continue;
      
      const socaGroup = Math.floor(circuitNum / 6);
      const colorIndex = circuitNum % 6;
      const colors = colorForIndex(colorIndex);
      const lightenPercent = socaGroup * 0.15;
      const baseColor = lightenColor(colors.solid, lightenPercent);
      
      // Make color more vibrant for PDF
      const outlineColor = getVibrantColorForPDF(baseColor);
      
      // White fill
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Color outline - use thicker line for better visibility
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, size, size);
      
      // Panel number
      ctx.fillStyle = '#000000';
      ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
    }
  }
  
  return tempCanvas;
}

// Create outline-only version of data layout for PDF
function createOutlineOnlyDataCanvas() {
  const sourceCanvas = document.getElementById('dataCanvas');
  if(!sourceCanvas || sourceCanvas.width === 0) return null;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceCanvas.width;
  tempCanvas.height = sourceCanvas.height;
  const ctx = tempCanvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

  const {pw, ph} = getEffectivePanelCounts();
  const size = panelSize; // Use global panelSize for consistent sizing
  
  // Calculate panelsPerDataLine the same way as in calculate() function
  const allPanels = getAllPanels();
  const allProcessors = getAllProcessors();
  const p = allPanels[document.getElementById('panelType').value];
  const pr = allProcessors[document.getElementById('processor').value];
  if(!p || !pr) return;
  const pixelsPerPanel = p.res_x * p.res_y;
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  const adjustedCapacity = calculateAdjustedPixelCapacity(pr, frameRate, bitDepth);
  const suggestedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  const userMax = parseInt(document.getElementById('maxPanelsPerData').value);
  const panelsPerDataLine = userMax > 0 ? userMax : suggestedPanelsPerData;
  
  const startDir = document.getElementById('dataStartDir').value;
  
  // Build data path based on start direction (SAME AS ORIGINAL)
  const serp = [];
  
  if(startDir === 'all_top') {
    // All columns start at top (going down)
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          serp.push({c, r});
        }
      }
    }
  } else if(startDir === 'all_bottom') {
    // All columns start at bottom (going up)
    for(let c=0; c<pw; c++){
      for(let r=ph-1; r>=0; r--) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          serp.push({c, r});
        }
      }
    }
  } else {
    // Serpentine pattern (for 'top' and 'bottom')
    const startFromTop = (startDir==='top' || startDir==='top_left');
    for(let c=0; c<pw; c++){
      const dirDown = (c%2===0) ? startFromTop : !startFromTop;
      if(dirDown){ 
        for(let r=0; r<ph; r++) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      } else { 
        for(let r=ph-1; r>=0; r--) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      }
    }
  }
  
  // Group into data lines with support for custom assignments (SAME AS ORIGINAL)
  const orderedDataPanels = [];
  serp.forEach(panel => {
    const panelKey = `${panel.c},${panel.r}`;
    orderedDataPanels.push({
      c: panel.c,
      r: panel.r,
      key: panelKey,
      isCustom: customDataLineAssignments.has(panelKey),
      customDataLine: customDataLineAssignments.has(panelKey) ? customDataLineAssignments.get(panelKey) - 1 : null
    });
  });
  
  // Collect all custom data line numbers in use
  const usedCustomDataLines = new Set();
  orderedDataPanels.forEach(p => {
    if(p.isCustom) {
      usedCustomDataLines.add(p.customDataLine);
    }
  });
  
  // Assign data line numbers
  const panelToDataLine = new Map();
  let autoDataLineCounter = 0;
  let panelsInCurrentAutoDataLine = 0;
  
  orderedDataPanels.forEach(panel => {
    if(panel.isCustom) {
      // Keep custom assignment
      panelToDataLine.set(panel.key, panel.customDataLine);
    } else {
      // Find next available data line number (skip over custom assignments)
      while(usedCustomDataLines.has(autoDataLineCounter)) {
        autoDataLineCounter++;
      }
      
      // Auto-assign to current data line
      panelToDataLine.set(panel.key, autoDataLineCounter);
      panelsInCurrentAutoDataLine++;
      
      // Move to next data line when we reach the limit
      if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
        autoDataLineCounter++;
        panelsInCurrentAutoDataLine = 0;
        
        // Skip over any custom data lines
        while(usedCustomDataLines.has(autoDataLineCounter)) {
          autoDataLineCounter++;
        }
      }
    }
  });
  
  // Build groups based on data line assignments
  const dataLineGroups = new Map();
  orderedDataPanels.forEach(panel => {
    const dataLine = panelToDataLine.get(panel.key);
    if(!dataLineGroups.has(dataLine)) {
      dataLineGroups.set(dataLine, []);
    }
    dataLineGroups.get(dataLine).push({c: panel.c, r: panel.r});
  });
  
  // Convert to array sorted by data line number
  const groups = [];
  const sortedDataLines = Array.from(dataLineGroups.keys()).sort((a, b) => a - b);
  sortedDataLines.forEach(dataLine => {
    groups.push(dataLineGroups.get(dataLine));
  });
  
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Draw deleted panels first
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      const x = c * size;
      const y = r * size;
      
      if(deletedPanels.has(panelKey)) {
        ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
      }
    }
  }


  // Draw active panels with data grouping
  for(let gi=0; gi<groups.length; gi++){
    const colors = colorForIndex(gi);
    const vibrantColor = getVibrantColorForPDF(colors.solid);
    
    for(let idx=0; idx<groups[gi].length; idx++){
      const pnt = groups[gi][idx];
      const x = pnt.c * size;
      const y = pnt.r * size;
      
      // White fill
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Color outline - use thicker line for better visibility
      ctx.strokeStyle = vibrantColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, size, size);
      
      // Panel number
      ctx.fillStyle = '#000000';
      ctx.fillText(`${pnt.c+1}.${pnt.r+1}`, x+size/2, y+size/2);
    }
  }
  
  return tempCanvas;
}

function getStandardColorForPanel(c, r){
  // Get the current screen's colors (same as canvas view)
  const currentScreen = screens[currentScreenId];
  let primaryColor = currentScreen ? currentScreen.color : '#808080';
  let secondaryColor = currentScreen ? (currentScreen.color2 || darkenColor(primaryColor, 30)) : '#606060';

  // Convert to pastel colors for eco-friendly printing
  if (ecoPrintMode) {
    primaryColor = toPastelColor(primaryColor);
    secondaryColor = toPastelColor(secondaryColor);
  }

  // Convert to greyscale for greyscale printing
  if (greyscalePrintMode) {
    primaryColor = toGreyscale(primaryColor);
    secondaryColor = toGreyscale(secondaryColor);
  }

  // Alternate colors in a checkerboard pattern (same logic as canvas view)
  const isEvenPanel = (c + r) % 2 === 0;
  return isEvenPanel ? primaryColor : secondaryColor;
}

function getEffectivePanelCountsForLayout(){ 
  const {pw, ph} = getEffectivePanelCounts(); 
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  // Add an extra row if CB5 half panels are enabled
  const adjustedPh = hasCB5HalfRow ? ph + 1 : ph;
  
  return {pw, ph: adjustedPh}; 
}

function generateLayout(mode){
  lastLayoutMode = mode;
  const allPanels = getAllPanels();
  const allProcessors = getAllProcessors();
  const p=allPanels[document.getElementById('panelType').value];
  if(!p || !p.width_m || !p.height_m){ return; }
  const proc=allProcessors[document.getElementById('processor').value];
  const voltage=parseFloat(document.getElementById('voltage').value)||220;
  const breaker=parseFloat(document.getElementById('breaker').value)||20;
  const powerType=document.getElementById('powerType').value;
  const perPanelW = powerType==='max' ? (p.power_max_w||0) : (p.power_avg_w||0);
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const circuitW=voltage*breaker*derate;
  const calculatedPanelsPerCircuit=Math.max(1, Math.floor(circuitW/Math.max(1,perPanelW)||1));
  
  // Get user override or use calculated value
  const userMaxPanelsPerCircuit = parseInt(document.getElementById('maxPanelsPerCircuit').value);
  const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;
  
  const pixelsPerPanel=(p.res_x&&p.res_y)?p.res_x*p.res_y: (176*176);
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  const adjustedCapacity = calculateAdjustedPixelCapacity(proc, frameRate, bitDepth);
  
  // Calculate suggested panels per data line accounting for CB5 half panels
  let capacityBasedPanelsPerData;
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  if(hasCB5HalfRow) {
    // With half panels, calculate based on average pixels per panel
    const {pw, ph} = getEffectivePanelCounts();
    const totalPanelsGrid = pw * ph;
    const activePanelsCount = totalPanelsGrid - deletedPanels.size;
    const halfPanel = panels['CB5_MKII_HALF'];
    const halfPanelPixels = halfPanel.res_x * halfPanel.res_y;
    const mainPanelCount = activePanelsCount; // All full panels
    const halfPanelCount = pw; // Additional half panel row
    const totalMixedPanels = mainPanelCount + halfPanelCount;
    const totalPixels = (mainPanelCount * pixelsPerPanel) + (halfPanelCount * halfPanelPixels);
    const avgPixelsPerPanel = totalPixels / totalMixedPanels;
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / avgPixelsPerPanel));
  } else {
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  }

  // Cap at 500 panels per port (Brompton Tessera hardware limit)
  const MAX_PANELS_PER_PORT = 500;
  capacityBasedPanelsPerData = Math.min(capacityBasedPanelsPerData, MAX_PANELS_PER_PORT);

  // Apply panel-specific max_panels_per_data limit (same logic as calculate())
  // Apply panel's max_panels_per_data limit even when mixing with half panels
  const panelSpecificDataLimit = p.max_panels_per_data || null;
  const suggestedPanelsPerData = panelSpecificDataLimit
    ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
    : capacityBasedPanelsPerData;
  
  const userMax = parseInt(document.getElementById('maxPanelsPerData').value);
  const panelsPerDataLine = (mode==='data') ? (userMax>0?userMax:suggestedPanelsPerData) : null;
  const startDirEl = document.getElementById('dataStartDir');
  const startDir = startDirEl ? startDirEl.value : 'top';
  // Using showArrowsEnabled toggle state
  const showArrows = showArrowsEnabled;

  const {pw, ph} = getEffectivePanelCountsForLayout();

  let canvasId, containerId;
  if(mode === 'standard'){
    canvasId = 'standardCanvas';
    containerId = 'standardContainer';
    
    // Setup interactivity after first render
    setTimeout(() => setupStandardCanvasInteractivity(), 10);
  } else if(mode === 'power'){
    canvasId = 'powerCanvas';
    containerId = 'powerContainer';
  } else {
    canvasId = 'dataCanvas';
    containerId = 'dataContainer';
  }

  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');

  // Calculate dynamic panel size based on container width
  const container = document.getElementById(containerId);
  // Only show layout containers in complex mode (not simple mode)
  const isSimpleMode = typeof currentAppMode !== 'undefined' && currentAppMode === 'simple';
  if(!isSimpleMode) {
    container.style.display = 'block';
  }
  const containerWidth = container.clientWidth - 32; // Account for padding
  const maxCanvasWidth = Math.min(containerWidth, 800); // Cap at 800px max
  const minSize = 30; // Minimum panel size
  const maxSize = 80; // Maximum panel size
  const calculatedSize = Math.floor(maxCanvasWidth / pw);
  const size = Math.max(minSize, Math.min(maxSize, calculatedSize));

  // Get panel type and calculate height ratio for CB5_MKII full panels
  const panelType = document.getElementById('panelType').value;
  const heightRatio = getPanelHeightRatio(panelType);
  const panelWidth = size;
  const panelHeight = size * heightRatio;

  // hasCB5HalfRow is already declared earlier in this function
  // Calculate dimensions accounting for half panel row
  const originalPh = hasCB5HalfRow ? ph - 1 : ph; // ph includes the half row, originalPh is just full panels
  const halfPanelHeight = size; // Half panels are square

  // Canvas height: full panel rows + half panel row if enabled
  const canvasHeightCalc = hasCB5HalfRow ? (originalPh * panelHeight + halfPanelHeight) : (ph * panelHeight);
  canvas.width = pw * panelWidth;
  canvas.height = canvasHeightCalc;

  // Update global panelSize for all modes
  panelSize = size;
  currentPanelWidth = panelWidth;
  currentPanelHeight = panelHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const fontSize = Math.max(10, Math.floor(size * 0.22));
  ctx.font = `${fontSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  if(mode==='standard'){
    currentCanvas = canvas;
    currentPw = pw;
    currentPh = ph;

    for(let c=0;c<pw;c++){
      for(let r=0;r<ph;r++){
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row (last row when hasCB5HalfRow)
        const isHalfPanelRow = hasCB5HalfRow && r === originalPh;
        const currentPanelHeight = isHalfPanelRow ? halfPanelHeight : panelHeight;
        // Calculate Y position: full panels use panelHeight, half panel row starts after all full panels
        const y = isHalfPanelRow ? (originalPh * panelHeight) : (r * panelHeight);
        const x = c * panelWidth;

        // Skip deleted panels
        if(deletedPanels.has(panelKey)) {
          ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a'; // White for eco print, dark otherwise
          ctx.fillRect(x, y, panelWidth, currentPanelHeight);
          ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(x, y, panelWidth, currentPanelHeight);
          ctx.setLineDash([]);
          continue;
        }

        const fillColor = getStandardColorForPanel(c, r);
        ctx.fillStyle = fillColor;
        ctx.fillRect(x, y, panelWidth, currentPanelHeight);

        // Highlight selected panels
        if(selectedPanels.has(panelKey)) {
          ctx.strokeStyle = '#00FF00';
          ctx.lineWidth = 4;
          ctx.strokeRect(x+2, y+2, panelWidth-4, currentPanelHeight-4);
        }

        // Show indicators for custom assignments
        if(customCircuitAssignments.has(panelKey)) {
          ctx.fillStyle = '#FFD700'; // Gold indicator for circuit
          ctx.fillRect(x+panelWidth-10, y+2, 8, 8);
        }
        if(customDataLineAssignments.has(panelKey)) {
          ctx.fillStyle = '#00CED1'; // Cyan indicator for data line
          ctx.fillRect(x+2, y+currentPanelHeight-10, 8, 8);
        }

        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, panelWidth, currentPanelHeight);
        ctx.fillStyle = '#000000'; // Always use black text (no black panels in standard layout)
        ctx.fillText(`${c+1}.${r+1}`, x+panelWidth/2, y+currentPanelHeight/2);
      }
    }

    return;
  }

  if(mode==='power'){
    // Power layout rule: Always start circuits at the top of each column
    // Knockouts in a column split that column into separate circuit segments

    const socaLabelHeight = 60;
    canvas.height = canvasHeightCalc + socaLabelHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Fill label area with white background (for PDF export - JPEG doesn't support transparency)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, socaLabelHeight);

    // Draw black border at bottom of SOCA label area (ensures visibility across all browsers)
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, socaLabelHeight);
    ctx.lineTo(canvas.width, socaLabelHeight);
    ctx.stroke();

    // Build column-by-column circuit assignments
    const columnCircuits = []; // Array of circuit segments per column
    let globalCircuitIndex = 0;
    
    for(let c=0; c<pw; c++){
      const columnPanels = [];
      
      // Collect active panels in this column from top to bottom
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          columnPanels.push({c, r, key: panelKey});
        }
      }
      
      // Split column into circuit segments based on panelsPerCircuit
      let circuitSegments = [];
      for(let i=0; i<columnPanels.length; i += panelsPerCircuit){
        const segment = columnPanels.slice(i, i + panelsPerCircuit);
        if(segment.length > 0) {
          circuitSegments.push({
            circuitNum: globalCircuitIndex++,
            panels: segment
          });
        }
      }
      
      columnCircuits.push(circuitSegments);
    }
    
    // Flatten all circuits for SOCA grouping
    const allCircuits = [];
    columnCircuits.forEach(col => {
      col.forEach(seg => {
        allCircuits.push(seg);
      });
    });
    
    // STEP 1: Build list of all panels in order (column by column, top to bottom)
    const orderedPanels = [];
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          orderedPanels.push({
            key: panelKey,
            col: c,
            row: r,
            isCustom: customCircuitAssignments.has(panelKey),
            customCircuit: customCircuitAssignments.has(panelKey) ? customCircuitAssignments.get(panelKey) - 1 : null
          });
        }
      }
    }
    
    // STEP 2: Collect all custom circuit numbers that are in use
    const usedCustomCircuits = new Set();
    orderedPanels.forEach(p => {
      if(p.isCustom) {
        usedCustomCircuits.add(p.customCircuit);
      }
    });
    
    // STEP 3: Assign circuit numbers
    const panelToCircuit = new Map();
    let autoCircuitCounter = 0;
    let panelsInCurrentAutoCircuit = 0;
    
    orderedPanels.forEach(panel => {
      if(panel.isCustom) {
        // Keep custom assignment
        panelToCircuit.set(panel.key, panel.customCircuit);
      } else {
        // Find next available circuit number (skip over custom assignments)
        while(usedCustomCircuits.has(autoCircuitCounter)) {
          autoCircuitCounter++;
        }
        
        // Auto-assign to current circuit
        panelToCircuit.set(panel.key, autoCircuitCounter);
        panelsInCurrentAutoCircuit++;
        
        // Move to next circuit when we reach the limit
        if(panelsInCurrentAutoCircuit >= panelsPerCircuit) {
          autoCircuitCounter++;
          panelsInCurrentAutoCircuit = 0;
          
          // Skip over any custom circuits
          while(usedCustomCircuits.has(autoCircuitCounter)) {
            autoCircuitCounter++;
          }
        }
      }
    });
    
    // Draw all panels
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row
        const isHalfPanelRow = hasCB5HalfRow && r === originalPh;
        const currentPanelHeight = isHalfPanelRow ? halfPanelHeight : panelHeight;
        const x = c * panelWidth;
        const y = (isHalfPanelRow ? (originalPh * panelHeight) : (r * panelHeight)) + socaLabelHeight;

        // Check if panel is deleted
        if(deletedPanels.has(panelKey)) {
          ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
          ctx.fillRect(x, y, panelWidth, currentPanelHeight);
          ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(x, y, panelWidth, currentPanelHeight);
          ctx.setLineDash([]);
          continue;
        }

        // Get circuit number for this panel
        const circuitNum = panelToCircuit.get(panelKey);
        if(circuitNum === undefined) continue;

        // Determine which SOCA group this circuit belongs to
        const socaGroup = Math.floor(circuitNum / 6);
        const colorIndex = circuitNum % 6;
        const colors = colorForIndex(colorIndex);

        // Lighten the color based on SOCA group (10% lighter for each SOCA)
        const lightenPercent = socaGroup * 0.15; // 15% lighter per SOCA group
        const fillColor = lightenColor(colors.solid, lightenPercent);

        ctx.fillStyle = fillColor;
        ctx.fillRect(x, y, panelWidth, currentPanelHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, panelWidth, currentPanelHeight);

        // Always use black text (no black panels in power layout)
        ctx.fillStyle = '#000000';

        ctx.font = '11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${c+1}.${r+1}`, x+panelWidth/2, y+currentPanelHeight/2);
      }
    }
    
    // Draw SOCA labels
    // Find the actual max circuit number used (including custom assignments)
    let maxCircuitNum = 0;
    panelToCircuit.forEach(circuitNum => {
      if(circuitNum > maxCircuitNum) maxCircuitNum = circuitNum;
    });
    const totalCircuits = maxCircuitNum + 1;
    const socaGroups = Math.ceil(totalCircuits / 6);
    
    // Build a map of circuit number -> panels with that circuit
    const circuitPanelMap = new Map();
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(deletedPanels.has(panelKey)) continue;

        const circuitNum = panelToCircuit.get(panelKey);
        if(circuitNum !== undefined) {
          if(!circuitPanelMap.has(circuitNum)) {
            circuitPanelMap.set(circuitNum, []);
          }
          circuitPanelMap.get(circuitNum).push({
            c: c,
            r: r,
            x: c * panelWidth
          });
        }
      }
    }
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    for(let s = 0; s < socaGroups; s++){
      const startCircuit = s * 6;
      const endCircuit = Math.min((s + 1) * 6 - 1, totalCircuits - 1);
      
      // Find the leftmost and rightmost panels in this SOCA group
      let minX = Infinity;
      let maxX = -Infinity;
      
      for(let circuit = startCircuit; circuit <= endCircuit; circuit++) {
        if(circuitPanelMap.has(circuit)) {
          const panels = circuitPanelMap.get(circuit);
          panels.forEach(p => {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
          });
        }
      }
      
      // If no panels found, skip this SOCA
      if(minX === Infinity) continue;

      const lineY = 35;
      const startX = minX;
      const endX = maxX + panelWidth;
      const midX = (startX + endX) / 2;
      
      // Draw horizontal line across the top
      ctx.beginPath();
      ctx.moveTo(startX, lineY);
      ctx.lineTo(endX, lineY);
      ctx.stroke();
      
      // Draw vertical ticks at the ends
      ctx.beginPath();
      ctx.moveTo(startX, lineY - 8);
      ctx.lineTo(startX, lineY + 8);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(endX, lineY - 8);
      ctx.lineTo(endX, lineY + 8);
      ctx.stroke();
      
      // Draw SOCA label above the line
      ctx.fillText(`SOCA ${s + 1}`, midX, lineY - 20);
      
      // Draw circuit range below the line
      ctx.font = '12px Arial';
      const circuitRange = startCircuit === endCircuit ? 
        `Circuit ${startCircuit + 1}` : 
        `Circuits ${startCircuit + 1}-${endCircuit + 1}`;
      ctx.fillText(circuitRange, midX, lineY + 20);
      ctx.font = 'bold 16px Arial';
    }
    
    return;
  }

  if(mode==='data'){
    // Build data path based on start direction (matching calculateActualDataLines logic)
    const serp = [];
    
    if(startDir === 'all_top') {
      // All columns start at top (going down)
      for(let c=0; c<pw; c++){
        for(let r=0; r<ph; r++) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      }
    } else if(startDir === 'all_bottom') {
      // All columns start at bottom (going up)
      for(let c=0; c<pw; c++){
        for(let r=ph-1; r>=0; r--) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      }
    } else {
      // Serpentine pattern (for 'top' and 'bottom')
      // Build serpentine path that respects data line boundaries
      const startFromTop = (startDir==='top');
      
      let panelsInCurrentDataLine = 0;
      let currentDataLine = 0;
      let currentColumn = 0;
      let serpentineGoingDown = startFromTop; // Initial direction
      let lastDataLineEndedAtBoundary = true; // First data line starts fresh
      
      while(currentColumn < pw) {
        // Count non-deleted, non-custom panels in this column
        let panelsInColumn = 0;
        for(let r=0; r<ph; r++) {
          const panelKey = `${currentColumn},${r}`;
          if(!deletedPanels.has(panelKey) && !customDataLineAssignments.has(panelKey)) {
            panelsInColumn++;
          }
        }
        
        // Check if adding this entire column would exceed the data line limit
        if(panelsInCurrentDataLine > 0 && panelsInCurrentDataLine + panelsInColumn > panelsPerDataLine) {
          // This column will cause a split - need to add partial column
          const panelsWeCanAdd = panelsPerDataLine - panelsInCurrentDataLine;
          
          // Track the actual row position where we stopped (not just the count)
          let lastRowProcessed = -1;

          if(panelsWeCanAdd > 0) {
            // Add partial column to current data line
            if(serpentineGoingDown) {
              // Going down - add from top
              let added = 0;
              for(let r=0; r<ph && added<panelsWeCanAdd; r++) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  added++;
                  lastRowProcessed = r;
                }
              }
              // Data line ends mid-column, not at boundary
              lastDataLineEndedAtBoundary = false;
            } else {
              // Going up - add from bottom
              let added = 0;
              for(let r=ph-1; r>=0 && added<panelsWeCanAdd; r--) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  added++;
                  lastRowProcessed = r;
                }
              }
              // Data line ends mid-column, not at boundary
              lastDataLineEndedAtBoundary = false;
            }
          }

          // Start new data line
          currentDataLine++;
          panelsInCurrentDataLine = 0;

          // If previous data line ended mid-column, continue serpentine in same direction
          // If it ended at boundary, start fresh serpentine
          if(!lastDataLineEndedAtBoundary) {
            // Continue in same column, same direction
            // Don't toggle direction, don't move to next column yet
            // The remaining panels in this column will be added in next iteration
            // But we need to continue adding panels from this column
            const remainingPanels = panelsInColumn - panelsWeCanAdd;

            if(serpentineGoingDown) {
              // Continue going down from where we left off (next row after lastRowProcessed)
              let added = 0;
              for(let r=lastRowProcessed+1; r<ph && added<Math.min(remainingPanels, panelsPerDataLine); r++) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  panelsInCurrentDataLine++;
                  added++;
                }
              }
            } else {
              // Continue going up from where we left off (previous row before lastRowProcessed)
              let added = 0;
              for(let r=lastRowProcessed-1; r>=0 && added<Math.min(remainingPanels, panelsPerDataLine); r--) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  panelsInCurrentDataLine++;
                  added++;
                }
              }
            }

            // Check if we finished this column
            if(panelsInCurrentDataLine >= remainingPanels) {
              // Finished column, move to next and toggle direction
              currentColumn++;
              serpentineGoingDown = !serpentineGoingDown;

              // Check if this column ended at a boundary
              if(serpentineGoingDown) {
                // Was going up, now going down - ended at top (boundary)
                lastDataLineEndedAtBoundary = true;
              } else {
                // Was going down, now going up - ended at bottom (boundary)
                lastDataLineEndedAtBoundary = true;
              }
            }
            // If we didn't finish the column, we'll continue it in the next data line iteration
            continue;
          } else {
            // Previous data line ended at boundary - start fresh serpentine
            // Reset direction based on start preference
            serpentineGoingDown = startFromTop;
            // Don't increment column - we still need to process this column
          }
        } else {
          // Entire column fits in current data line
          if(serpentineGoingDown) {
            // Going down
            for(let r=0; r<ph; r++) {
              const panelKey = `${currentColumn},${r}`;
              if(!deletedPanels.has(panelKey)) {
                serp.push({c: currentColumn, r: r});
                panelsInCurrentDataLine++;
              }
            }
            // Ended at bottom of column - this is a boundary
            lastDataLineEndedAtBoundary = true;
          } else {
            // Going up
            for(let r=ph-1; r>=0; r--) {
              const panelKey = `${currentColumn},${r}`;
              if(!deletedPanels.has(panelKey)) {
                serp.push({c: currentColumn, r: r});
                panelsInCurrentDataLine++;
              }
            }
            // Ended at top of column - this is a boundary
            lastDataLineEndedAtBoundary = true;
          }
          
          // Move to next column and toggle direction
          currentColumn++;
          serpentineGoingDown = !serpentineGoingDown;
        }
      }
    }
    
    // Group into data lines with support for custom assignments
    // Build ordered list of all panels
    const orderedDataPanels = [];
    serp.forEach(panel => {
      const panelKey = `${panel.c},${panel.r}`;
      orderedDataPanels.push({
        c: panel.c,
        r: panel.r,
        key: panelKey,
        isCustom: customDataLineAssignments.has(panelKey),
        customDataLine: customDataLineAssignments.has(panelKey) ? customDataLineAssignments.get(panelKey) - 1 : null
      });
    });
    
    // Collect all custom data line numbers in use
    const usedCustomDataLines = new Set();
    orderedDataPanels.forEach(p => {
      if(p.isCustom) {
        usedCustomDataLines.add(p.customDataLine);
      }
    });
    
    // Assign data line numbers
    const panelToDataLine = new Map();
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;
    
    // Special handling for all_top and all_bottom - each column is its own data line
    if(startDir === 'all_top' || startDir === 'all_bottom') {
      let currentColumn = -1;
      let columnDataLine = 0;
      
      orderedDataPanels.forEach(panel => {
        if(panel.isCustom) {
          // Keep custom assignment
          panelToDataLine.set(panel.key, panel.customDataLine);
        } else {
          // Check if we've moved to a new column
          if(panel.c !== currentColumn) {
            // Moving to new column - get next available data line
            if(currentColumn >= 0) {
              // Not the first column, so increment
              columnDataLine++;
            }
            currentColumn = panel.c;
            
            // Find next available data line number (skip over custom assignments)
            while(usedCustomDataLines.has(columnDataLine)) {
              columnDataLine++;
            }
          }
          
          // All panels in this column use the same data line
          panelToDataLine.set(panel.key, columnDataLine);
        }
      });
    } else {
      // Normal serpentine: split by panelsPerDataLine
      orderedDataPanels.forEach(panel => {
        if(panel.isCustom) {
          // Keep custom assignment
          panelToDataLine.set(panel.key, panel.customDataLine);
        } else {
          // Find next available data line number (skip over custom assignments)
          while(usedCustomDataLines.has(autoDataLineCounter)) {
            autoDataLineCounter++;
          }
          
          // Auto-assign to current data line
          panelToDataLine.set(panel.key, autoDataLineCounter);
          panelsInCurrentAutoDataLine++;
          
          // Move to next data line when we reach the limit
          if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
            autoDataLineCounter++;
            panelsInCurrentAutoDataLine = 0;
            
            // Skip over any custom data lines
            while(usedCustomDataLines.has(autoDataLineCounter)) {
              autoDataLineCounter++;
            }
          }
        }
      });
    }
    
    // Build groups based on data line assignments
    const dataLineGroups = new Map();
    orderedDataPanels.forEach(panel => {
      const dataLine = panelToDataLine.get(panel.key);
      if(!dataLineGroups.has(dataLine)) {
        dataLineGroups.set(dataLine, []);
      }
      dataLineGroups.get(dataLine).push({c: panel.c, r: panel.r});
    });
    
    // Convert to array sorted by data line number
    const groups = [];
    const sortedDataLines = Array.from(dataLineGroups.keys()).sort((a, b) => a - b);
    sortedDataLines.forEach(dataLine => {
      groups.push(dataLineGroups.get(dataLine));
    });

    // Draw all panels first (including deleted)
    for(let c=0;c<pw;c++){
      for(let r=0;r<ph;r++){
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row
        const isHalfPanelRow = hasCB5HalfRow && r === originalPh;
        const currentPanelHeight = isHalfPanelRow ? halfPanelHeight : panelHeight;
        const x = c * panelWidth;
        const y = isHalfPanelRow ? (originalPh * panelHeight) : (r * panelHeight);

        // Check if panel is deleted
        if(deletedPanels.has(panelKey)) {
          ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
          ctx.fillRect(x,y,panelWidth,currentPanelHeight);
          ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(x,y,panelWidth,currentPanelHeight);
          ctx.setLineDash([]);
        }
      }
    }

    // Draw active panels with data grouping
    const groupPoints = [];
    for(let gi=0; gi<groups.length; gi++){
      const colors=colorForIndex(gi);
      groupPoints[gi] = [];
      for(let idx=0; idx<groups[gi].length; idx++){
        const pnt = groups[gi][idx];

        // Determine if this row is the half panel row
        const isHalfPanelRow = hasCB5HalfRow && pnt.r === originalPh;
        const currentPanelHeight = isHalfPanelRow ? halfPanelHeight : panelHeight;
        const x = pnt.c * panelWidth;
        const y = isHalfPanelRow ? (originalPh * panelHeight) : (pnt.r * panelHeight);

        ctx.fillStyle=colors.fill;
        ctx.fillRect(x,y,panelWidth,currentPanelHeight);
        ctx.strokeStyle='#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x,y,panelWidth,currentPanelHeight);

        // Use white text only for data line 9 (black resistor color), black text for all others
        ctx.fillStyle = (gi === 9) ? '#FFFFFF' : '#000000';

        // Show panel number as column.row (matching standard layout)
        ctx.fillText(`${pnt.c+1}.${pnt.r+1}`, x+panelWidth/2, y+currentPanelHeight/2);
        groupPoints[gi].push({x:x+panelWidth/2, y:y+currentPanelHeight/2, color: colors.solid});
      }
    }
    if(showArrows){
      if(startDir === 'all_top' || startDir === 'all_bottom') {
        // For all_top and all_bottom, draw one arrow per column
        // Group points by column
        for(let gi=0; gi<groupPoints.length; gi++){
          const pts = groupPoints[gi];
          if(pts.length<2) continue;
          
          // Group points by column
          const columnGroups = new Map();
          groups[gi].forEach((pnt, idx) => {
            if(!columnGroups.has(pnt.c)) {
              columnGroups.set(pnt.c, []);
            }
            columnGroups.get(pnt.c).push(pts[idx]);
          });
          
          // Draw arrow for each column
          columnGroups.forEach((columnPoints) => {
            if(columnPoints.length >= 2) {
              drawArrowPath(ctx, columnPoints, '#000000');
            }
          });
        }
      } else {
        // For serpentine patterns, only draw arrows between ADJACENT panels in same data line
        // Build segments of continuous adjacent panels
        for(let gi=0; gi<groupPoints.length; gi++){
          const pts = groupPoints[gi];
          const grp = groups[gi];
          if(pts.length<2) continue;
          
          // Build segments - break when panels are not adjacent
          const segments = [];
          let currentSegment = [pts[0]];
          
          for(let i=1; i<pts.length; i++){
            const prev = grp[i-1];
            const curr = grp[i];
            
            // Check if current panel is adjacent to previous (within same column or adjacent columns)
            const colDiff = Math.abs(curr.c - prev.c);
            const rowDiff = Math.abs(curr.r - prev.r);
            
            // Adjacent means: same column (any row), or adjacent columns at top/bottom boundary
            const isAdjacent = (colDiff === 0) || // same column
                               (colDiff === 1 && (prev.r === 0 || prev.r === ph-1 || curr.r === 0 || curr.r === ph-1)); // adjacent column at boundary
            
            if(isAdjacent) {
              currentSegment.push(pts[i]);
            } else {
              // Not adjacent - finish current segment and start new one
              if(currentSegment.length >= 2) {
                segments.push(currentSegment);
              }
              currentSegment = [pts[i]];
            }
          }
          
          // Add final segment
          if(currentSegment.length >= 2) {
            segments.push(currentSegment);
          }
          
          // Draw each segment
          segments.forEach(segment => {
            drawArrowPath(ctx, segment, '#000000');
          });
        }
      }
    }
    return;
  }
}

function drawArrowPath(ctx, points, colorHex){
  ctx.save();
  ctx.strokeStyle = colorHex;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for(let i=1;i<points.length;i++){
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();

  const end = points[points.length-1];
  const prev = points[points.length-2];
  const angle = Math.atan2(end.y - prev.y, end.x - prev.x);
  drawVArrowhead(ctx, end.x, end.y, angle, colorHex);
  ctx.restore();
}

// Floor frame calculation for floor panels (like BM4)
// Returns array of frame objects with position, size, and type
function calculateFloorFrames(pw, ph, deletedPanelsSet) {
  const frames = [];

  // Create a grid to track which panels are covered
  // true = panel exists and needs frame, false = no panel or already covered
  const needsCoverage = [];
  for(let r = 0; r < ph; r++) {
    needsCoverage[r] = [];
    for(let c = 0; c < pw; c++) {
      const panelKey = `${c},${r}`;
      needsCoverage[r][c] = !deletedPanelsSet.has(panelKey);
    }
  }

  // Frame definitions: [width, height, type name]
  // Order matters - try larger frames first
  const frameTypes = [
    { w: 3, h: 2, type: 'frame_3x2', name: '3x2' },
    { w: 2, h: 3, type: 'frame_3x2', name: '3x2' }, // rotated 3x2
    { w: 2, h: 2, type: 'frame_2x2', name: '2x2' },
    { w: 2, h: 1, type: 'frame_2x1', name: '2x1' },
    { w: 1, h: 2, type: 'frame_2x1', name: '2x1' }, // rotated 2x1
    { w: 1, h: 1, type: 'frame_1x1', name: '1x1' }
  ];

  // Helper to check if a frame can fit at position
  function canPlaceFrame(startC, startR, frameW, frameH) {
    if(startC + frameW > pw || startR + frameH > ph) return false;
    for(let r = startR; r < startR + frameH; r++) {
      for(let c = startC; c < startC + frameW; c++) {
        if(!needsCoverage[r][c]) return false;
      }
    }
    return true;
  }

  // Helper to mark panels as covered
  function markCovered(startC, startR, frameW, frameH) {
    for(let r = startR; r < startR + frameH; r++) {
      for(let c = startC; c < startC + frameW; c++) {
        needsCoverage[r][c] = false;
      }
    }
  }

  // Greedy algorithm: scan grid and place largest possible frame at each uncovered position
  for(let r = 0; r < ph; r++) {
    for(let c = 0; c < pw; c++) {
      if(!needsCoverage[r][c]) continue;

      // Try each frame type from largest to smallest
      for(const frameType of frameTypes) {
        if(canPlaceFrame(c, r, frameType.w, frameType.h)) {
          frames.push({
            col: c,
            row: r,
            width: frameType.w,
            height: frameType.h,
            type: frameType.type,
            name: frameType.name
          });
          markCovered(c, r, frameType.w, frameType.h);
          break;
        }
      }
    }
  }

  return frames;
}

// Get frame counts from calculated frames
function getFloorFrameCounts(frames) {
  const counts = {
    frame_1x1: 0,
    frame_2x1: 0,
    frame_2x2: 0,
    frame_3x2: 0
  };

  frames.forEach(frame => {
    counts[frame.type]++;
  });

  return counts;
}

// Colors for different frame types
const floorFrameColors = {
  frame_1x1: '#ff6b6b', // Red
  frame_2x1: '#4ecdc4', // Teal
  frame_2x2: '#ffe66d', // Yellow
  frame_3x2: '#b794f4'  // Purple
};

// Structure View generation
function generateStructureLayout(){
  const allPanels = getAllPanels();
  const p=allPanels[document.getElementById('panelType').value];
  if(!p || !p.width_m || !p.height_m){ return; }

  const {pw, ph} = getEffectivePanelCountsForLayout();

  const canvas = document.getElementById('structureCanvas');
  const ctx = canvas.getContext('2d');

  // Calculate dynamic panel size based on container width
  const structContainer = document.getElementById('structureContainer');
  // Only show structure container in complex mode (not simple mode)
  const isSimpleMode = typeof currentAppMode !== 'undefined' && currentAppMode === 'simple';
  if(!isSimpleMode) {
    structContainer.style.display = 'block';
  }
  const structContainerWidth = structContainer.clientWidth - 32; // Account for padding
  const maxStructCanvasWidth = Math.min(structContainerWidth, 800); // Cap at 800px max
  const minStructSize = 30; // Minimum panel size
  const maxStructSize = 80; // Maximum panel size
  const calculatedStructSize = Math.floor(maxStructCanvasWidth / pw);
  const size = Math.max(minStructSize, Math.min(maxStructSize, calculatedStructSize));

  // Get panel type and calculate height ratio for CB5_MKII full panels
  const panelType = document.getElementById('panelType').value;
  const heightRatio = getPanelHeightRatio(panelType);
  const panelWidth = size;
  const panelHeight = size * heightRatio;

  // Check if CB5 half panel row is enabled - last row should be square
  const hasCB5HalfRow = cb5HalfRowEnabled && panelType === 'CB5_MKII';
  const originalPh = hasCB5HalfRow ? ph - 1 : ph;
  const halfPanelHeight = size; // Half panels are square

  const bumperHeight = Math.max(30, size * 0.8); // Scale bumper height with panel size
  const fourWayHeight = Math.max(15, size * 0.4); // Scale 4-way height with panel size
  const fourWayGap = 5; // Gap between 2W and 4W bumpers

  // Check if 4-way bumpers are enabled
  const use4Way = use4WayBumpersEnabled;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const has4WayBumpers = use4Way && isCB5;

  // Calculate canvas height - add space for bumpers and 4-way bumpers
  // Account for half panel row if enabled
  let canvasHeight = hasCB5HalfRow ? (originalPh * panelHeight + halfPanelHeight) : (ph * panelHeight);
  if(showTopBumper) {
    canvasHeight += bumperHeight;
    if(has4WayBumpers) canvasHeight += fourWayHeight + fourWayGap;
  }
  if(showBottomBumper) {
    canvasHeight += bumperHeight;
    if(has4WayBumpers) canvasHeight += fourWayHeight + fourWayGap;
  }

  canvas.width = pw * panelWidth;
  canvas.height = canvasHeight;

  // Update global panelSize for consistent sizing across all functions
  panelSize = size;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Fill entire canvas with dark background (same as deleted panels)
  ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const fontSize = Math.max(10, Math.floor(size * 0.22));
  ctx.font = `${fontSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Y offset for panels - leave space for top bumper and 4-way if enabled
  let panelYOffset = 0;
  if(showTopBumper) {
    panelYOffset += bumperHeight;
    if(has4WayBumpers) panelYOffset += fourWayHeight + fourWayGap;
  }

  // Draw all panels with black outline and labels
  for(let c=0;c<pw;c++){
    for(let r=0;r<ph;r++){
      const panelKey = `${c},${r}`;

      // Determine if this row is the half panel row
      const isHalfPanelRow = hasCB5HalfRow && r === originalPh;
      const currentPanelHeight = isHalfPanelRow ? halfPanelHeight : panelHeight;
      const x = c * panelWidth;
      const y = panelYOffset + (isHalfPanelRow ? (originalPh * panelHeight) : (r * panelHeight));

      // Skip deleted panels - they'll show the dark background
      if(deletedPanels.has(panelKey)) {
        // Draw dashed outline for deleted panels
        ctx.strokeStyle='#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, panelWidth, currentPanelHeight);
        ctx.setLineDash([]);
        continue;
      }

      // White background for panels
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, panelWidth, currentPanelHeight);

      // Black outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, panelWidth, currentPanelHeight);

      // Black label
      ctx.fillStyle = '#000000';
      ctx.fillText(`${c+1}.${r+1}`, x+panelWidth/2, y+currentPanelHeight/2);
    }
  }

  // Draw floor frames if this is a floor configuration
  const structureType = document.getElementById('structureType').value;
  if(structureType === 'floor' && p.is_floor_panel && p.floor_frames) {
    const frames = calculateFloorFrames(pw, ph, deletedPanels);
    const frameLineWidth = 4;

    // Draw each frame's outline
    frames.forEach(frame => {
      const frameX = frame.col * panelWidth;
      const frameY = panelYOffset + frame.row * panelHeight;
      const frameW = frame.width * panelWidth;
      const frameH = frame.height * panelHeight;

      // Get color for this frame type
      const color = floorFrameColors[frame.type] || '#ffffff';

      // Draw thick colored outline
      ctx.strokeStyle = color;
      ctx.lineWidth = frameLineWidth;
      ctx.strokeRect(frameX + frameLineWidth/2, frameY + frameLineWidth/2,
                     frameW - frameLineWidth, frameH - frameLineWidth);

      // Draw black outline around the colored one for visibility
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.strokeRect(frameX + 1, frameY + 1, frameW - 2, frameH - 2);
      ctx.strokeRect(frameX + frameLineWidth + 1, frameY + frameLineWidth + 1,
                     frameW - frameLineWidth * 2 - 2, frameH - frameLineWidth * 2 - 2);

      // Draw frame label in center
      const labelX = frameX + frameW / 2;
      const labelY = frameY + frameH / 2;
      const labelFontSize = Math.max(12, Math.floor(size * 0.3));

      // Draw label background
      ctx.font = `bold ${labelFontSize}px Arial`;
      const labelText = frame.name;
      const textMetrics = ctx.measureText(labelText);
      const labelPadding = 4;
      const bgWidth = textMetrics.width + labelPadding * 2;
      const bgHeight = labelFontSize + labelPadding * 2;

      ctx.fillStyle = color;
      ctx.fillRect(labelX - bgWidth/2, labelY - bgHeight/2, bgWidth, bgHeight);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.strokeRect(labelX - bgWidth/2, labelY - bgHeight/2, bgWidth, bgHeight);

      // Draw label text
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(labelText, labelX, labelY);
    });

    // Reset text alignment
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
  }

  // Draw connecting plates if enabled (reusing panelType from above)
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  
  if(useConnectingPlates) {
    const plateThickness = 4; // Thickness of plate indicator
    const plateLength = 12; // Length of 2-way plate indicator
    const plate4WaySize = 8; // Size of 4-way plate square
    
    // Determine if hanging (top bumpers) or ground stacking (bottom bumpers)
    const isHanging = showTopBumper;
    const isGroundStacking = showBottomBumper;
    
    // Draw 2-way plates (yellow) at perimeter intersections only
    
    // LEFT EDGE - vertical 2-way plates at panel joints
    for(let r = 0; r < ph - 1; r++) {
      const panelKey = `0,${r}`;
      const belowKey = `0,${r+1}`;
      if(!deletedPanels.has(panelKey) && !deletedPanels.has(belowKey)) {
        const x = 2; // Left edge
        const y = panelYOffset + (r + 1) * panelHeight - plateLength/2; // At the joint between panels

        ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }

    // RIGHT EDGE - vertical 2-way plates at panel joints
    for(let r = 0; r < ph - 1; r++) {
      const panelKey = `${pw-1},${r}`;
      const belowKey = `${pw-1},${r+1}`;
      if(!deletedPanels.has(panelKey) && !deletedPanels.has(belowKey)) {
        const x = pw * panelWidth - plateThickness - 2; // Right edge
        const y = panelYOffset + (r + 1) * panelHeight - plateLength/2; // At the joint between panels

        ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }

    // TOP EDGE (if ground stacking) - horizontal 2-way plates at panel joints
    if(isGroundStacking) {
      for(let c = 0; c < pw - 1; c++) {
        const panelKey = `${c},0`;
        const rightKey = `${c+1},0`;
        if(!deletedPanels.has(panelKey) && !deletedPanels.has(rightKey)) {
          const x = (c + 1) * panelWidth - plateLength/2; // At the joint between panels
          const y = panelYOffset + 2; // Top edge of panels

          ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
          ctx.fillRect(x, y, plateLength, plateThickness);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plateLength, plateThickness);
        }
      }
    }

    // BOTTOM EDGE (if hanging) - horizontal 2-way plates at panel joints
    if(isHanging) {
      for(let c = 0; c < pw - 1; c++) {
        const panelKey = `${c},${ph-1}`;
        const rightKey = `${c+1},${ph-1}`;
        if(!deletedPanels.has(panelKey) && !deletedPanels.has(rightKey)) {
          const x = (c + 1) * panelWidth - plateLength/2; // At the joint between panels
          const y = panelYOffset + ph * panelHeight - plateThickness - 2; // Bottom edge of panels

          ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
          ctx.fillRect(x, y, plateLength, plateThickness);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plateLength, plateThickness);
        }
      }
    }

    // CORNER 2-way plates connecting to bumpers
    // TOP-LEFT CORNER (if hanging)
    if(isHanging) {
      const topLeftKey = `0,0`;
      if(!deletedPanels.has(topLeftKey)) {
        // Horizontal plate at top-left
        const x = 2;
        const y = panelYOffset - plateThickness - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }

    // TOP-RIGHT CORNER (if hanging)
    if(isHanging) {
      const topRightKey = `${pw-1},0`;
      if(!deletedPanels.has(topRightKey)) {
        // Horizontal plate at top-right
        const x = pw * panelWidth - plateLength - 2;
        const y = panelYOffset - plateThickness - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }

    // BOTTOM-LEFT CORNER (if ground stacking)
    if(isGroundStacking) {
      const bottomLeftKey = `0,${ph-1}`;
      if(!deletedPanels.has(bottomLeftKey)) {
        // Horizontal plate at bottom-left
        const x = 2;
        const y = panelYOffset + ph * panelHeight + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }

    // BOTTOM-RIGHT CORNER (if ground stacking)
    if(isGroundStacking) {
      const bottomRightKey = `${pw-1},${ph-1}`;
      if(!deletedPanels.has(bottomRightKey)) {
        // Horizontal plate at bottom-right
        const x = pw * panelWidth - plateLength - 2;
        const y = panelYOffset + ph * panelHeight + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }
    
    // VERTICAL PLATES at edges where panels meet bumpers
    // TOP-LEFT vertical (if hanging)
    if(isHanging) {
      const topLeftKey = `0,0`;
      if(!deletedPanels.has(topLeftKey)) {
        const x = 2;
        const y = panelYOffset - plateLength/2 - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // TOP-RIGHT vertical (if hanging)
    if(isHanging) {
      const topRightKey = `${pw-1},0`;
      if(!deletedPanels.has(topRightKey)) {
        const x = pw * panelWidth - plateThickness - 2;
        const y = panelYOffset - plateLength/2 - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }

    // BOTTOM-LEFT vertical (if ground stacking)
    if(isGroundStacking) {
      const bottomLeftKey = `0,${ph-1}`;
      if(!deletedPanels.has(bottomLeftKey)) {
        const x = 2;
        const y = panelYOffset + ph * panelHeight - plateLength/2 + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }

    // BOTTOM-RIGHT vertical (if ground stacking)
    if(isGroundStacking) {
      const bottomRightKey = `${pw-1},${ph-1}`;
      if(!deletedPanels.has(bottomRightKey)) {
        const x = pw * panelWidth - plateThickness - 2;
        const y = panelYOffset + ph * panelHeight - plateLength/2 + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }

    // Draw 4-way plates (red) at interior panel intersections
    for(let c = 0; c < pw - 1; c++) {
      for(let r = 0; r < ph - 1; r++) {
        const topLeft = `${c},${r}`;
        const topRight = `${c+1},${r}`;
        const bottomLeft = `${c},${r+1}`;
        const bottomRight = `${c+1},${r+1}`;

        // Only draw if all 4 panels exist (not deleted)
        if(!deletedPanels.has(topLeft) && !deletedPanels.has(topRight) &&
           !deletedPanels.has(bottomLeft) && !deletedPanels.has(bottomRight)) {
          const x = (c + 1) * panelWidth - plate4WaySize/2;
          const y = panelYOffset + (r + 1) * panelHeight - plate4WaySize/2;

          ctx.fillStyle = '#FF4444'; // Red for 4-way
          ctx.fillRect(x, y, plate4WaySize, plate4WaySize);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plate4WaySize, plate4WaySize);
        }
      }
    }

    // Draw 4-way plates (red) connecting panels to TOP BUMPERS (if hanging)
    // Align with interior panel intersections (columns between panels)
    // Show for any panel type that has bumpers (CB5 with 4-way, or DM2.6, etc.)
    if(isHanging && (showTopBumper)) {
      for(let c = 0; c < pw - 1; c++) {
        const topLeftKey = `${c},0`;
        const topRightKey = `${c+1},0`;
        if(!deletedPanels.has(topLeftKey) && !deletedPanels.has(topRightKey)) {
          const x = (c + 1) * panelWidth - plate4WaySize/2; // Align with interior intersections
          const y = panelYOffset - plate4WaySize/2; // Between bumper and panel

          ctx.fillStyle = '#FF4444'; // Red for 4-way
          ctx.fillRect(x, y, plate4WaySize, plate4WaySize);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plate4WaySize, plate4WaySize);
        }
      }
    }

    // Draw 4-way plates (red) connecting panels to BOTTOM BUMPERS (if ground stacking)
    // Align with interior panel intersections (columns between panels)
    // Show for any panel type that has bumpers (CB5 with 4-way, or DM2.6, etc.)
    if(isGroundStacking && (showBottomBumper)) {
      for(let c = 0; c < pw - 1; c++) {
        const bottomLeftKey = `${c},${ph-1}`;
        const bottomRightKey = `${c+1},${ph-1}`;
        if(!deletedPanels.has(bottomLeftKey) && !deletedPanels.has(bottomRightKey)) {
          const x = (c + 1) * panelWidth - plate4WaySize/2; // Align with interior intersections
          const y = panelYOffset + ph * panelHeight - plate4WaySize/2; // Between panel and bumper

          ctx.fillStyle = '#FF4444'; // Red for 4-way
          ctx.fillRect(x, y, plate4WaySize, plate4WaySize);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plate4WaySize, plate4WaySize);
        }
      }
    }
  }
  
  // Initialize bumpers if not already done and not previously customized
  // Check bumpersInitialized flag from current screen data to respect user's bumper customizations
  const currentScreenData = screens[currentScreenId]?.data;
  const bumpersAlreadyInitialized = currentScreenData?.bumpersInitialized || false;
  if(bumpers.length === 0 && (showTopBumper || showBottomBumper) && !bumpersAlreadyInitialized) {
    initializeBumpers();
  }
  
  // Draw ground support hardware (bridge clamps and ladders) if ground stacking
  const isGroundStacking = showBottomBumper;
  // Track which bumpers have ladders (for drawing ladder bases)
  const bumpersWithLadders = new Set();

  // Check if CB5 panels with air frames - they don't need bridge clamps or rear truss
  const isCB5WithAirframes = (panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF') && connectionMethod === 'airframe';

  if(isGroundStacking) {
    const bridgeClampSize = 14; // Size of bridge clamp indicator
    const ladderWidth = 8; // Width of ladder piece
    const ladderHeightPanels = isCB5WithAirframes ? 1 : 2; // CB5 with airframes: 1 panel per ladder section, others: 2 panels

    // Get columns that have bottom bumpers (ladders are bound to bumpers)
    const columnsWithBumpers = new Set();
    const bumperToColumnMap = new Map(); // Map bumper id to its ladder column

    bumpers.filter(b => b.position === 'bottom').forEach(bumper => {
      // For bottom bumpers, get the columns they cover
      const cols = getBumperColumns(bumper);
      if(cols.length > 0) {
        // Check if bumper has a custom ladder column setting
        let ladderCol;
        if(bumper.type === '2w' && bumper.ladderColumn === 'right') {
          // Use the right (second) column
          ladderCol = cols[1] !== undefined ? cols[1] : cols[0];
        } else {
          // Default: use the left (first) column
          ladderCol = cols[0];
        }
        columnsWithBumpers.add(ladderCol);
        bumperToColumnMap.set(bumper.id, ladderCol);
        bumpersWithLadders.add(bumper.id);
      }
    });

    // Draw REAR LADDER (cyan) - only in columns with bumpers, centered horizontally
    // For CB5 with airframes: ladders extend full height (1 panel sections)
    // For others: Each ladder is 2 panels high, stacked from BOTTOM up
    ctx.fillStyle = '#00CED1'; // Cyan for ladder pieces

    columnsWithBumpers.forEach(c => {
      // Find the topmost and bottommost non-deleted panel in this column
      let topRow = -1;
      let bottomRow = -1;

      for(let r = 0; r < ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          if(topRow === -1) topRow = r;
          bottomRow = r;
        }
      }

      // Draw ladders if there are panels in this column
      if(topRow !== -1 && bottomRow !== -1) {
        const totalPanelsInColumn = bottomRow - topRow + 1;
        // For CB5 with airframes: draw full height ladder
        // For others: Only complete 2-panel sections get ladders (from bottom)
        const numLadders = isCB5WithAirframes ? totalPanelsInColumn : Math.floor(totalPanelsInColumn / ladderHeightPanels);

        // Draw each ladder piece from bottom to top
        for(let ladderIndex = 0; ladderIndex < numLadders; ladderIndex++) {
          // Calculate which rows this ladder covers (from bottom)
          const ladderBottomRow = bottomRow - (ladderIndex * ladderHeightPanels);
          const ladderTopRow = ladderBottomRow - ladderHeightPanels + 1;

          // Skip if ladder would be above the topmost panel
          if(ladderTopRow < topRow) continue;

          const ladderX = c * panelWidth + panelWidth/2 - ladderWidth/2; // Centered in column
          const ladderTopY = panelYOffset + ladderTopRow * panelHeight + 4;
          const ladderHeight = ladderHeightPanels * panelHeight - 8;

          // Draw ladder as a rounded rectangle
          ctx.fillStyle = '#00CED1'; // Cyan
          ctx.beginPath();
          ctx.roundRect(ladderX, ladderTopY, ladderWidth, ladderHeight, 2);
          ctx.fill();

          // Black outline
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Draw ladder rungs
          ctx.strokeStyle = '#008B8B'; // Darker cyan for rungs
          ctx.lineWidth = 1;
          const rungSpacing = panelHeight / 2;
          for(let y = ladderTopY + rungSpacing; y < ladderTopY + ladderHeight - 5; y += rungSpacing) {
            ctx.beginPath();
            ctx.moveTo(ladderX + 1, y);
            ctx.lineTo(ladderX + ladderWidth - 1, y);
            ctx.stroke();
          }
        }
      }
    });

    // Draw BRIDGE CLAMPS (purple) - only on columns with ladders (bound to bumpers)
    // Skip for CB5 with airframes - they don't need bridge clamps
    if(!isCB5WithAirframes) {
      // In center of panels, every 2nd row from bottom (2nd, 4th, 6th, etc.)
      ctx.fillStyle = '#9932CC'; // Purple for bridge clamps
      columnsWithBumpers.forEach(c => {
        // Start from 2nd row from bottom (index ph-2), then every 2nd row going up
        for(let r = ph - 2; r >= 0; r -= 2) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            // Draw bridge clamp as a filled circle at center of panel
            ctx.beginPath();
            ctx.arc(c * panelWidth + panelWidth/2, panelYOffset + r * panelHeight + panelHeight/2, bridgeClampSize/2, 0, Math.PI * 2);
            ctx.fill();

            // Black outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
        }
      });
    }
  }

  // Draw all bumpers and store their positions for interaction
  // Pass bumpersWithLadders so we can draw ladder bases inside bumpers
  drawAllBumpers(ctx, pw, ph, panelWidth, panelHeight, bumperHeight, fourWayHeight, fourWayGap, panelYOffset, bumpersWithLadders);
  
  // Update pickup weight summary
  updatePickupWeightSummary();
  
  // Setup interactivity for bumpers
  setupStructureCanvasInteractivity();
}

// Update the pickup weight summary display
function updatePickupWeightSummary() {
  const infoPanel = document.getElementById('structureInfoPanel');
  const weightsBox = document.getElementById('structureWeightsBox');
  const weightsContent = document.getElementById('structureWeightsContent');
  const structureType = document.getElementById('structureType').value;

  if(!infoPanel || !weightsContent) return;

  // For floor mode, skip bumper display but still show floor frames
  if(structureType === 'floor') {
    weightsBox.style.display = 'none';
    infoPanel.style.display = 'grid';
    // Update floor frames display (will also update plates and ground support)
    updateStructurePlatesDisplay();
    return;
  }

  if(bumpers.length === 0) {
    infoPanel.style.display = 'none';
    return;
  }

  // Show the info panel and weights box
  weightsBox.style.display = 'block';
  infoPanel.style.display = 'grid';
  
  // Group bumpers by position
  const topBumpers = bumpers.filter(b => b.position === 'top');
  const bottomBumpers = bumpers.filter(b => b.position === 'bottom');
  
  // Helper function to check if a 2W bumper is under a 4W bumper
  function is2wUnder4w(bumper2w, position) {
    const fourWayBumpers = bumpers.filter(b => b.type === '4w' && b.position === position);
    for(const b4w of fourWayBumpers) {
      // 4W startCol/endCol are the centers of the 2W bumpers it connects
      // First 2W covers columns (startCol-1) to startCol
      // Second 2W covers columns (endCol-1) to endCol
      const col4wStart = b4w.startCol - 1;
      const col4wEnd = b4w.endCol;
      
      // Check if this 2W's columns are within the 4W's range
      if(bumper2w.startCol >= col4wStart && bumper2w.endCol <= col4wEnd) {
        return true;
      }
    }
    return false;
  }
  
  const wtUnit = getWeightUnitLabel();
  let html = '';
  let totalWeightKg = 0;
  
  // Show ALL top bumpers (but skip 2W bumpers that are under 4W bumpers)
  if(topBumpers.length > 0) {
    // Sort by type: 4W first, then 2W, then 1W
    const sortedTop = [...topBumpers].sort((a, b) => {
      const order = { '4w': 0, '2w': 1, '1w': 2 };
      return order[a.type] - order[b.type];
    });
    
    // Count by type for numbering
    const counts = { '4w': 0, '2w': 0, '1w': 0 };
    
    sortedTop.forEach((bumper) => {
      // Skip 2W bumpers that are under a 4W bumper (they're not pickup points)
      if(bumper.type === '2w' && is2wUnder4w(bumper, 'top')) {
        return; // Skip this bumper
      }
      
      counts[bumper.type]++;
      const weight = calculateBumperPickupWeight(bumper);
      totalWeightKg += weight.kg;
      const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
      const color = bumper.type === '4w' ? '#FF6B35' : bumper.type === '2w' ? '#4CAF50' : '#2196F3';
      const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
      html += `<div class="weight-row">
        <span class="weight-label" style="color: ${color};">${label} #${counts[bumper.type]}</span>
        <span class="weight-value">${weightDisplay} ${wtUnit}</span>
      </div>`;
    });
  }
  
  // Show ALL bottom bumpers (ground stacking) - skip 2W bumpers under 4W
  if(bottomBumpers.length > 0) {
    if(topBumpers.length > 0 && html.length > 0) {
      html += '<div style="border-top: 1px solid #444; margin: 6px 0;"></div>';
    }
    
    // Sort by type: 4W first, then 2W, then 1W
    const sortedBottom = [...bottomBumpers].sort((a, b) => {
      const order = { '4w': 0, '2w': 1, '1w': 2 };
      return order[a.type] - order[b.type];
    });
    
    // Count by type for numbering
    const counts = { '4w': 0, '2w': 0, '1w': 0 };
    
    sortedBottom.forEach((bumper) => {
      // Skip 2W bumpers that are under a 4W bumper (they're not pickup points)
      if(bumper.type === '2w' && is2wUnder4w(bumper, 'bottom')) {
        return; // Skip this bumper
      }
      
      counts[bumper.type]++;
      const weight = calculateBumperPickupWeight(bumper);
      totalWeightKg += weight.kg;
      const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
      const color = bumper.type === '4w' ? '#FF6B35' : bumper.type === '2w' ? '#FF9800' : '#2196F3';
      const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
      html += `<div class="weight-row">
        <span class="weight-label" style="color: ${color};">${label} #${counts[bumper.type]}</span>
        <span class="weight-value">${weightDisplay} ${wtUnit}</span>
      </div>`;
    });
  }
  
  // Add total
  const totalDisplay = displayWeightUnit === 'lbs' ? (totalWeightKg * KG_TO_LBS).toFixed(0) : totalWeightKg.toFixed(0);
  html += `<div class="weight-row" style="border-top: 1px solid #4a9eff; margin-top: 6px; padding-top: 6px;">
    <span class="weight-label" style="color: #fff;">Total</span>
    <span class="weight-value" style="color: #4a9eff;">${totalDisplay} ${wtUnit}</span>
  </div>`;
  
  weightsContent.innerHTML = html;
  
  // Also update the plates display in the same panel
  updateStructurePlatesDisplay();
}

// Update the connecting plates display in the structure info panel
function updateStructurePlatesDisplay() {
  const platesBox = document.getElementById('structurePlatesBox');
  const platesContent = document.getElementById('structurePlatesContent');
  
  if(!platesBox || !platesContent) return;
  
  const panelType = document.getElementById('panelType').value;
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  // Initialize plates data for storage
  let platesData = { total2way: 0, total4way: 0, totalPlateWeight: 0 };
  
  if(!useConnectingPlates || pw === 0 || ph === 0) {
    platesBox.style.display = 'none';
  } else {
    // Plate weights in kg
    const plate2wayKg = 0.141; // 0.31 lbs
    const plate4wayKg = 0.249; // 0.55 lbs
    
    const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
    platesData = plates; // Store the calculated values
    
    const wtUnit = getWeightUnitLabel();
    const weightDisplay = displayWeightUnit === 'lbs' 
      ? (plates.totalPlateWeight * KG_TO_LBS).toFixed(1) 
      : plates.totalPlateWeight.toFixed(1);
    
    let html = '';
    
    html += `<div class="plates-row">
      <span class="plates-label">2-Way (yellow)</span>
      <span class="plates-value">${plates.total2way}</span>
    </div>`;
    
    html += `<div class="plates-row">
      <span class="plates-label">4-Way (red)</span>
      <span class="plates-value">${plates.total4way}</span>
    </div>`;
    
    html += `<div class="plates-row plates-total">
      <span class="plates-label" style="color: #fff;">Total Weight</span>
      <span class="plates-value" style="color: #6fc276;">${weightDisplay} ${wtUnit}</span>
    </div>`;
    
    platesContent.innerHTML = html;
    platesBox.style.display = 'block';
  }
  
  // Store plates data for gear list
  if(screens[currentScreenId]) {
    if(!screens[currentScreenId].calculatedData) {
      screens[currentScreenId].calculatedData = {};
    }
    screens[currentScreenId].calculatedData.plates2way = platesData.total2way;
    screens[currentScreenId].calculatedData.plates4way = platesData.total4way;
    screens[currentScreenId].calculatedData.platesWeightKg = platesData.totalPlateWeight;
  }
  
  // Also update ground support hardware display
  updateGroundSupportDisplay();
}

// Update the ground support hardware display (ladders and bridge clamps)
function updateGroundSupportDisplay() {
  const groundSupportBox = document.getElementById('structureGroundSupportBox');
  const groundSupportContent = document.getElementById('structureGroundSupportContent');
  
  if(!groundSupportBox || !groundSupportContent) return;
  
  const isGroundStacking = showBottomBumper;
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  // Initialize ground support data for storage
  let groundSupportData = {
    totalRearTruss: 0,
    totalBaseTruss: 0,
    totalBridgeClamps: 0,
    totalRearBridgeClampAdapters: 0,
    totalPipes: 0,
    totalSwivelCheeseboroughs: 0,
    totalSandbags: 0,
    totalWeightKg: 0,
    totalWeightLbs: 0,
    pipeInfo: []
  };
  
  if(!isGroundStacking || pw === 0 || ph === 0) {
    groundSupportBox.style.display = 'none';
    // Store empty ground support data
    if(screens[currentScreenId]) {
      if(!screens[currentScreenId].calculatedData) {
        screens[currentScreenId].calculatedData = {};
      }
      screens[currentScreenId].calculatedData.groundSupport = groundSupportData;
      screens[currentScreenId].calculatedData.groundSupportWeightKg = 0;
    }
    updateFloorFramesDisplay(); // Continue chain to floor frames then total weight
    return;
  }
  
  // Calculate ground support hardware
  const hardware = calculateGroundSupportHardware(pw, ph);
  groundSupportData = hardware; // Store calculated values
  
  // Store ground support data for gear list
  if(screens[currentScreenId]) {
    if(!screens[currentScreenId].calculatedData) {
      screens[currentScreenId].calculatedData = {};
    }
    screens[currentScreenId].calculatedData.groundSupport = groundSupportData;
    screens[currentScreenId].calculatedData.groundSupportWeightKg = hardware.totalWeightKg || 0;
  }

  // Hide ground support box if nothing to show
  const hasAnyHardware = hardware.totalRearTruss > 0 || hardware.totalBridgeClamps > 0 ||
                         hardware.totalBaseTruss > 0 || hardware.totalSandbags > 0 ||
                         hardware.totalPipes > 0 || hardware.totalSwivelCheeseboroughs > 0 ||
                         hardware.totalRearBridgeClampAdapters > 0;
  if(!hasAnyHardware) {
    groundSupportBox.style.display = 'none';
    updateFloorFramesDisplay(); // Continue chain to floor frames then total weight
    return;
  }
  
  const wtUnit = getWeightUnitLabel();
  let html = '';

  if(hardware.totalRearTruss > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Rear Truss</span>
      <span class="plates-value">${hardware.totalRearTruss}</span>
    </div>`;
  }

  if(hardware.totalBaseTruss > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Base Truss</span>
      <span class="plates-value">${hardware.totalBaseTruss}</span>
    </div>`;
  }

  if(hardware.totalBridgeClamps > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Bridge Clamps</span>
      <span class="plates-value">${hardware.totalBridgeClamps}</span>
    </div>`;
  }
  
  if(hardware.totalRearBridgeClampAdapters > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Rear Bridge Clamp Adapter</span>
      <span class="plates-value">${hardware.totalRearBridgeClampAdapters}</span>
    </div>`;
  }
  
  if(hardware.totalPipes > 0) {
    // Show pipe count with unique length(s)
    const uniqueLengths = [...new Set(hardware.pipeInfo.map(p => p.pipeLengthFt))];
    const pipeLengthStr = uniqueLengths.map(l => l + 'ft').join(', ');
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Pipe (${pipeLengthStr})</span>
      <span class="plates-value">${hardware.totalPipes}</span>
    </div>`;
  }
  
  if(hardware.totalSwivelCheeseboroughs > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Swivel Cheeseborough</span>
      <span class="plates-value">${hardware.totalSwivelCheeseboroughs}</span>
    </div>`;
  }
  
  html += `<div class="plates-row">
    <span class="plates-label" style="color: #ffffff;">Sandbags (25lb)</span>
    <span class="plates-value">${hardware.totalSandbags}</span>
  </div>`;
  
  // Add total weight
  const totalWeightDisplay = displayWeightUnit === 'lbs' 
    ? hardware.totalWeightLbs.toFixed(1) 
    : hardware.totalWeightKg.toFixed(1);
  
  html += `<div class="plates-row plates-total" style="border-top: 1px solid #00CED1; margin-top: 6px; padding-top: 6px;">
    <span class="plates-label" style="color: #fff;">Total Weight</span>
    <span class="plates-value" style="color: #00CED1;">${totalWeightDisplay} ${wtUnit}</span>
  </div>`;
  
  groundSupportContent.innerHTML = html;
  groundSupportBox.style.display = 'block';

  // Update floor frames display
  updateFloorFramesDisplay();
}

// Update the floor frames display
function updateFloorFramesDisplay() {
  const floorFramesBox = document.getElementById('structureFloorFramesBox');
  const floorFramesContent = document.getElementById('structureFloorFramesContent');
  const structureType = document.getElementById('structureType').value;

  if(!floorFramesBox || !floorFramesContent) {
    updateTotalStructureWeight();
    return;
  }

  const panelType = document.getElementById('panelType').value;
  const allPanels = getAllPanels();
  const p = allPanels[panelType];
  const {pw, ph} = getEffectivePanelCountsForLayout();

  // Initialize floor frames data for storage
  let floorFramesData = {
    frame_1x1: 0,
    frame_2x1: 0,
    frame_2x2: 0,
    frame_3x2: 0,
    totalWeightLbs: 0,
    totalWeightKg: 0
  };

  // Only show for floor mode with floor panels
  if(structureType !== 'floor' || !p || !p.is_floor_panel || !p.floor_frames || pw === 0 || ph === 0) {
    floorFramesBox.style.display = 'none';
    // Store empty floor frames data
    if(screens[currentScreenId]) {
      if(!screens[currentScreenId].calculatedData) {
        screens[currentScreenId].calculatedData = {};
      }
      screens[currentScreenId].calculatedData.floorFrames = floorFramesData;
    }
    updateTotalStructureWeight();
    return;
  }

  // Calculate floor frames
  const frames = calculateFloorFrames(pw, ph, deletedPanels);
  const frameCounts = getFloorFrameCounts(frames);

  // Calculate total weight
  let totalWeightLbs = 0;
  if(frameCounts.frame_1x1 > 0 && p.floor_frames.frame_1x1) {
    totalWeightLbs += frameCounts.frame_1x1 * p.floor_frames.frame_1x1.weight_lbs;
  }
  if(frameCounts.frame_2x1 > 0 && p.floor_frames.frame_2x1) {
    totalWeightLbs += frameCounts.frame_2x1 * p.floor_frames.frame_2x1.weight_lbs;
  }
  if(frameCounts.frame_2x2 > 0 && p.floor_frames.frame_2x2) {
    totalWeightLbs += frameCounts.frame_2x2 * p.floor_frames.frame_2x2.weight_lbs;
  }
  if(frameCounts.frame_3x2 > 0 && p.floor_frames.frame_3x2) {
    totalWeightLbs += frameCounts.frame_3x2 * p.floor_frames.frame_3x2.weight_lbs;
  }

  const totalWeightKg = totalWeightLbs / KG_TO_LBS;

  // Store floor frames data
  floorFramesData = {
    ...frameCounts,
    totalWeightLbs: totalWeightLbs,
    totalWeightKg: totalWeightKg
  };

  if(screens[currentScreenId]) {
    if(!screens[currentScreenId].calculatedData) {
      screens[currentScreenId].calculatedData = {};
    }
    screens[currentScreenId].calculatedData.floorFrames = floorFramesData;
  }

  // Build display HTML
  const wtUnit = getWeightUnitLabel();
  let html = '';

  // Show counts for each frame type with their colors
  if(frameCounts.frame_3x2 > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: ${floorFrameColors.frame_3x2};">3×2 Frame</span>
      <span class="plates-value">${frameCounts.frame_3x2}</span>
    </div>`;
  }
  if(frameCounts.frame_2x2 > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: ${floorFrameColors.frame_2x2};">2×2 Frame</span>
      <span class="plates-value">${frameCounts.frame_2x2}</span>
    </div>`;
  }
  if(frameCounts.frame_2x1 > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: ${floorFrameColors.frame_2x1};">2×1 Frame</span>
      <span class="plates-value">${frameCounts.frame_2x1}</span>
    </div>`;
  }
  if(frameCounts.frame_1x1 > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: ${floorFrameColors.frame_1x1};">1×1 Frame</span>
      <span class="plates-value">${frameCounts.frame_1x1}</span>
    </div>`;
  }

  // Add total weight
  const totalWeightDisplay = displayWeightUnit === 'lbs'
    ? totalWeightLbs.toFixed(1)
    : totalWeightKg.toFixed(1);

  html += `<div class="plates-row plates-total" style="border-top: 1px solid #4ecdc4; margin-top: 6px; padding-top: 6px;">
    <span class="plates-label" style="color: #fff;">Total Weight</span>
    <span class="plates-value" style="color: #4ecdc4;">${totalWeightDisplay} ${wtUnit}</span>
  </div>`;

  floorFramesContent.innerHTML = html;
  floorFramesBox.style.display = 'block';

  // Update total structure weight
  updateTotalStructureWeight();
}

// Update the total structure weight display (sum of pickup weights + plates + ground support)
function updateTotalStructureWeight() {
  const totalWeightBox = document.getElementById('structureTotalWeightBox');
  const totalWeightContent = document.getElementById('structureTotalWeightContent');
  
  if(!totalWeightBox || !totalWeightContent) return;
  
  // Helper function to check if a 2W bumper is under a 4W bumper
  function is2wUnder4w(bumper2w) {
    const fourWayBumpers = bumpers.filter(b => b.type === '4w' && b.position === bumper2w.position);
    for(const b4w of fourWayBumpers) {
      const col4wStart = b4w.startCol - 1;
      const col4wEnd = b4w.endCol;
      if(bumper2w.startCol >= col4wStart && bumper2w.endCol <= col4wEnd) {
        return true;
      }
    }
    return false;
  }
  
  // Calculate connecting plates weight
  let platesWeightKg = 0;
  const panelType = document.getElementById('panelType').value;
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const {pw, ph} = getEffectivePanelCountsForLayout();

  // Calculate bumper hardware weight (the actual weight of bumper hardware, not load being supported)
  const bumperHardwareWeightKg = calculateTotalBumperWeight(pw, ph);
  
  if(useConnectingPlates && pw > 0 && ph > 0) {
    const plate2wayKg = 0.141;
    const plate4wayKg = 0.249;
    const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
    platesWeightKg = plates.totalPlateWeight || 0;
  }
  
  // Calculate ground support hardware weight
  let groundSupportWeightKg = 0;
  const isGroundStacking = showBottomBumper;

  if(isGroundStacking && pw > 0 && ph > 0) {
    const hardware = calculateGroundSupportHardware(pw, ph);
    groundSupportWeightKg = hardware.totalWeightKg || 0;
  }

  // Calculate floor frames weight
  let floorFramesWeightKg = 0;
  const structureType = document.getElementById('structureType').value;
  const allPanels = getAllPanels();
  const p = allPanels[panelType];

  if(structureType === 'floor' && p && p.is_floor_panel && p.floor_frames && pw > 0 && ph > 0) {
    const frames = calculateFloorFrames(pw, ph, deletedPanels);
    const frameCounts = getFloorFrameCounts(frames);
    let totalWeightLbs = 0;
    if(frameCounts.frame_1x1 > 0 && p.floor_frames.frame_1x1) {
      totalWeightLbs += frameCounts.frame_1x1 * p.floor_frames.frame_1x1.weight_lbs;
    }
    if(frameCounts.frame_2x1 > 0 && p.floor_frames.frame_2x1) {
      totalWeightLbs += frameCounts.frame_2x1 * p.floor_frames.frame_2x1.weight_lbs;
    }
    if(frameCounts.frame_2x2 > 0 && p.floor_frames.frame_2x2) {
      totalWeightLbs += frameCounts.frame_2x2 * p.floor_frames.frame_2x2.weight_lbs;
    }
    if(frameCounts.frame_3x2 > 0 && p.floor_frames.frame_3x2) {
      totalWeightLbs += frameCounts.frame_3x2 * p.floor_frames.frame_3x2.weight_lbs;
    }
    floorFramesWeightKg = totalWeightLbs / KG_TO_LBS;
  }

  // Calculate total structure hardware weight
  const totalWeightKg = bumperHardwareWeightKg + platesWeightKg + groundSupportWeightKg + floorFramesWeightKg;

  // Only show if there's something to display
  const isFloorMode = structureType === 'floor';
  if(totalWeightKg === 0 && bumpers.length === 0 && !isFloorMode) {
    totalWeightBox.style.display = 'none';
    return;
  }
  
  const wtUnit = getWeightUnitLabel();
  const totalWeightLbs = totalWeightKg * KG_TO_LBS;

  let html = '';

  // Show breakdown - skip bumpers for floor mode
  if(!isFloorMode && bumperHardwareWeightKg > 0) {
    const bumperDisplay = displayWeightUnit === 'lbs'
      ? (bumperHardwareWeightKg * KG_TO_LBS).toFixed(1)
      : bumperHardwareWeightKg.toFixed(1);
    html += `<div class="weight-row">
      <span class="weight-label" style="color: #4a9eff;">Bumpers</span>
      <span class="weight-value">${bumperDisplay} ${wtUnit}</span>
    </div>`;
  }

  if(platesWeightKg > 0) {
    const platesDisplay = displayWeightUnit === 'lbs'
      ? (platesWeightKg * KG_TO_LBS).toFixed(1)
      : platesWeightKg.toFixed(1);
    html += `<div class="weight-row">
      <span class="weight-label" style="color: #6fc276;">Connecting Plates</span>
      <span class="weight-value">${platesDisplay} ${wtUnit}</span>
    </div>`;
  }

  if(groundSupportWeightKg > 0) {
    const gsDisplay = displayWeightUnit === 'lbs'
      ? (groundSupportWeightKg * KG_TO_LBS).toFixed(1)
      : groundSupportWeightKg.toFixed(1);
    html += `<div class="weight-row">
      <span class="weight-label" style="color: #00CED1;">Ground Support</span>
      <span class="weight-value">${gsDisplay} ${wtUnit}</span>
    </div>`;
  }

  if(floorFramesWeightKg > 0) {
    const floorDisplay = displayWeightUnit === 'lbs'
      ? (floorFramesWeightKg * KG_TO_LBS).toFixed(1)
      : floorFramesWeightKg.toFixed(1);
    html += `<div class="weight-row">
      <span class="weight-label" style="color: #4ecdc4;">Floor Frames</span>
      <span class="weight-value">${floorDisplay} ${wtUnit}</span>
    </div>`;
  }

  // Total
  const totalDisplay = displayWeightUnit === 'lbs'
    ? totalWeightLbs.toFixed(0)
    : totalWeightKg.toFixed(0);
  html += `<div class="weight-row" style="border-top: 1px solid #FFD700; margin-top: 6px; padding-top: 6px;">
    <span class="weight-label" style="color: #fff; font-weight: bold;">TOTAL</span>
    <span class="weight-value" style="color: #FFD700; font-weight: bold;">${totalDisplay} ${wtUnit}</span>
  </div>`;
  
  totalWeightContent.innerHTML = html;
  totalWeightBox.style.display = 'block';
}

// Calculate ground support hardware counts
function calculateGroundSupportHardware(pw, ph) {
  const ladderHeightPanels = 2;
  const maxPanelsBeforeSecondBase = 8; // If more than 8 panels high, add 2nd base
  
  // Hardware weights in lbs
  const weights = {
    rearTruss: 10.1,          // per rear truss piece (1000mm)
    baseTruss: 28.2,          // per base truss (1000mm)
    bridgeClamp: 2.2,         // per bridge clamp
    rearBridgeClampAdapter: 1.1, // per adapter (DM2.6 only)
    pipe: 5.0,                // per pipe
    swivelCheeseborough: 1.2, // per swivel cheeseborough
    sandbag: 25.0             // per sandbag (25lb sandbags)
  };
  
  let totalRearTruss = 0;
  let totalBridgeClamps = 0;
  let totalBaseTruss = 0;
  let totalSecondBases = 0; // Additional bases for tall walls
  let totalPipes = 0; // Pipes from top truss to 2nd base
  let totalSwivelCheeseboroughs = 0; // 2 per pipe
  let totalSandbags = 0;
  let totalRearBridgeClampAdapters = 0; // For DM2.6 only, 1 per bridge clamp
  
  const panelType = document.getElementById('panelType').value;
  const isDM26 = panelType === 'DM2_6';

  // Check if CB5 panels with air frames - they don't need rear truss or bridge clamps
  const isCB5WithAirframes = (panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF') && connectionMethod === 'airframe';

  // Track bumpers and their ladder columns for sandbag calculation
  const bumperLadderInfo = []; // {bumper, ladderCol, panelsInColumn}
  
  // Track pipe lengths for columns that need them
  const pipeInfo = []; // {column, rearTrussCount, pipeLengthFt}
  
  // Get columns that have bottom bumpers (ladders are bound to bumpers)
  const columnsWithBumpers = new Set();
  
  bumpers.filter(b => b.position === 'bottom').forEach(bumper => {
    const cols = getBumperColumns(bumper);
    if(cols.length > 0) {
      // Check if bumper has a custom ladder column setting
      let ladderCol;
      if(bumper.type === '2w' && bumper.ladderColumn === 'right') {
        ladderCol = cols[1] !== undefined ? cols[1] : cols[0];
      } else {
        ladderCol = cols[0];
      }
      columnsWithBumpers.add(ladderCol);
      bumperLadderInfo.push({ bumper, ladderCol });
    }
  });
  
  // Count items per column
  columnsWithBumpers.forEach(c => {
    let topRow = -1;
    let bottomRow = -1;
    
    for(let r = 0; r < ph; r++) {
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey)) {
        if(topRow === -1) topRow = r;
        bottomRow = r;
      }
    }
    
    if(topRow !== -1 && bottomRow !== -1) {
      const totalPanelsInColumn = bottomRow - topRow + 1;
      const numTruss = Math.floor(totalPanelsInColumn / ladderHeightPanels);
      // CB5 with airframes don't need rear truss
      if(!isCB5WithAirframes) {
        totalRearTruss += numTruss;
      }
      
      // Check if we need a second base (more than 8 panels high)
      if(totalPanelsInColumn > maxPanelsBeforeSecondBase) {
        totalSecondBases++;
        totalPipes++; // 1 pipe per second base
        totalSwivelCheeseboroughs += 2; // 2 swivel cheeseboroughs per pipe
        
        // Calculate pipe length using Pythagorean theorem
        // Pipe goes diagonally from top rear truss to 2nd base truss
        // Each rear truss is 1000mm (1m) = 3.28 ft
        // Horizontal distance (base) = 2m = 6.56 ft
        // Vertical height = number of rear truss * 3.28 ft
        const horizontalDistFt = 6.56; // 2 meters in feet
        const verticalHeightFt = numTruss * 3.28; // Each truss is 1m = 3.28ft
        const diagonalFt = Math.sqrt(Math.pow(horizontalDistFt, 2) + Math.pow(verticalHeightFt, 2));
        const pipeLengthFt = Math.floor(diagonalFt); // Round down
        
        // Store pipe length info
        pipeInfo.push({
          column: c,
          rearTrussCount: numTruss,
          pipeLengthFt: pipeLengthFt
        });
      }
      
      // Store panel count for this column for sandbag calculation
      const info = bumperLadderInfo.find(bi => bi.ladderCol === c);
      if(info) {
        info.panelsInColumn = totalPanelsInColumn;
      }
    }
  });
  
  // Base truss = columns with bumpers (1 per column)
  // Plus second bases for tall walls
  totalBaseTruss = columnsWithBumpers.size + totalSecondBases;
  
  // Count bridge clamps - every 2nd row from bottom, only in columns with ladders
  // Skip for CB5 with airframes - they don't need bridge clamps
  if(!isCB5WithAirframes) {
    columnsWithBumpers.forEach(c => {
      for(let r = ph - 2; r >= 0; r -= 2) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          totalBridgeClamps++;
        }
      }
    });
  }

  // Rear bridge clamp adapters for DM2.6 only (1 per bridge clamp)
  if(isDM26) {
    totalRearBridgeClampAdapters = totalBridgeClamps;
  }
  
  // Calculate sandbags: ((total weight of bumper) / 25lbs) x 1.25 = sandbags per column
  // Round up to nearest whole sandbag
  bumperLadderInfo.forEach(info => {
    const bumperWeight = calculateBumperPickupWeight(info.bumper);
    const weightLbs = bumperWeight.lbs;
    const sandbagWeight = 25; // lbs per sandbag
    const sandbagMultiplier = 1.25;
    const sandbagCount = Math.ceil((weightLbs / sandbagWeight) * sandbagMultiplier);
    totalSandbags += sandbagCount;
  });
  
  // Calculate total weight of all ground support hardware
  const totalWeightLbs = 
    (totalRearTruss * weights.rearTruss) +
    (totalBaseTruss * weights.baseTruss) +
    (totalBridgeClamps * weights.bridgeClamp) +
    (totalRearBridgeClampAdapters * weights.rearBridgeClampAdapter) +
    (totalPipes * weights.pipe) +
    (totalSwivelCheeseboroughs * weights.swivelCheeseborough) +
    (totalSandbags * weights.sandbag);
  
  const totalWeightKg = totalWeightLbs / KG_TO_LBS;
  
  return {
    totalRearTruss,
    totalBridgeClamps,
    totalBaseTruss,
    totalPipes,
    totalSwivelCheeseboroughs,
    totalSandbags,
    totalRearBridgeClampAdapters,
    totalWeightLbs,
    totalWeightKg,
    pipeInfo // Array of {column, rearTrussCount, pipeLengthFt}
  };
}

// Draw all bumpers from the bumpers array
function drawAllBumpers(ctx, pw, ph, panelWidth, panelHeight, bumperHeight, fourWayHeight, fourWayGap, panelYOffset, bumpersWithLadders = new Set()) {
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';

  ctx.font = 'bold 10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Draw each bumper
  bumpers.forEach(bumper => {
    let x, y, width, height;
    let label = '';
    let fillColor = '';

    if(bumper.type === '4w') {
      // 4-way bumper - spans from center of one 2W to center of next 2W
      // startCol and endCol are already the column positions (centers of 2W bumpers)
      const col1 = bumper.startCol;
      const col2 = bumper.endCol;

      x = col1 * panelWidth;  // Start at column 1, 5, 9... (centers of 2W bumpers)
      width = (col2 - col1) * panelWidth;  // Width of 2 columns
      height = fourWayHeight;

      if(bumper.position === 'top') {
        // 4W bumpers stay at top (they connect to the 2W bumpers which drop down)
        y = 0;
      } else {
        y = panelYOffset + (ph * panelHeight) + bumperHeight + fourWayGap;
      }

      fillColor = greyscalePrintMode ? toGreyscale('#FF6B35') : (ecoPrintMode ? toPastelColor('#FF6B35') : '#FF6B35'); // Orange
      label = '4W';

    } else if(bumper.type === '2w') {
      // 2-way bumper - spans 2 columns
      const col = bumper.startCol;
      x = col * panelWidth;
      width = panelWidth * 2; // Span 2 columns
      height = bumperHeight;

      if(bumper.position === 'top') {
        // For hanging bumpers, drop down to the first non-deleted row
        // Check both columns covered by this 2W bumpers
        const row1 = getFirstNonDeletedRow(col, ph);
        const row2 = getFirstNonDeletedRow(col + 1, ph);
        const maxRow = Math.max(row1, row2); // Use the deeper one so bumper sits on both

        const baseY = use4Way && isCB5 ? (fourWayHeight + fourWayGap) : 0;
        y = baseY + (maxRow * panelHeight); // Drop down by the number of deleted rows
      } else {
        y = panelYOffset + (ph * panelHeight);
      }

      fillColor = greyscalePrintMode ? toGreyscale('#4CAF50') : (ecoPrintMode ? toPastelColor('#4CAF50') : '#4CAF50'); // Green for top, orange for bottom
      if(bumper.position === 'bottom') {
        fillColor = greyscalePrintMode ? toGreyscale('#FF9800') : (ecoPrintMode ? toPastelColor('#FF9800') : '#FF9800');
      }
      label = '2W';

    } else if(bumper.type === '1w') {
      // 1-way bumper - spans 1 column
      const col = bumper.startCol;
      x = col * panelWidth;
      width = panelWidth; // Span 1 column
      height = bumperHeight;

      if(bumper.position === 'top') {
        // For hanging bumpers, drop down to the first non-deleted row
        const firstRow = getFirstNonDeletedRow(col, ph);

        const baseY = use4Way && isCB5 ? (fourWayHeight + fourWayGap) : 0;
        y = baseY + (firstRow * panelHeight); // Drop down by the number of deleted rows
      } else {
        y = panelYOffset + (ph * panelHeight);
      }

      fillColor = greyscalePrintMode ? toGreyscale('#2196F3') : (ecoPrintMode ? toPastelColor('#2196F3') : '#2196F3'); // Blue for 1W
      label = '1W';
    }

    // Store position for interaction
    bumper.x = x;
    bumper.y = y;
    bumper.width = width;
    bumper.height = height;

    // Draw bumper
    ctx.fillStyle = fillColor;
    ctx.fillRect(x, y, width, height);

    // Draw LADDER BASE (dark blue) inside bumpers that have ladders
    // Only for bottom bumpers (ground support)
    // Position under the column where the ladder is (respects ladderColumn setting)
    if(bumper.position === 'bottom' && bumpersWithLadders.has(bumper.id)) {
      const ladderBaseWidth = panelWidth * 0.85; // Slightly less than panel width
      const ladderBaseHeight = 10; // Height of ladder base

      // Determine which column the ladder is in
      let ladderColOffset = 0; // Default: first column (left)
      if(bumper.type === '2w' && bumper.ladderColumn === 'right') {
        ladderColOffset = panelWidth; // Move to second column (right)
      }

      // Position under the correct column
      const ladderBaseX = x + ladderColOffset + (panelWidth - ladderBaseWidth) / 2;
      const ladderBaseY = y + (height - ladderBaseHeight) / 2; // Centered vertically in bumper
      
      // Draw ladder base rectangle
      ctx.fillStyle = '#00008B'; // Dark blue
      ctx.beginPath();
      ctx.roundRect(ladderBaseX, ladderBaseY, ladderBaseWidth, ladderBaseHeight, 3);
      ctx.fill();
      
      // Black outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Check if bumper is selected (manual mode uses selectedBumpers set)
    const isBumperSelected = (manualBumperMode && selectedBumpers.has(bumper.id)) || 
                              (selectedBumper && selectedBumper.id === bumper.id);
    
    // Add selection highlight
    if(isBumperSelected) {
      ctx.strokeStyle = '#00FF00';
      ctx.lineWidth = 3;
      ctx.strokeRect(x + 2, y + 2, width - 4, height - 4);
    }
    
    // Add hover highlight (only in manual mode)
    if(manualBumperMode && hoveredBumper && hoveredBumper.id === bumper.id && !isBumperSelected) {
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);
      ctx.setLineDash([]);
    }
    
    // Draw border
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, width, height);
    
    // Calculate weight at center point of this bumper
    const pickupWeight = calculateBumperPickupWeight(bumper);

    // Draw label with weight
    ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#000000' : '#FFFFFF';

    // For small bumpers (especially 4W on mobile), only show weight
    // Check if height is too small for both label and weight
    const isMobile = window.innerWidth <= 768;
    const isSmallBumper = height < 25;

    if(isSmallBumper || (isMobile && bumper.type === '4w')) {
      // Only show weight (centered)
      ctx.font = 'bold 9px Arial';
      const weightValue = displayWeightUnit === 'lbs' ? pickupWeight.lbs.toFixed(0) : pickupWeight.kg.toFixed(0);
      const weightText = `${weightValue}${displayWeightUnit}`;
      ctx.fillText(weightText, x + width/2, y + height/2);
    } else {
      // Show both label and weight
      ctx.font = 'bold 10px Arial';
      ctx.fillText(label, x + width/2, y + height/2 - 6);

      // Draw weight below label using selected unit
      ctx.font = '9px Arial';
      const weightValue = displayWeightUnit === 'lbs' ? pickupWeight.lbs.toFixed(0) : pickupWeight.kg.toFixed(0);
      const weightText = `${weightValue}${displayWeightUnit}`;
      ctx.fillText(weightText, x + width/2, y + height/2 + 6);
    }
  });
}

// Calculate the weight at the center pickup point of a bumper
function calculateBumperPickupWeight(bumper) {
  const panelType = document.getElementById('panelType').value;
  const allPanels = getAllPanels();
  const p = allPanels[panelType];
  const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;

  if(!p) return { kg: 0, lbs: 0 };

  // Get correct panel weight based on connection method (air frame vs connecting plates)
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const panelWeightKg = getPanelWeight(panelType, useConnectingPlates);

  // Check if CB5 half panel row is enabled
  const hasCB5HalfRow = cb5HalfRowEnabled && panelType === 'CB5_MKII';
  const halfPanelWeightKg = hasCB5HalfRow ? getPanelWeight('CB5_MKII_HALF', useConnectingPlates) : 0;

  let totalPanelWeightKg = 0;
  let bumperWeightLbs = 0;
  
  // Get bumper weights in lbs
  const bumper1wLbs = p.bumper_1w_lbs || 0;
  const bumper2wLbs = p.bumper_2w_lbs || 0;
  const bumper4wLbs = p.bumper_4w_lbs || 0;
  
  // First, get the columns this bumper directly covers
  let directColumns = [];
  
  // Calculate panel weight based on bumper type
  if(bumper.type === '4w') {
    // 4W bumper is the pickup point - it picks up 4 columns of panels + the 4W bar itself
    // The 2W bumpers underneath are structural only, not added to pickup weight
    // bumper.startCol = center of first 2W (e.g., 1 for first 4W)
    // bumper.endCol = center of second 2W (e.g., 3 for first 4W)
    // First 2W covers columns (startCol-1) to startCol
    // Second 2W covers columns (endCol-1) to endCol
    // So we need columns: (startCol-1) to endCol (inclusive)
    const colStart = bumper.startCol - 1; // e.g., 0 for first 4W
    const colEnd = bumper.endCol;         // e.g., 3 for first 4W (not 4!)
    
    console.log(`4W Bumper: startCol=${bumper.startCol}, endCol=${bumper.endCol}, calculating columns ${colStart} to ${colEnd}`);
    
    let panelCount = 0;
    for(let c = colStart; c <= colEnd; c++) {
      if(c >= 0) {
        directColumns.push(c);
        for(let r = 0; r < ph; r++) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            totalPanelWeightKg += panelWeightKg;
            panelCount++;
          }
        }
      }
    }
    
    console.log(`4W Bumper picked up ${panelCount} panels at ${panelWeightKg}kg each = ${totalPanelWeightKg}kg panel weight`);

    // Add half panel row weight if enabled (4 half panels for 4W bumper)
    if(hasCB5HalfRow) {
      totalPanelWeightKg += 4 * halfPanelWeightKg;
    }

    // Add 4W hanging bar weight + 2x 2W bumpers (structural, part of the pickup assembly)
    bumperWeightLbs = bumper4wLbs + (2 * bumper2wLbs);
    console.log(`4W Bumper weight: ${bumper4wLbs}lbs + 2x ${bumper2wLbs}lbs = ${bumperWeightLbs}lbs total`);

  } else if(bumper.type === '2w') {
    // 2W bumper picks up 2 columns + itself
    const colStart = bumper.startCol;
    const colEnd = bumper.endCol;
    
    directColumns.push(colStart, colEnd);
    
    // For hanging bumpers, we need to calculate from the row the bumper is sitting on
    // (which accounts for dropped position due to deleted top panels)
    let startRow = 0;
    if(bumper.position === 'top') {
      // Find the first non-deleted row for both columns - bumper sits on the deeper one
      const row1 = getFirstNonDeletedRow(colStart, ph);
      const row2 = getFirstNonDeletedRow(colEnd, ph);
      startRow = Math.max(row1, row2);
    }
    
    for(let c = colStart; c <= colEnd; c++) {
      for(let r = startRow; r < ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          totalPanelWeightKg += panelWeightKg;
        }
      }
    }

    // Add half panel row weight if enabled (2 half panels for 2W bumper)
    if(hasCB5HalfRow) {
      totalPanelWeightKg += 2 * halfPanelWeightKg;
    }

    bumperWeightLbs = bumper2wLbs;

  } else if(bumper.type === '1w') {
    // 1W bumper picks up 1 column + itself
    const col = bumper.startCol;
    
    directColumns.push(col);
    
    // For hanging bumpers, calculate from the row the bumper is sitting on
    let startRow = 0;
    if(bumper.position === 'top') {
      startRow = getFirstNonDeletedRow(col, ph);
    }
    
    for(let r = startRow; r < ph; r++) {
      const panelKey = `${col},${r}`;
      if(!deletedPanels.has(panelKey)) {
        totalPanelWeightKg += panelWeightKg;
      }
    }

    // Add half panel row weight if enabled (1 half panel for 1W bumper)
    if(hasCB5HalfRow) {
      totalPanelWeightKg += halfPanelWeightKg;
    }

    bumperWeightLbs = bumper1wLbs;
  }

  // Now add weight from any orphaned columns that should transfer to this bumper
  const orphanedWeight = getOrphanedColumnWeightForBumper(bumper, pw, ph, panelWeightKg);
  totalPanelWeightKg += orphanedWeight;
  
  const panelWeightLbs = totalPanelWeightKg * 2.20462;
  const totalLbs = panelWeightLbs + bumperWeightLbs;
  const totalKg = totalLbs * 0.453592;
  
  return {
    kg: totalKg,
    lbs: totalLbs,
    panelWeight: totalPanelWeightKg,
    bumperWeight: bumperWeightLbs / 2.20462
  };
}

// Get the first non-deleted row for a column (for top bumpers)
function getFirstNonDeletedRow(column, ph) {
  for(let r = 0; r < ph; r++) {
    const panelKey = `${column},${r}`;
    if(!deletedPanels.has(panelKey)) {
      return r;
    }
  }
  return 0; // If all deleted, return 0
}

// Get the last non-deleted row for a column (for bottom bumpers)
function getLastNonDeletedRow(column, ph) {
  for(let r = ph - 1; r >= 0; r--) {
    const panelKey = `${column},${r}`;
    if(!deletedPanels.has(panelKey)) {
      return r;
    }
  }
  return ph - 1; // If all deleted, return last row
}

// Check if a column should have a bottom bumper (last row panel must exist)
function shouldHaveBottomBumper(column, ph) {
  const lastRow = ph - 1;
  const panelKey = `${column},${lastRow}`;
  return !deletedPanels.has(panelKey);
}

// Get which columns a bumper directly covers
function getBumperColumns(bumper) {
  if(bumper.type === '4w') {
    const colStart = bumper.startCol - 1;
    const colEnd = bumper.endCol;
    const cols = [];
    for(let c = colStart; c <= colEnd; c++) {
      if(c >= 0) cols.push(c);
    }
    return cols;
  } else if(bumper.type === '2w') {
    return [bumper.startCol, bumper.endCol];
  } else if(bumper.type === '1w') {
    return [bumper.startCol];
  }
  return [];
}

// Find all columns that have no bumper covering them (orphaned columns)
function getOrphanedColumns(pw, position) {
  const coveredColumns = new Set();
  
  // Get all columns covered by existing bumpers of the same position
  bumpers.filter(b => b.position === position).forEach(b => {
    getBumperColumns(b).forEach(col => coveredColumns.add(col));
  });
  
  // Find columns that are not covered
  const orphaned = [];
  for(let c = 0; c < pw; c++) {
    if(!coveredColumns.has(c)) {
      orphaned.push(c);
    }
  }
  
  return orphaned;
}

// Find the nearest bumper to a given column
function findNearestBumper(column, position) {
  const samePosiBumpers = bumpers.filter(b => b.position === position && (b.type === '1w' || b.type === '2w'));
  
  if(samePosiBumpers.length === 0) return null;
  
  let nearestBumper = null;
  let nearestDistance = Infinity;
  
  samePosiBumpers.forEach(b => {
    const bumperCols = getBumperColumns(b);
    // Find minimum distance from column to any column covered by this bumper
    bumperCols.forEach(bc => {
      const dist = Math.abs(column - bc);
      if(dist < nearestDistance) {
        nearestDistance = dist;
        nearestBumper = b;
      }
    });
  });
  
  return nearestBumper;
}

// Calculate weight from orphaned columns that should transfer to a specific bumper
function getOrphanedColumnWeightForBumper(bumper, pw, ph, panelWeightKg) {
  // Only calculate for 1w and 2w bumpers (4w bumpers pick up via their 2w sub-bumpers)
  if(bumper.type === '4w') return 0;

  // Check if CB5 half panel row is enabled
  const panelType = document.getElementById('panelType').value;
  const hasCB5HalfRow = cb5HalfRowEnabled && panelType === 'CB5_MKII';
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const halfPanelWeightKg = hasCB5HalfRow ? getPanelWeight('CB5_MKII_HALF', useConnectingPlates) : 0;

  const orphanedCols = getOrphanedColumns(pw, bumper.position);
  let additionalWeightKg = 0;

  orphanedCols.forEach(col => {
    // Find which bumper this orphaned column should transfer its weight to
    const nearestBumper = findNearestBumper(col, bumper.position);

    // If this bumper is the nearest one to this orphaned column, add the weight
    if(nearestBumper && nearestBumper.id === bumper.id) {
      // Calculate weight of panels in this orphaned column
      let startRow = 0;
      if(bumper.position === 'top') {
        startRow = getFirstNonDeletedRow(col, ph);
      }

      for(let r = startRow; r < ph; r++) {
        const panelKey = `${col},${r}`;
        if(!deletedPanels.has(panelKey)) {
          additionalWeightKg += panelWeightKg;
        }
      }

      // Add half panel weight for this orphaned column if enabled
      if(hasCB5HalfRow) {
        additionalWeightKg += halfPanelWeightKg;
      }

      console.log(`Orphaned column ${col} weight (${additionalWeightKg.toFixed(2)}kg) transferred to ${bumper.type} bumper #${bumper.id}`);
    }
  });

  return additionalWeightKg;
}

function drawBumpersAdaptive(ctx, pw, ph, size, bumperHeight, yBase, type) {
  const oneWColumn = type === 'top' ? topBumper1wColumn : bottomBumper1wColumn;
  
  // Determine if we need a 1w bumper
  const needsOneW = pw % 2 === 1;
  
  ctx.font = 'bold 12px Arial';
  
  if(!needsOneW) {
    // Even number of panels - just draw 2w bumpers
    for(let c = 0; c < pw; c += 2) {
      // Skip if this is a bottom bumper and either column has bottom row deleted
      if(type === 'bottom') {
        const hasBottomC = shouldHaveBottomBumper(c, ph);
        const hasBottomC1 = (c + 1 < pw) ? shouldHaveBottomBumper(c + 1, ph) : false;
        if(!hasBottomC || !hasBottomC1) {
          continue; // Skip this 2W bumper if either column has bottom row deleted
        }
      }
      
      // Find the appropriate Y position for this bumper pair
      let yOffset;
      if(type === 'top') {
        // Top bumpers: start at yBase, move down with deleted panels at the top
        const row1 = getFirstNonDeletedRow(c, ph);
        const row2 = c + 1 < pw ? getFirstNonDeletedRow(c + 1, ph) : row1;
        const maxRow = Math.max(row1, row2);
        // yBase is where bumpers should start (either 0 or after 4W bumpers)
        yOffset = yBase + (maxRow * size);
      } else {
        // Bottom bumpers: always at bottom (yBase = bottom of panels, so bumper starts at yBase)
        yOffset = yBase;
      }
      
      const x = c * size;
      const width = 2 * size;
      ctx.fillStyle = '#87CEEB'; // Sky blue for 2w
      ctx.fillRect(x, yOffset, width, bumperHeight);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, yOffset, width, bumperHeight);
      ctx.fillStyle = '#000000';
      ctx.fillText('2W', x + width/2, yOffset + bumperHeight/2);
    }
  } else {
    // Odd number of panels - need to place 1w and redistribute 2w bumpers
    // Draw 1W bumper at specified position
    const oneWPos = oneWColumn >= 0 && oneWColumn < pw ? oneWColumn : (pw - 1);
    
    // Check if 1W bumper should be drawn (only for bottom bumpers, check if bottom row exists)
    const shouldDraw1W = type === 'top' || shouldHaveBottomBumper(oneWPos, ph);
    
    if(shouldDraw1W) {
      let yOffset1w;
      if(type === 'top') {
        const row = getFirstNonDeletedRow(oneWPos, ph);
        yOffset1w = yBase + (row * size);
      } else {
        // Bottom bumpers stay at bottom
        yOffset1w = yBase;
      }
      
      const x1w = oneWPos * size;
      ctx.fillStyle = '#FFD700'; // Gold for 1w
      ctx.fillRect(x1w, yOffset1w, size, bumperHeight);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x1w, yOffset1w, size, bumperHeight);
      ctx.fillStyle = '#000000';
      ctx.fillText('1W', x1w + size/2, yOffset1w + bumperHeight/2);
    }
    
    // Now draw 2W bumpers, skipping the 1W position
    for(let c = 0; c < pw; c++) {
      // Skip if this is the 1W position
      if(c === oneWPos) continue;
      
      // Check if we can place a 2W bumper starting at this position
      if(c + 1 < pw && (c + 1) !== oneWPos) {
        // Skip if this is a bottom bumper and either column has bottom row deleted
        if(type === 'bottom') {
          const hasBottomC = shouldHaveBottomBumper(c, ph);
          const hasBottomC1 = shouldHaveBottomBumper(c + 1, ph);
          if(!hasBottomC || !hasBottomC1) {
            c++; // Still skip next column
            continue;
          }
        }
        
        // We can place a 2W bumper here
        let yOffset;
        if(type === 'top') {
          const row1 = getFirstNonDeletedRow(c, ph);
          const row2 = getFirstNonDeletedRow(c + 1, ph);
          const maxRow = Math.max(row1, row2);
          yOffset = yBase + (maxRow * size);
        } else {
          // Bottom bumpers stay at bottom
          yOffset = yBase;
        }
        
        const x = c * size;
        const width = 2 * size;
        ctx.fillStyle = '#87CEEB'; // Sky blue for 2w
        ctx.fillRect(x, yOffset, width, bumperHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, yOffset, width, bumperHeight);
        ctx.fillStyle = '#000000';
        ctx.fillText('2W', x + width/2, yOffset + bumperHeight/2);
        
        // Skip the next column since we just covered it with a 2W
        c++;
      } else {
        // Can't place 2W, need to place 1W here (this handles the remaining columns)
        // Skip if this is a bottom bumper and this column has bottom row deleted
        if(type === 'bottom' && !shouldHaveBottomBumper(c, ph)) {
          continue;
        }
        
        let yOffset;
        if(type === 'top') {
          const row = getFirstNonDeletedRow(c, ph);
          yOffset = yBase + (row * size);
        } else {
          // Bottom bumpers stay at bottom
          yOffset = yBase;
        }
        
        const x = c * size;
        ctx.fillStyle = '#FFD700'; // Gold for remaining 1w
        ctx.fillRect(x, yOffset, size, bumperHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, yOffset, size, bumperHeight);
        ctx.fillStyle = '#000000';
        ctx.fillText('1W', x + size/2, yOffset + bumperHeight/2);
      }
    }
  }
}

function draw4WayBumpers(ctx, pw, ph, size, bumperHeight, yBase, type) {
  const fourWayHeight = 20; // Height of 4-way bumper bar
  const fourWayGap = 5; // Gap between 2W and 4W bumpers
  const fourWayCount = Math.floor(pw / 4); // Each 4W covers 4 columns
  
  ctx.font = 'bold 10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  for(let i = 0; i < fourWayCount; i++) {
    // Each 4-way bumper is centered over 4 columns with 0.5 panel offset on each side
    // First 4W: from column 0.5 to 4.5 (4 panel widths, centered over panels 1,2,3,4)
    // Second 4W: from column 4.5 to 8.5 (4 panel widths, centered over panels 5,6,7,8)
    // Third 4W: from column 8.5 to 12.5 (4 panel widths, centered over panels 9,10,11,12)
    
    // Start at 0.5, 4.5, 8.5, etc (i*4 + 0.5)
    // End at 4.5, 8.5, 12.5, etc (i*4 + 4.5)
    const x1 = (i * 4 + 0.5) * size;  // Start position
    const width = 4 * size;            // Width is exactly 4 panels
    
    // Position above or below the 2W bumpers
    let yOffset;
    if(type === 'top') {
      // Above the 2W bumpers - at the very top
      yOffset = 0;
    } else {
      // Below the 2W bumpers
      yOffset = yBase + bumperHeight + fourWayGap;
    }
    
    // Draw 4-way bumper
    ctx.fillStyle = '#FF6B35'; // Orange color for 4W
    ctx.fillRect(x1, yOffset, width, fourWayHeight);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(x1, yOffset, width, fourWayHeight);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText('4W', x1 + width/2, yOffset + fourWayHeight/2);
  }
}

function setupStructureCanvasInteractivity() {
  const canvas = document.getElementById('structureCanvas');
  if(!canvas) return;
  
  // Store reference but don't clone - cloning erases the canvas content!
  structureCanvas = canvas;
  
  // Remove existing listeners by using a flag to track if already set up
  if(canvas._structureListenersAttached) {
    return; // Already set up, don't duplicate listeners
  }
  canvas._structureListenersAttached = true;
  
  canvas.style.cursor = manualBumperMode ? 'pointer' : 'default';
  
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let bumperDragStartCol = -1; // Track starting column for undo
  
  // Left click - select bumpers in manual mode
  canvas.addEventListener('mousedown', function(e) {
    if(e.button !== 0) return; // Only left click
    
    hideContextMenu();
    
    // Check for modifier keys (Ctrl on Windows/Linux, Cmd on Mac)
    const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
    
    // Check if clicking on a bumper
    const bumper = getBumperAtMouse(canvas, e.clientX, e.clientY);
    
    if(bumper) {
      if(manualBumperMode) {
        // In manual mode - handle selection
        if(!isMultiSelect) {
          selectedBumpers.clear();
        }
        
        // Toggle bumper selection
        if(selectedBumpers.has(bumper.id)) {
          selectedBumpers.delete(bumper.id);
        } else {
          selectedBumpers.add(bumper.id);
        }
        
        selectedBumper = bumper;
        structureDraggingBumper = bumper;
        bumperDragStartCol = bumper.startCol; // Save start position for undo
        
        // Calculate drag offset
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        dragOffsetX = mouseX - bumper.x;
        dragOffsetY = mouseY - bumper.y;
        
        canvas.style.cursor = 'grabbing';
        updateStructureSelectionInfo();
        generateStructureLayout();
      } else {
        // Not in manual mode - no interaction
      }
      
      structureIsDragging = true;
      structureDragStartX = e.clientX;
      structureDragStartY = e.clientY;
      return;
    }
    
    // Clicked on empty space - clear selection in manual mode
    if(manualBumperMode && !isMultiSelect) {
      selectedBumpers.clear();
      selectedBumper = null;
      updateStructureSelectionInfo();
      generateStructureLayout();
    }
  });
  
  // Mouse move - drag bumper (only in manual mode)
  canvas.addEventListener('mousemove', function(e) {
    // Handle bumper dragging (only in manual mode)
    if(structureDraggingBumper && manualBumperMode) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

      const size = panelSize; // Use global panelSize for consistent sizing
      const newCol = Math.floor((mouseX - dragOffsetX) / size);
      const pw = parseInt(document.getElementById('panelsWide').value) || 0;
      
      // Constrain to valid columns
      if(newCol >= 0 && newCol < pw) {
        const bumperWidth = structureDraggingBumper.endCol - structureDraggingBumper.startCol;
        const maxStartCol = Math.max(0, pw - 1 - bumperWidth);
        const constrainedCol = Math.max(0, Math.min(newCol, maxStartCol));
        
        if(constrainedCol !== structureDraggingBumper.startCol) {
          const colDelta = constrainedCol - structureDraggingBumper.startCol;
          structureDraggingBumper.startCol = constrainedCol;
          structureDraggingBumper.endCol = structureDraggingBumper.endCol + colDelta;
          
          generateStructureLayout();
        }
      }
      return;
    }
    
    // Show hover effects for bumpers (only in manual mode)
    if(manualBumperMode) {
      const bumper = getBumperAtMouse(canvas, e.clientX, e.clientY);
      
      if(bumper) {
        canvas.style.cursor = 'grab';
        if(!hoveredBumper || hoveredBumper.id !== bumper.id) {
          hoveredBumper = bumper;
          generateStructureLayout();
        }
      } else {
        canvas.style.cursor = 'default';
        if(hoveredBumper) {
          hoveredBumper = null;
          generateStructureLayout();
        }
      }
    } else {
      canvas.style.cursor = 'default';
    }
  });
  
  // Mouse up - end drag and save state if bumper was moved
  canvas.addEventListener('mouseup', function(e) {
    if(structureDraggingBumper && manualBumperMode) {
      // Check if bumper was actually moved
      if(bumperDragStartCol !== -1 && bumperDragStartCol !== structureDraggingBumper.startCol) {
        saveStructureState(); // Save state after move
      }
      
      structureDraggingBumper = null;
      bumperDragStartCol = -1;
      canvas.style.cursor = 'pointer';
      
      // Update weight and calculations
      updateWeightDisplay();
      calculate();
      updateStructureUndoRedoButtons();
    }
    structureIsDragging = false;
  });
  
  // Right click - context menu (only in manual mode)
  canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    
    if(!manualBumperMode) return;
    
    const bumper = getBumperAtMouse(canvas, e.clientX, e.clientY);
    
    if(bumper) {
      // If clicked bumper is not selected, select only it
      if(!selectedBumpers.has(bumper.id)) {
        selectedBumpers.clear();
        selectedBumpers.add(bumper.id);
        updateStructureSelectionInfo();
        generateStructureLayout();
      }
      
      // Show bumper context menu
      showBumperContextMenu(bumper, e.clientX, e.clientY);
      return;
    }
    
    // Check if clicking in a bumper area (top or bottom) for adding bumpers
    const rect = canvas.getBoundingClientRect();
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);

    const pw = parseInt(document.getElementById('panelsWide').value) || 0;
    const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
    const size = panelSize; // Use global panelSize for consistent sizing
    const bumperHeight = Math.max(30, size * 0.8);
    const fourWayHeight = Math.max(15, size * 0.4);
    const fourWayGap = Math.max(3, size * 0.1);
    
    const use4Way = use4WayBumpersEnabled;
    const panelType = document.getElementById('panelType').value;
    const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
    
    let panelYOffset = 0;
    if(showTopBumper) {
      panelYOffset += bumperHeight;
      if(use4Way && isCB5) panelYOffset += fourWayHeight + fourWayGap;
    }
    
    const column = Math.floor(x / size);
    
    // Check if in top bumper area
    if(showTopBumper) {
      const topBumperEnd = panelYOffset;
      if(y < topBumperEnd && column >= 0 && column < pw) {
        showEmptyAreaContextMenu('top', column, e.clientX, e.clientY);
        return;
      }
    }
    
    // Check if in bottom bumper area
    if(showBottomBumper) {
      const bottomBumperStart = panelYOffset + (ph * size);
      const bottomBumperEnd = bottomBumperStart + bumperHeight + (use4Way && isCB5 ? fourWayHeight + fourWayGap : 0);
      if(y >= bottomBumperStart && y < bottomBumperEnd && column >= 0 && column < pw) {
        showEmptyAreaContextMenu('bottom', column, e.clientX, e.clientY);
        return;
      }
    }
  });
  
  // Mouse leave - clear hover and end drag
  canvas.addEventListener('mouseleave', function(e) {
    if(hoveredBumper) {
      hoveredBumper = null;
      generateStructureLayout();
    }
    if(structureDraggingBumper) {
      structureDraggingBumper = null;
    }
    structureIsDragging = false;
    canvas.style.cursor = manualBumperMode ? 'pointer' : 'default';
  });
}

// Show context menu for panels in structure view
// Draw green highlight on bumper being dragged - optimized version
function drawBumperDragHighlight(canvas, clientX, clientY) {
  if(!structureDraggingBumper || !structureOriginalImageData) return;

  const ctx = canvas.getContext('2d');
  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  if(!p || !p.width_m || !p.height_m) return;
  
  const {pw, ph} = getEffectivePanelCountsForLayout();
  const needsOneW = pw % 2 === 1;
  
  // Restore original canvas state
  ctx.putImageData(structureOriginalImageData, 0, 0);

  const size = panelSize; // Use global panelSize for consistent sizing
  const bumperHeight = Math.max(30, size * 0.8);
  const panelYOffset = showTopBumper ? bumperHeight : 0;
  const type = structureDraggingBumper.type;
  const draggedColumn = structureDraggingBumper.column;
  
  // Calculate the Y position of the bumper being dragged
  let yOffset;
  if(type === 'top') {
    if(structureDraggingBumper.is2W) {
      const row1 = getFirstNonDeletedRow(draggedColumn, ph);
      const row2 = draggedColumn + 1 < pw ? getFirstNonDeletedRow(draggedColumn + 1, ph) : row1;
      const maxRow = Math.max(row1, row2);
      yOffset = (panelYOffset - bumperHeight) + (maxRow * size);
    } else {
      const row = getFirstNonDeletedRow(draggedColumn, ph);
      yOffset = (panelYOffset - bumperHeight) + (row * size);
    }
  } else {
    const bottomYBase = panelYOffset + (ph * size);
    yOffset = bottomYBase;
  }
  
  // Draw green outline around the bumper being dragged
  ctx.strokeStyle = '#00FF00';
  ctx.lineWidth = 4;
  const x = draggedColumn * size;
  const width = structureDraggingBumper.is2W ? (2 * size) : size;
  ctx.strokeRect(x, yOffset, width, bumperHeight);
  
  // Get hover column
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const canvasX = (clientX - rect.left) * scaleX;
  const hoverColumn = Math.floor(canvasX / size);
  
  // Show preview outline where it will go
  if(hoverColumn >= 0 && hoverColumn < pw && hoverColumn !== draggedColumn) {
    const currentOneWPos = type === 'top' ? topBumper1wColumn : bottomBumper1wColumn;
    let canDropHere = false;
    let previewWidth = size;
    
    if(structureDraggingBumper.is2W) {
      // For 2W bumpers, only show preview if hovering directly over the 1W position (for swap)
      if(needsOneW && hoverColumn === currentOneWPos) {
        canDropHere = true;
        previewWidth = size; // Will show where the 1W will move to
      }
    } else if(structureDraggingBumper.isOneW) {
      // 1W bumpers can be moved anywhere
      canDropHere = true;
      previewWidth = size;
    }
    
    if(canDropHere) {
      let previewY;
      let previewX;
      
      if(structureDraggingBumper.is2W && hoverColumn === currentOneWPos) {
        // Show where the 1W will move to (the dragged 2W's first column)
        previewX = draggedColumn * size;
        if(type === 'top') {
          const row = getFirstNonDeletedRow(draggedColumn, ph);
          previewY = (panelYOffset - bumperHeight) + (row * size);
        } else {
          const bottomYBase = panelYOffset + (ph * size);
          previewY = bottomYBase;
        }
      } else {
        // Normal 1W move preview
        previewX = hoverColumn * size;
        if(type === 'top') {
          const row = getFirstNonDeletedRow(hoverColumn, ph);
          previewY = (panelYOffset - bumperHeight) + (row * size);
        } else {
          const bottomYBase = panelYOffset + (ph * size);
          previewY = bottomYBase;
        }
      }
      
      // Draw dashed green preview outline
      ctx.strokeStyle = '#00FF00';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      ctx.strokeRect(previewX, previewY, previewWidth, bumperHeight);
      ctx.setLineDash([]);
      
      // Add helper text for 2W -> 1W swap
      if(structureDraggingBumper.is2W && needsOneW && hoverColumn === currentOneWPos) {
        ctx.fillStyle = '#00FF00';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SWAP', hoverColumn * size + size/2, previewY - 8);
      }
    }
  }
}

function getBumperAtPosition(canvas, clientX, clientY) {
  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  if(!p || !p.width_m || !p.height_m) return null;
  
  const {pw, ph} = getEffectivePanelCountsForLayout();
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const canvasX = (clientX - rect.left) * scaleX;
  const canvasY = (clientY - rect.top) * scaleY;

  const size = panelSize; // Use global panelSize for consistent sizing
  const bumperHeight = Math.max(30, size * 0.8);
  const panelYOffset = showTopBumper ? bumperHeight : 0;
  const column = Math.floor(canvasX / size);
  
  if(column < 0 || column >= pw) return null;
  
  // Check top bumper
  if(showTopBumper) {
    const oneWPos = topBumper1wColumn >= 0 && topBumper1wColumn < pw ? topBumper1wColumn : (pw - 1);
    const needsOneW = pw % 2 === 1;
    
    // Check if clicking on the 1W bumper specifically
    if(needsOneW && column === oneWPos) {
      const row = getFirstNonDeletedRow(column, ph);
      const expectedY = (panelYOffset - bumperHeight) + (row * size);
      
      if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
        return {type: 'top', column: column, isOneW: true};
      }
    }
    
    // Check for 2W bumpers
    for(let c = 0; c < pw; c++) {
      if(needsOneW && c === oneWPos) continue;
      
      if(c + 1 < pw && (c + 1) !== oneWPos) {
        // This is a 2W bumper covering columns c and c+1
        if(column === c || column === c + 1) {
          const row1 = getFirstNonDeletedRow(c, ph);
          const row2 = getFirstNonDeletedRow(c + 1, ph);
          const maxRow = Math.max(row1, row2);
          const expectedY = (panelYOffset - bumperHeight) + (maxRow * size);
          
          if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
            return {type: 'top', column: c, isOneW: false, is2W: true};
          }
        }
        c++;
      } else if(!needsOneW && c + 1 >= pw) {
        if(column === c) {
          const row = getFirstNonDeletedRow(c, ph);
          const expectedY = (panelYOffset - bumperHeight) + (row * size);
          
          if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
            return {type: 'top', column: column, isOneW: false};
          }
        }
      }
    }
  }
  
  // Check bottom bumper
  if(showBottomBumper) {
    const oneWPos = bottomBumper1wColumn >= 0 && bottomBumper1wColumn < pw ? bottomBumper1wColumn : (pw - 1);
    const needsOneW = pw % 2 === 1;
    const bottomYBase = panelYOffset + (ph * size);
    const expectedY = bottomYBase; // Bottom bumpers always at yBase
    
    // Check if click is within bumper Y range
    if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
      // Check if clicking on the 1W bumper specifically
      if(needsOneW && column === oneWPos) {
        // Only return if this column should have a bottom bumper
        if(shouldHaveBottomBumper(oneWPos, ph)) {
          return {type: 'bottom', column: column, isOneW: true};
        }
      }
      
      // Check for 2W bumpers
      for(let c = 0; c < pw; c++) {
        if(needsOneW && c === oneWPos) continue;
        
        if(c + 1 < pw && (c + 1) !== oneWPos) {
          // This is a 2W bumper covering columns c and c+1
          if(column === c || column === c + 1) {
            // Only return if both columns should have bottom bumpers
            if(shouldHaveBottomBumper(c, ph) && shouldHaveBottomBumper(c + 1, ph)) {
              return {type: 'bottom', column: c, isOneW: false, is2W: true};
            }
          }
          c++;
        } else if(!needsOneW && c + 1 >= pw) {
          if(column === c) {
            // Only return if this column should have a bottom bumper
            if(shouldHaveBottomBumper(c, ph)) {
              return {type: 'bottom', column: column, isOneW: false};
            }
          }
        }
      }
    }
  }
  
  return null;
}

function updateBumpersBasedOnStructureType() {
  const structureType = document.getElementById('structureType').value;

  // Floor structure type - automatically disable bumpers
  if(structureType === 'floor') {
    if(useBumpers) {
      useBumpers = false;
      document.getElementById('useBumpersBtn').classList.remove('active');
      const bumperControls = document.getElementById('bumperControls');
      if(bumperControls) bumperControls.style.display = 'none';
    }
    showTopBumper = false;
    showBottomBumper = false;
  } else if(useBumpers) {
    // Only set bumper flags if bumpers are enabled
    if(structureType === 'hanging') {
      showTopBumper = true;
      showBottomBumper = false;
    } else { // ground stacking
      showTopBumper = false;
      showBottomBumper = true;
    }
  } else {
    // Bumpers disabled - ensure flags are false
    showTopBumper = false;
    showBottomBumper = false;
  }

  // Reinitialize bumpers when structure type changes
  initializeBumpers();

  updateStructureVisualization();
  updateWeightDisplay();
}

function toggleTopBumper() {
  // Deprecated - kept for backward compatibility
  showTopBumper = !showTopBumper;
  generateStructureLayout();
}

function toggleBottomBumper() {
  // Deprecated - kept for backward compatibility
  showBottomBumper = !showBottomBumper;
  generateStructureLayout();
}


// Interactive panel selection functions
function getPanelAtPosition(canvas, x, y) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const canvasX = (x - rect.left) * scaleX;
  const canvasY = (y - rect.top) * scaleY;
  
  const col = Math.floor(canvasX / currentPanelWidth);
  const row = Math.floor(canvasY / currentPanelHeight);
  
  if(col >= 0 && col < currentPw && row >= 0 && row < currentPh) {
    return {col, row, key: `${col},${row}`};
  }
  return null;
}

function getPanelsInRect(x1, y1, x2, y2) {
  const rect = currentCanvas.getBoundingClientRect();
  const scaleX = currentCanvas.width / rect.width;
  const scaleY = currentCanvas.height / rect.height;
  
  const canvasX1 = (Math.min(x1, x2) - rect.left) * scaleX;
  const canvasY1 = (Math.min(y1, y2) - rect.top) * scaleY;
  const canvasX2 = (Math.max(x1, x2) - rect.left) * scaleX;
  const canvasY2 = (Math.max(y1, y2) - rect.top) * scaleY;
  
  const col1 = Math.max(0, Math.floor(canvasX1 / currentPanelWidth));
  const row1 = Math.max(0, Math.floor(canvasY1 / currentPanelHeight));
  const col2 = Math.min(currentPw - 1, Math.floor(canvasX2 / currentPanelWidth));
  const row2 = Math.min(currentPh - 1, Math.floor(canvasY2 / currentPanelHeight));
  
  const panels = [];
  for(let c = col1; c <= col2; c++) {
    for(let r = row1; r <= row2; r++) {
      panels.push({col: c, row: r, key: `${c},${r}`});
    }
  }
  return panels;
}

function deleteSelectedPanels() {
  if(selectedPanels.size === 0) return;
  
  saveState(); // Save state before making changes
  
  selectedPanels.forEach(key => {
    deletedPanels.add(key);
  });
  selectedPanels.clear();
  
  // Save to current screen data so canvas view can see it
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.deletedPanels = new Set(deletedPanels);
  }
  
  // Regenerate all layouts and recalculate
  calculate();
  
  // Update canvas view to reflect deleted panels
  showCanvasView();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
}

let canvasListenersSetup = false;

function setupStandardCanvasInteractivity() {
  const canvas = document.getElementById('standardCanvas');
  if(!canvas) return;
  
  // Only setup listeners once
  if(canvasListenersSetup) {
    currentCanvas = canvas;
    return;
  }
  
  canvasListenersSetup = true;
  currentCanvas = canvas;
  
  // Mouse down - start selection
  canvas.addEventListener('mousedown', function(e) {
    if(e.button !== 0) return; // Only left click
    
    const panel = getPanelAtPosition(canvas, e.clientX, e.clientY);
    if(!panel) return;
    
    // Check for modifier keys (Ctrl on Windows/Linux, Cmd on Mac)
    const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
    
    if(!isMultiSelect) {
      selectedPanels.clear();
    }
    
    // Toggle selection of clicked panel
    if(selectedPanels.has(panel.key)) {
      selectedPanels.delete(panel.key);
    } else {
      selectedPanels.add(panel.key);
    }
    
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    
    generateLayout('standard');
  });
  
  // Mouse move - drag selection
  canvas.addEventListener('mousemove', function(e) {
    if(!isDragging) return;
    
    const dx = Math.abs(e.clientX - dragStartX);
    const dy = Math.abs(e.clientY - dragStartY);
    
    // Only do rect selection if dragged more than 5 pixels
    if(dx > 5 || dy > 5) {
      const panels = getPanelsInRect(dragStartX, dragStartY, e.clientX, e.clientY);
      
      const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
      if(!isMultiSelect) {
        selectedPanels.clear();
      }
      
      panels.forEach(p => {
        selectedPanels.add(p.key);
      });
      
      generateLayout('standard');
    }
  });
  
  // Mouse up - end selection
  canvas.addEventListener('mouseup', function(e) {
    isDragging = false;
  });
  
  // Mouse leave - end drag
  canvas.addEventListener('mouseleave', function(e) {
    isDragging = false;
  });
  
  // Right click - context menu
  canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();

    const panel = getPanelAtPosition(canvas, e.clientX, e.clientY);
    if(!panel) return;

    // If clicked panel is not selected, select only it
    if(!selectedPanels.has(panel.key)) {
      selectedPanels.clear();
      selectedPanels.add(panel.key);
      generateLayout('standard');
    }

    // Show context menu
    showContextMenu(e.clientX, e.clientY);
  });

  // Touch support for panel selection
  // Behavior: 1 tap = select panel, 2nd tap on selected = menu, drag = multi-select
  let touchSelectStart = null;
  let isTouchSelecting = false;
  let touchStartPanel = null;
  let touchEndX = 0;
  let touchEndY = 0;

  canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length !== 1) return;

    const touch = e.touches[0];
    touchSelectStart = { x: touch.clientX, y: touch.clientY };
    touchEndX = touch.clientX;
    touchEndY = touch.clientY;
    isTouchSelecting = false;

    const panel = getPanelAtPosition(canvas, touch.clientX, touch.clientY);
    touchStartPanel = panel;
  }, {passive: true});

  canvas.addEventListener('touchmove', function(e) {
    if(!touchSelectStart) return;
    if(e.touches.length !== 1) return;

    const touch = e.touches[0];
    touchEndX = touch.clientX;
    touchEndY = touch.clientY;
    const dx = Math.abs(touch.clientX - touchSelectStart.x);
    const dy = Math.abs(touch.clientY - touchSelectStart.y);

    // Start drag selection after moving enough
    if(dx > 10 || dy > 10) {
      if(!isTouchSelecting) {
        // First move - clear selection and start fresh
        isTouchSelecting = true;
        selectedPanels.clear();
        if(touchStartPanel) {
          selectedPanels.add(touchStartPanel.key);
        }
      }

      e.preventDefault();

      // Get panel at current touch position
      const panel = getPanelAtPosition(canvas, touch.clientX, touch.clientY);
      if(panel && !selectedPanels.has(panel.key)) {
        selectedPanels.add(panel.key);
        vibrate(10); // Light haptic feedback
        generateLayout('standard');
      }
    }
  }, {passive: false});

  canvas.addEventListener('touchend', function(e) {
    // If dragging across panels, tapping on selected panel shows menu
    if(isTouchSelecting) {
      // Multi-select drag ended - don't show menu automatically
      touchSelectStart = null;
      isTouchSelecting = false;
      touchStartPanel = null;
      return;
    }

    // Single tap behavior
    if(touchStartPanel) {
      const wasAlreadySelected = selectedPanels.has(touchStartPanel.key);

      if(wasAlreadySelected) {
        // Panel was already selected - show context menu
        vibrate(30);
        showContextMenu(touchEndX, touchEndY);
      } else {
        // Panel not selected - select it (clear others first)
        selectedPanels.clear();
        selectedPanels.add(touchStartPanel.key);
        generateLayout('standard');
      }
    }

    touchSelectStart = null;
    isTouchSelecting = false;
    touchStartPanel = null;
  });

  canvas.addEventListener('touchcancel', function(e) {
    touchSelectStart = null;
    isTouchSelecting = false;
    touchStartPanel = null;
  });
}

function showContextMenu(x, y) {
  // Remove existing menu if any
  const existingMenu = document.getElementById('panelContextMenu');
  if(existingMenu) existingMenu.remove();
  
  // Create context menu
  const menu = document.createElement('div');
  menu.id = 'panelContextMenu';
  menu.style.position = 'fixed';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.background = '#2a2a2a';
  menu.style.border = '1px solid #555';
  menu.style.borderRadius = '4px';
  menu.style.padding = '4px 0';
  menu.style.zIndex = '10000';
  menu.style.minWidth = '200px';
  menu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.5)';
  
  // Assign Circuit option
  const assignCircuitOption = document.createElement('div');
  assignCircuitOption.textContent = `Assign Circuit # to ${selectedPanels.size} panel(s)`;
  assignCircuitOption.style.padding = '8px 12px';
  assignCircuitOption.style.cursor = 'pointer';
  assignCircuitOption.style.color = '#e0e0e0';
  assignCircuitOption.style.fontSize = '13px';
  assignCircuitOption.style.borderBottom = '1px solid #444';
  assignCircuitOption.addEventListener('mouseover', function() {
    assignCircuitOption.style.background = '#0a66c2';
  });
  assignCircuitOption.addEventListener('mouseout', function() {
    assignCircuitOption.style.background = 'transparent';
  });
  assignCircuitOption.addEventListener('click', function() {
    menu.remove();
    showCircuitNumberPrompt();
  });
  
  // Assign Data Line option
  const assignDataLineOption = document.createElement('div');
  assignDataLineOption.textContent = `Assign Data Line # to ${selectedPanels.size} panel(s)`;
  assignDataLineOption.style.padding = '8px 12px';
  assignDataLineOption.style.cursor = 'pointer';
  assignDataLineOption.style.color = '#e0e0e0';
  assignDataLineOption.style.fontSize = '13px';
  assignDataLineOption.style.borderBottom = '1px solid #444';
  assignDataLineOption.addEventListener('mouseover', function() {
    assignDataLineOption.style.background = '#0a66c2';
  });
  assignDataLineOption.addEventListener('mouseout', function() {
    assignDataLineOption.style.background = 'transparent';
  });
  assignDataLineOption.addEventListener('click', function() {
    menu.remove();
    showDataLineNumberPrompt();
  });
  
  // Delete option
  const deleteOption = document.createElement('div');
  deleteOption.textContent = `Delete ${selectedPanels.size} panel(s)`;
  deleteOption.style.padding = '8px 12px';
  deleteOption.style.cursor = 'pointer';
  deleteOption.style.color = '#e0e0e0';
  deleteOption.style.fontSize = '13px';
  deleteOption.addEventListener('mouseover', function() {
    deleteOption.style.background = '#0a66c2';
  });
  deleteOption.addEventListener('mouseout', function() {
    deleteOption.style.background = 'transparent';
  });
  deleteOption.addEventListener('click', function() {
    deleteSelectedPanels();
    menu.remove();
  });
  
  menu.appendChild(assignCircuitOption);
  menu.appendChild(assignDataLineOption);
  menu.appendChild(deleteOption);
  document.body.appendChild(menu);
  
  // Close menu when clicking elsewhere
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if(!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 10);
}

function showCircuitNumberPrompt() {
  const circuitNum = prompt(`Enter circuit number for ${selectedPanels.size} selected panel(s):\n\n(Enter a number 1-999, or leave blank to clear custom assignment)`);
  
  if(circuitNum === null) return; // User cancelled
  
  saveState(); // Save state before making changes
  
  if(circuitNum.trim() === '') {
    // Clear custom assignments for selected panels
    selectedPanels.forEach(key => {
      customCircuitAssignments.delete(key);
    });
  } else {
    const num = parseInt(circuitNum);
    if(isNaN(num) || num < 1 || num > 999) {
      alert('Please enter a valid circuit number between 1 and 999');
      return;
    }
    
    // Assign circuit number to selected panels
    selectedPanels.forEach(key => {
      customCircuitAssignments.set(key, num);
    });
  }
  
  selectedPanels.clear();
  calculate();
}

function showDataLineNumberPrompt() {
  const dataLineNum = prompt(`Enter data line number for ${selectedPanels.size} selected panel(s):\n\n(Enter a number 1-999, or leave blank to clear custom assignment)`);
  
  if(dataLineNum === null) return; // User cancelled
  
  saveState(); // Save state before making changes
  
  if(dataLineNum.trim() === '') {
    // Clear custom assignments for selected panels
    selectedPanels.forEach(key => {
      customDataLineAssignments.delete(key);
    });
  } else {
    const num = parseInt(dataLineNum);
    if(isNaN(num) || num < 1 || num > 999) {
      alert('Please enter a valid data line number between 1 and 999');
      return;
    }
    
    // Assign data line number to selected panels
    selectedPanels.forEach(key => {
      customDataLineAssignments.set(key, num);
    });
  }
  
  selectedPanels.clear();
  calculate();
}

function drawVArrowhead(ctx, x, y, angle, colorHex){
  const size = 12;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.strokeStyle = colorHex;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-size, -size/2);
  ctx.lineTo(0, 0);
  ctx.lineTo(-size, size/2);
  ctx.stroke();
  ctx.restore();
}

// Calculate and update the suggested max panels per circuit based on power settings
function updateSuggestedCircuitLimit(){
  const allPanels = getAllPanels();
  const p = allPanels[document.getElementById('panelType').value];
  if(!p || !p.power_max_w) {
    document.getElementById('maxPanelsPerCircuit').placeholder = "Auto";
    return;
  }
  
  const voltage = parseFloat(document.getElementById('voltage').value) || 208;
  const breaker = parseFloat(document.getElementById('breaker').value) || 20;
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const powerType = document.getElementById('powerType').value;
  
  const circuitCapacityW = voltage * breaker * derate;
  const perPanelW = powerType === 'max' ? p.power_max_w : (p.power_avg_w || p.power_max_w * 0.5);
  const powerBasedLimit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
  
  const input = document.getElementById('maxPanelsPerCircuit');
  if(input && !input.value) {
    input.placeholder = powerBasedLimit.toString();
  }
}

function updateSuggestedDataLimit(){
  const allPanels = getAllPanels();
  const allProcessors = getAllProcessors();
  const p=allPanels[document.getElementById('panelType').value];
  const pr=allProcessors[document.getElementById('processor').value];
  if(!p || !p.res_x || !p.res_y){ document.getElementById('maxPanelsPerData').placeholder = "Auto"; return; }

  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';

  // Get panel dimensions
  const pw = parseInt(document.getElementById('panelsWide').value) || 1;
  const ph = parseInt(document.getElementById('panelsHigh').value) || 1;
  const activePanelsCount = (pw * ph) - deletedPanels.size;

  const pixelsPerPanel = p.res_x*p.res_y;
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  const adjustedCapacity = calculateAdjustedPixelCapacity(pr, frameRate, bitDepth);

  // Calculate suggested panels per data line accounting for mixed panel types
  // Uses the SAME logic as calculate() for consistency
  let capacityBasedLimit;
  if(hasCB5HalfRow) {
    // With half panels, calculate based on actual panel counts (same as calculate() function)
    const halfPanel = panels['CB5_MKII_HALF'];
    const halfPanelPixels = halfPanel.res_x * halfPanel.res_y;
    const mainPanelCount = activePanelsCount; // All full panels
    const halfPanelCount = pw; // Additional half panel row
    const totalMixedPanels = mainPanelCount + halfPanelCount;
    const totalMixedPixels = (mainPanelCount * pixelsPerPanel) + (halfPanelCount * halfPanelPixels);
    const avgPixelsPerPanel = totalMixedPixels / totalMixedPanels;
    capacityBasedLimit = Math.max(1, Math.floor(adjustedCapacity / avgPixelsPerPanel));
  } else {
    capacityBasedLimit = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  }

  // Cap at 500 panels per port (Brompton Tessera hardware limit)
  const MAX_PANELS_PER_PORT = 500;
  capacityBasedLimit = Math.min(capacityBasedLimit, MAX_PANELS_PER_PORT);

  // Use the panel-specific limit if available, otherwise use capacity-based calculation
  // Apply panel's max_panels_per_data limit even when mixing with half panels
  const panelSpecificLimit = p.max_panels_per_data || null;
  const suggested = panelSpecificLimit
    ? Math.min(capacityBasedLimit, panelSpecificLimit)
    : capacityBasedLimit;

  const input = document.getElementById('maxPanelsPerData');
  if(!input.value){ input.placeholder = suggested; }
}

// ==================== CANVAS TABS MANAGEMENT ====================
// Data structure for multiple canvases
let canvases = {};
let canvasIdCounter = 0;
let currentCanvasId = null;

// Initialize default canvas
function initializeCanvases() {
  if(Object.keys(canvases).length === 0) {
    canvasIdCounter = 1;
    const defaultCanvasId = 'canvas_1';
    const defaultData = getDefaultCanvasData();
    // Initialize with current screen visibility
    Object.keys(screens).forEach(screenId => {
      defaultData.screenVisibility[screenId] = screens[screenId].visible !== false;
    });
    canvases[defaultCanvasId] = {
      id: defaultCanvasId,
      name: 'Canvas 1',
      data: defaultData
    };
    currentCanvasId = defaultCanvasId;
  }
  renderCanvasTabs();
}

function getDefaultCanvasData() {
  return {
    canvasSize: '4K_UHD',
    customCanvasWidth: 3840,
    customCanvasHeight: 2160,
    screenVisibility: {} // Per-canvas screen visibility: {screenId: true/false}
  };
}

function renderCanvasTabs() {
  const container = document.getElementById('canvasTabsContainer');
  if(!container) return;

  const canvasIds = Object.keys(canvases).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]) || 0;
    const numB = parseInt(b.split('_')[1]) || 0;
    return numA - numB;
  });

  let html = '<div class="screen-tabs">';
  canvasIds.forEach(canvasId => {
    const canvas = canvases[canvasId];
    const isActive = canvasId === currentCanvasId;
    html += `
      <div class="screen-tab ${isActive ? 'active' : ''}" onclick="switchToCanvas('${canvasId}')">
        <span class="screen-tab-name">${canvas.name}</span>
        <button class="screen-tab-edit" onclick="event.stopPropagation(); openCanvasRenameModal('${canvasId}')" title="Edit canvas">✎</button>
        <button class="screen-tab-close" onclick="event.stopPropagation(); deleteCanvas('${canvasId}')" title="Delete canvas" style="${canvasIds.length <= 1 ? 'visibility: hidden;' : ''}">×</button>
      </div>`;
  });
  html += '</div>';
  html += `<div class="screen-tab-add" onclick="addNewCanvas()" title="Add new canvas" style="flex-shrink: 0; margin-left: auto;">+</div>`;

  container.innerHTML = html;
}

function addNewCanvas() {
  saveCurrentCanvasData();
  canvasIdCounter++;
  const newCanvasId = `canvas_${canvasIdCounter}`;
  const canvasNumber = Object.keys(canvases).length + 1;

  // Create new canvas with all screens hidden (since they may be on other canvases)
  const newCanvasData = getDefaultCanvasData();
  // Initialize all screens as not visible in the new canvas
  Object.keys(screens).forEach(screenId => {
    newCanvasData.screenVisibility[screenId] = false;
  });

  canvases[newCanvasId] = {
    id: newCanvasId,
    name: `Canvas ${canvasNumber}`,
    data: newCanvasData
  };

  currentCanvasId = newCanvasId;
  renderCanvasTabs();
  loadCanvasData(newCanvasId);
  showCanvasView();
}

function switchToCanvas(canvasId) {
  if(canvasId === currentCanvasId) return;
  saveCurrentCanvasData();
  currentCanvasId = canvasId;
  loadCanvasData(canvasId);
  renderCanvasTabs();
  showCanvasView();
}

function deleteCanvas(canvasId) {
  const canvasIds = Object.keys(canvases);
  if(canvasIds.length <= 1) return;

  if(!confirm(`Delete "${canvases[canvasId].name}"?`)) return;

  delete canvases[canvasId];

  if(currentCanvasId === canvasId) {
    const remainingIds = Object.keys(canvases);
    currentCanvasId = remainingIds[0];
    loadCanvasData(currentCanvasId);
  }

  renderCanvasTabs();
  showCanvasView();
}

function openCanvasRenameModal(canvasId) {
  const canvas = canvases[canvasId];
  if(!canvas) return;
  const newName = prompt('Rename canvas:', canvas.name);
  if(newName && newName.trim()) {
    canvas.name = newName.trim();
    renderCanvasTabs();
  }
}

function saveCurrentCanvasData() {
  if(!currentCanvasId || !canvases[currentCanvasId]) return;
  const canvas = canvases[currentCanvasId];

  canvas.data.canvasSize = document.getElementById('canvasSize')?.value || '4K_UHD';
  canvas.data.customCanvasWidth = parseInt(document.getElementById('customCanvasWidth')?.value) || 3840;
  canvas.data.customCanvasHeight = parseInt(document.getElementById('customCanvasHeight')?.value) || 2160;

  // Save current screen visibility for this canvas
  canvas.data.screenVisibility = {};
  Object.keys(screens).forEach(screenId => {
    canvas.data.screenVisibility[screenId] = screens[screenId].visible !== false;
  });
}

function loadCanvasData(canvasId) {
  const canvas = canvases[canvasId];
  if(!canvas) return;

  const canvasSizeSelect = document.getElementById('canvasSize');
  if(canvasSizeSelect) {
    canvasSizeSelect.value = canvas.data.canvasSize || '4K_UHD';
    // Trigger change event to show/hide custom inputs
    canvasSizeSelect.dispatchEvent(new Event('change'));
  }

  const customWidthInput = document.getElementById('customCanvasWidth');
  const customHeightInput = document.getElementById('customCanvasHeight');
  if(customWidthInput) customWidthInput.value = canvas.data.customCanvasWidth || 3840;
  if(customHeightInput) customHeightInput.value = canvas.data.customCanvasHeight || 2160;

  // Restore screen visibility for this canvas
  // Default all screens to hidden, then restore saved visibility
  Object.keys(screens).forEach(screenId => {
    if(canvas.data.screenVisibility && canvas.data.screenVisibility.hasOwnProperty(screenId)) {
      screens[screenId].visible = canvas.data.screenVisibility[screenId];
    } else {
      // If no saved state, default to hidden
      screens[screenId].visible = false;
    }
  });
  // Update the screen toggles UI
  updateCanvasScreenToggles();
}

function showCanvasView(){
  // Get all panels (built-in + custom) for use throughout this function
  const allPanels = getAllPanels();

  // Clear any cached canvas image to ensure fresh render
  cachedCanvasImageData = null;

  // Only show canvas container when on canvas page
  const container = document.getElementById('canvasContainer');
  const isCanvasPage = typeof currentMobileView !== 'undefined' && currentMobileView === 'canvas';
  if(isCanvasPage) {
    container.style.display = 'block';
  }

  // Check if ANY screen has valid dimensions (not just current screen)
  let anyScreenHasDimensions = false;
  Object.values(screens).forEach(screen => {
    const data = screen.data;
    if((data.panelsWide && data.panelsWide > 0) || (data.panelsHigh && data.panelsHigh > 0)) {
      anyScreenHasDimensions = true;
    }
  });

  // Don't draw canvas if no screens have dimensions, but still show container
  if(!anyScreenHasDimensions) {
    // Clear the canvas to black when no screens have dimensions
    const canvas = document.getElementById('canvasView');
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    return;
  }

  // Reset viewport pan to show origin (0,0)
  if(canvasZoomLevel === 1.0) {
    canvasPanX = 0;
    canvasPanY = 0;
  }
  
  // Force browser reflow to ensure container is laid out
  void container.offsetHeight;
  
  const canvasSize = document.getElementById('canvasSize').value;
  
  // Get canvas resolution
  let canvasResX, canvasResY, canvasName;
  if(canvasSize === '4K_UHD'){
    canvasResX = 3840; canvasResY = 2160; canvasName = '4K UHD (3840x2160)';
  } else if(canvasSize === '4K_DCI'){
    canvasResX = 4096; canvasResY = 2160; canvasName = '4K DCI (4096x2160)';
  } else if(canvasSize === 'HD'){
    canvasResX = 1920; canvasResY = 1080; canvasName = 'HD (1920x1080)';
  } else if(canvasSize === 'custom'){
    canvasResX = parseInt(document.getElementById('customCanvasWidth').value) || 1920;
    canvasResY = parseInt(document.getElementById('customCanvasHeight').value) || 1080;
    canvasName = `Custom (${canvasResX}x${canvasResY})`;
  }
  
  const canvas = document.getElementById('canvasView');
  const ctx = canvas.getContext('2d');
  
  // Set canvas internal resolution (always full resolution for quality)
  canvas.width = canvasResX;
  canvas.height = canvasResY;
  
  // Explicitly position canvas at origin
  canvas.style.position = 'relative';
  canvas.style.left = '0px';
  canvas.style.top = '0px';
  canvas.style.margin = '0';
  canvas.style.padding = '0';
  
  // Calculate the base display size to fit in wrapper (use actual wrapper size for mobile compatibility)
  const wrapperEl = document.getElementById('canvasViewWrapper');
  const wrapperRect = wrapperEl.getBoundingClientRect();
  const wrapperWidth = wrapperRect.width || 800;
  const wrapperHeight = wrapperRect.height || 450;
  const scaleX = wrapperWidth / canvasResX;
  const scaleY = wrapperHeight / canvasResY;
  const baseScale = Math.min(scaleX, scaleY);

  // Set canvas display size to fill wrapper (CSS handles responsive sizing)
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  
  console.log(`Canvas setup: internal=${canvasResX}x${canvasResY}, wrapper=${wrapperWidth}x${wrapperHeight}, baseScale=${baseScale}`);
  console.log(`Viewport: zoom=${canvasZoomLevel}, panX=${canvasPanX}, panY=${canvasPanY}`);
  
  // Log actual DOM positions for debugging
  const canvasRect = canvas.getBoundingClientRect();
  const viewportEl = document.getElementById('canvasViewport');
  const viewportRect = viewportEl ? viewportEl.getBoundingClientRect() : null;

  console.log('Canvas rect:', {x: canvasRect.x, y: canvasRect.y, width: canvasRect.width, height: canvasRect.height});
  if(viewportRect) console.log('Viewport rect:', {x: viewportRect.x, y: viewportRect.y, width: viewportRect.width, height: viewportRect.height});
  console.log('Wrapper rect:', {x: wrapperRect.x, y: wrapperRect.y, width: wrapperRect.width, height: wrapperRect.height});
  if(viewportEl) console.log('Viewport transform:', viewportEl.style.transform);
  
  // Apply zoom and pan transform
  updateCanvasViewport();
  
  // Force multiple browser reflows to ensure proper rendering
  void canvas.offsetHeight;
  void canvas.offsetWidth;
  void canvas.getBoundingClientRect();
  
  // Force a style recalculation
  canvas.style.transform = canvas.style.transform;
  
  // Clear canvas with black background
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, canvasResX, canvasResY);
  
  // Sort screen IDs numerically
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  
  // Draw each visible screen
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    
    // Skip invisible screens
    if(!screen.visible) return;
    
    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = allPanels[panelType];

    if(!p || !p.width_m || !p.height_m || !p.res_x || !p.res_y) return;

    // Get panel dimensions for this screen
    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;

    if(pw === 0 || ph === 0) return;

    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';

    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    // Ensure canvas position is a valid number, default to 0
    const offsetX = (typeof screenData.canvasX === 'number' && !isNaN(screenData.canvasX)) ? screenData.canvasX : 0;
    const offsetY = (typeof screenData.canvasY === 'number' && !isNaN(screenData.canvasY)) ? screenData.canvasY : 0;
    
    console.log(`showCanvasView rendering ${screenId}: offsetX=${offsetX}, offsetY=${offsetY}, screenData.canvasX=${screenData.canvasX}, screenData.canvasY=${screenData.canvasY}`);
    
    const totalRows = hasCB5HalfRow ? ph + 1 : ph;
    // Ensure deletedPanels is a Set (might be array from JSON load)
    let deletedPanelsForScreen = screenData.deletedPanels;
    if(deletedPanelsForScreen && !(deletedPanelsForScreen instanceof Set)) {
      deletedPanelsForScreen = new Set(deletedPanelsForScreen);
    }
    if(!deletedPanelsForScreen) {
      deletedPanelsForScreen = new Set();
    }
    
    // Pre-calculate colors and halfPanel outside loop
    const primaryColor = screen.color || '#808080';
    const secondaryColor = screen.color2 || darkenColor(primaryColor, 30);
    const halfPanel = allPanels['CB5_MKII_HALF'];
    
    // Draw panels for this screen - optimized loop
    for(let c = 0; c < pw; c++){
      const xBase = offsetX + (c * p.res_x);
      
      for(let r = 0; r < totalRows; r++){
        const panelKey = `${c},${r}`;
        
        // Skip deleted panels
        if(deletedPanelsForScreen.has(panelKey)) continue;
        
        // Determine if this is the half panel row
        const isHalfPanelRow = hasCB5HalfRow && (r === ph);
        
        // Calculate panel pixel dimensions
        const panelResX = isHalfPanelRow ? halfPanel.res_x : p.res_x;
        const panelResY = isHalfPanelRow ? halfPanel.res_y : p.res_y;
        
        // Calculate Y position
        const y = offsetY + (r * p.res_y);
        
        // Skip if out of view
        if(xBase >= canvasResX || y >= canvasResY || xBase + panelResX <= 0 || y + panelResY <= 0) continue;
        
        // Use alternating colors for checkerboard pattern
        const fillColor = ((c + r) % 2 === 0) ? primaryColor : secondaryColor;
        ctx.fillStyle = fillColor;
        ctx.fillRect(xBase, y, panelResX, panelResY);
        
        // Off-white outline for visibility
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 2;
        ctx.strokeRect(xBase, y, panelResX, panelResY);
        
        // Draw panel label - always use white text for visibility
        ctx.fillStyle = '#FFFFFF';
        const fontSize = Math.max(12, Math.min(panelResX, panelResY) / 4);
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${c+1}.${r+1}`, xBase + panelResX/2, y + panelResY/2);
      }
    }
    
    // Add X/Y coordinates in top-left corner (if enabled for this screen)
    if(screen.showCoordinates !== false) {
      const coordFontSize = Math.max(24, Math.min(p.res_x, p.res_y) / 4);
      ctx.font = `bold ${coordFontSize}px Arial`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      const coordPadding = 12;
      const textX = offsetX + coordPadding;
      const textY = offsetY + coordPadding;
      const lineHeight = coordFontSize + 6;

      // Measure text width for dynamic background sizing
      const xText = `X: ${screenData.canvasX || 0}`;
      const yText = `Y: ${screenData.canvasY || 0}`;
      const maxTextWidth = Math.max(ctx.measureText(xText).width, ctx.measureText(yText).width);

      // Semi-transparent dark background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(textX - 6, textY - 6, maxTextWidth + 16, lineHeight * 2 + 8);

      // Draw coordinates
      ctx.fillStyle = '#f0f0f0';
      ctx.fillText(xText, textX, textY);
      ctx.fillText(yText, textX, textY + lineHeight);
    }
    
    // Add screen name overlay - simplified shadow
    const screenName = screen.name;
    if(screenName) {
      const wallCenterX = offsetX + (wallResX / 2);
      const wallCenterY = offsetY + (wallResY / 2);
      const baseFontSize = Math.min(wallResX, wallResY) * 0.15;
      
      ctx.font = `bold ${baseFontSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Simple shadow (reduced from 13 to 4 draws)
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillText(screenName, wallCenterX + 3, wallCenterY + 3);
      ctx.fillText(screenName, wallCenterX - 2, wallCenterY + 2);
      
      // Yellow text on top
      ctx.fillStyle = '#FFFF00';
      ctx.fillText(screenName, wallCenterX, wallCenterY);
    }
    
    // Add screen resolution at bottom-left (if enabled for this screen) - simplified shadow
    if(screen.showPixelDimensions !== false) {
      const resFontSize = Math.max(14, Math.min(wallResX, wallResY) * 0.06);
      ctx.font = `bold ${resFontSize}px Arial`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      
      const resTextX = offsetX + 10;
      const resTextY = offsetY + wallResY - 10;
      const resText = `${wallResX} × ${wallResY}`;
      
      // Simple shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillText(resText, resTextX + 2, resTextY + 2);
      
      // Yellow text
      ctx.fillStyle = '#FFFF00';
      ctx.fillText(resText, resTextX, resTextY);
    }

    // Draw X crosshair if enabled for this screen (default: on)
    if(screen.showCrosshair !== false) {
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 5]); // Dashed line for visibility

      // Line from top-left to bottom-right
      ctx.beginPath();
      ctx.moveTo(offsetX, offsetY);
      ctx.lineTo(offsetX + wallResX, offsetY + wallResY);
      ctx.stroke();

      // Line from top-right to bottom-left
      ctx.beginPath();
      ctx.moveTo(offsetX + wallResX, offsetY);
      ctx.lineTo(offsetX, offsetY + wallResY);
      ctx.stroke();

      ctx.setLineDash([]); // Reset to solid line
    }

    // Add GLAB logo in bottom right corner
    const logoFontSize = Math.max(12, Math.min(wallResX, wallResY) * 0.05);
    ctx.font = `bold ${logoFontSize}px Arial`;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';

    const logoTextX = offsetX + wallResX - 10;
    const logoTextY = offsetY + wallResY - 10;
    const logoText = 'GLAB';

    // Simple shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillText(logoText, logoTextX + 2, logoTextY + 2);

    // White text for logo
    ctx.fillStyle = '#ffffff';
    ctx.fillText(logoText, logoTextX, logoTextY);
  });

  // Cache the canvas state BEFORE drawing the border (for clean export)
  cachedCanvasImageDataForExport = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // Draw canvas boundary border (so users can see canvas edges when zoomed)
  // This is only for display, not included in export
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 6;
  ctx.setLineDash([]);
  ctx.strokeRect(3, 3, canvasResX - 6, canvasResY - 6);

  // Update info display
  let totalWalls = 0;
  let totalPanels = 0;
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    if(screen.visible && screen.data.panelsWide > 0 && screen.data.panelsHigh > 0) {
      totalWalls++;
      totalPanels += screen.data.panelsWide * screen.data.panelsHigh;
    }
  });

  // Update canvas info display (includes selected screen coordinates if any)
  updateCanvasInfoDisplay();

  // Cache the canvas state WITH border for quick selection highlighting
  cachedCanvasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  // Setup canvas view interactivity
  setupCanvasViewInteractivity();
  
  // Force browser repaint using multiple techniques
  const viewport = document.getElementById('canvasViewport');
  if(viewport) {
    // Method 1: willChange hint
    viewport.style.willChange = 'transform';
    void viewport.offsetHeight;
    viewport.style.willChange = 'auto';
    
    // Method 2: Force repaint by toggling visibility
    const originalDisplay = viewport.style.display;
    viewport.style.display = 'none';
    void viewport.offsetHeight; // Force reflow
    viewport.style.display = originalDisplay || '';
  }
  
  // Method 3: Force repaint on canvas with opacity trick
  canvas.style.opacity = '0.9999';
  void canvas.offsetHeight;
  canvas.style.opacity = '1';
  
  // Method 4: Force a transform update on viewport
  if(viewport) {
    const currentTransform = viewport.style.transform;
    viewport.style.transform = 'none';
    void viewport.offsetHeight;
    viewport.style.transform = currentTransform;
  }
  
  // WORKAROUND: Second render after delay
  if(!isSecondRenderPass) {
    isSecondRenderPass = true;
    setTimeout(() => {
      showCanvasView();
      isSecondRenderPass = false;
    }, 50);
  }
}

// Cached canvas image for fast selection highlighting (includes border)
let cachedCanvasImageData = null;
// Cached canvas image for export (without border)
let cachedCanvasImageDataForExport = null;
let canvasViewDragging = false;
let canvasViewDragStartX = 0;
let canvasViewDragStartY = 0;
let canvasViewStartOffsetX = 0;
let canvasViewStartOffsetY = 0;
let canvasViewOriginalImageData = null;
let canvasViewFocused = false;
let canvasViewKeyPressed = new Set();
let canvasViewKeyInterval = null;
let canvasViewRedrawTimeout = null;
let isSecondRenderPass = false; // Flag to prevent infinite recursion
let draggedScreenId = null; // Track which screen is being dragged
let selectedCanvasScreenId = null; // Track which screen is selected (highlighted)

// Update canvas info display with selected screen coordinates
function updateCanvasInfoDisplay() {
  const infoEl = document.getElementById('canvasInfo');
  if(!infoEl) return;

  const canvas = document.getElementById('canvasView');
  const canvasResX = canvas ? canvas.width : 0;
  const canvasResY = canvas ? canvas.height : 0;

  // Count visible screens and panels
  let totalWalls = 0;
  let totalPanels = 0;
  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    if(screen.visible && screen.data.panelsWide > 0 && screen.data.panelsHigh > 0) {
      totalWalls++;
      totalPanels += screen.data.panelsWide * screen.data.panelsHigh;
    }
  });

  let html = `Canvas Resolution: ${canvasResX} × ${canvasResY} px<br>` +
             `Visible Screens: ${totalWalls}<br>` +
             `Total Panels: ${totalPanels}`;

  // Add selected screen info if one is selected
  if(selectedCanvasScreenId && screens[selectedCanvasScreenId]) {
    const screen = screens[selectedCanvasScreenId];
    const x = screen.data.canvasX || 0;
    const y = screen.data.canvasY || 0;
    html += `<br><span style="color: var(--primary);">Selected: ${screen.name} (X: ${x}, Y: ${y})</span>`;
  }

  infoEl.innerHTML = html;
}

// Draw selection highlight on canvas without full redraw
function drawSelectionHighlight() {
  if(!selectedCanvasScreenId || !screens[selectedCanvasScreenId]) return;

  const allPanels = getAllPanels();
  const canvas = document.getElementById('canvasView');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  const selectedScreen = screens[selectedCanvasScreenId];
  if(!selectedScreen.visible) return;

  const screenData = selectedScreen.data;
  const panelType = screenData.panelType || 'CB5_MKII';
  const p = allPanels[panelType];

  if(!p || !p.res_x || !p.res_y || !screenData.panelsWide || !screenData.panelsHigh) return;

  const offsetX = screenData.canvasX || 0;
  const offsetY = screenData.canvasY || 0;

  // Check if CB5 half panel row is enabled for this screen
  const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';

  // Calculate wall resolution accounting for CB5 half panels
  let wallResX, wallResY;
  if(hasCB5HalfRow) {
    const halfPanel = allPanels['CB5_MKII_HALF'];
    wallResX = screenData.panelsWide * p.res_x;
    wallResY = screenData.panelsHigh * p.res_y + halfPanel.res_y;
  } else {
    wallResX = screenData.panelsWide * p.res_x;
    wallResY = screenData.panelsHigh * p.res_y;
  }
  
  // Draw thick cyan highlight border
  ctx.strokeStyle = '#00FFFF';
  ctx.lineWidth = 6;
  ctx.setLineDash([]);
  ctx.strokeRect(offsetX - 3, offsetY - 3, wallResX + 6, wallResY + 6);
  
  // Draw inner white border for contrast
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 2;
  ctx.strokeRect(offsetX - 6, offsetY - 6, wallResX + 12, wallResY + 12);
}

// Helper function to detect which screen is clicked
function getScreenAtPosition(mouseX, mouseY) {
  const allPanels = getAllPanels();

  // Check screens in reverse order (top screen first)
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numB - numA; // Reverse order
  });

  for(const screenId of screenIds) {
    const screen = screens[screenId];

    if(!screen.visible) continue;

    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = allPanels[panelType];

    if(!p || !p.res_x || !p.res_y) continue;

    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;

    if(pw === 0 || ph === 0) continue;

    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';

    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    const offsetX = screenData.canvasX || 0;
    const offsetY = screenData.canvasY || 0;
    
    // Check if click is within this screen's bounds
    if(mouseX >= offsetX && mouseX <= offsetX + wallResX &&
       mouseY >= offsetY && mouseY <= offsetY + wallResY) {
      return screenId;
    }
  }
  
  return null;
}


// Flag to prevent duplicate event listener setup
let canvasInteractivityInitialized = false;

function setupCanvasViewInteractivity() {
  const canvas = document.getElementById('canvasView');
  if(!canvas) return;

  // Initialize history with current position if history is empty
  if(canvasMoveHistory.length === 0) {
    const initialState = {
      x: parseInt(document.getElementById('canvasX').value) || 0,
      y: parseInt(document.getElementById('canvasY').value) || 0
    };
    canvasMoveHistory.push(initialState);
    canvasMoveHistoryIndex = 0;
    updateCanvasUndoRedoButtons();
  }

  // Prevent duplicate event listeners - only setup once
  if(canvasInteractivityInitialized) return;
  canvasInteractivityInitialized = true;

  canvas.style.cursor = 'grab';
  canvas.tabIndex = 0; // Make canvas focusable
  
  // Add click to focus for keyboard controls
  canvas.addEventListener('click', function(e) {
    canvas.focus();
    canvasViewFocused = true;
  });
  
  canvas.addEventListener('focus', function(e) {
    canvasViewFocused = true;
    // Save original state when focusing
    const ctx = canvas.getContext('2d');
    canvasViewOriginalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  });
  
  canvas.addEventListener('blur', function(e) {
    canvasViewFocused = false;
    canvasViewOriginalImageData = null;
    canvasViewKeyPressed.clear();
    if(canvasViewKeyInterval) {
      clearInterval(canvasViewKeyInterval);
      canvasViewKeyInterval = null;
    }
  });
  
  // Keyboard arrow controls
  canvas.addEventListener('keydown', function(e) {
    if(!canvasViewFocused) return;
    
    if(['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      e.preventDefault();
      
      // Only move if this key wasn't already pressed (prevents repeat events)
      if(!canvasViewKeyPressed.has(e.key)) {
        canvasViewKeyPressed.add(e.key);
        moveCanvasWithKeys(); // Move once per key press
      }
    }
  });
  
  canvas.addEventListener('keyup', function(e) {
    if(['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      e.preventDefault();
      canvasViewKeyPressed.delete(e.key);
      
      // If no more arrow keys pressed, do final redraw with selection highlight
      if(canvasViewKeyPressed.size === 0) {
        // Debounce the redraw - only redraw after 300ms of no key presses
        if(canvasViewRedrawTimeout) {
          clearTimeout(canvasViewRedrawTimeout);
        }
        canvasViewRedrawTimeout = setTimeout(function() {
          showCanvasView();
          // Re-draw selection highlight if there's a selected screen
          if(selectedCanvasScreenId) {
            drawSelectionHighlight();
          }
        }, 300);
      }
    }
  });
  
  function moveCanvasWithKeys() {
    if(canvasViewKeyPressed.size === 0) return;
    
    // Determine which screen to move: selected screen or current screen
    const screenToMove = selectedCanvasScreenId || currentScreenId;
    if(!screenToMove || !screens[screenToMove]) return;
    
    // Get increment value directly - this is the exact pixel amount to move
    const increment = parseInt(document.getElementById('arrowKeyIncrement').value) || 10;
    
    // Get current position from the screen data
    let currentX = screens[screenToMove].data.canvasX || 0;
    let currentY = screens[screenToMove].data.canvasY || 0;
    
    // Apply movement for each pressed key
    if(canvasViewKeyPressed.has('ArrowLeft')) {
      currentX -= increment;
    }
    if(canvasViewKeyPressed.has('ArrowRight')) {
      currentX += increment;
    }
    if(canvasViewKeyPressed.has('ArrowUp')) {
      currentY -= increment;
    }
    if(canvasViewKeyPressed.has('ArrowDown')) {
      currentY += increment;
    }
    
    // Update the screen's position
    screens[screenToMove].data.canvasX = currentX;
    screens[screenToMove].data.canvasY = currentY;
    
    // Update the input values
    document.getElementById('canvasX').value = currentX;
    document.getElementById('canvasY').value = currentY;
    
    // If moving current screen, also update global variables
    if(screenToMove === currentScreenId) {
      canvasOffsetX = currentX;
      canvasOffsetY = currentY;
    }
    
    // Save state after moving
    saveCanvasMoveState();
    
    // Redraw the canvas to show updated position
    showCanvasView();
    
    // Re-draw selection highlight if there's a selected screen
    if(selectedCanvasScreenId) {
      drawSelectionHighlight();
    }
  }
  
  function drawCanvasPreviewWithGuides(newOffsetX, newOffsetY, snapMode) {
    if(!draggedScreenId || !screens[draggedScreenId]) return;

    const allPanels = getAllPanels();
    const screen = screens[draggedScreenId];
    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = allPanels[panelType];
    if(!p || !p.res_x || !p.res_y) return;

    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;

    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';

    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    const pixelWidth = p.res_x;
    const pixelHeight = p.res_y;
    const ctx = canvas.getContext('2d');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    
    // Restore original image
    if(canvasViewOriginalImageData) {
      ctx.putImageData(canvasViewOriginalImageData, 0, 0);
    }
    
    // Draw snap guide lines if in markers mode - YELLOW and THICKER
    if(snapMode === 'markers') {
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      
      // Vertical guide lines - edges (0, 1) and center (1/2)
      const xPositions = [0, 1/2, 1];
      xPositions.forEach(ratio => {
        const x = canvasWidth * ratio;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
      });
      
      // Horizontal guide lines - edges (0, 1) and center (1/2)
      const yPositions = [0, 1/2, 1];
      yPositions.forEach(ratio => {
        const y = canvasHeight * ratio;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasWidth, y);
        ctx.stroke();
      });
      
      ctx.setLineDash([]);
    }
    
    // Draw wall preview outline (solid green, THICKER)
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 5;
    ctx.setLineDash([]);
    ctx.strokeRect(newOffsetX, newOffsetY, wallResX, wallResY);
    
    // Draw X pattern across the wall
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    // Top-left to bottom-right
    ctx.moveTo(newOffsetX, newOffsetY);
    ctx.lineTo(newOffsetX + wallResX, newOffsetY + wallResY);
    // Top-right to bottom-left
    ctx.moveTo(newOffsetX + wallResX, newOffsetY);
    ctx.lineTo(newOffsetX, newOffsetY + wallResY);
    ctx.stroke();
    
    // Draw corner panels (one panel at each corner)
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 3;
    
    // Top-left panel
    if(newOffsetX + pixelWidth > 0 && newOffsetY + pixelHeight > 0) {
      ctx.strokeRect(newOffsetX, newOffsetY, pixelWidth, pixelHeight);
    }
    
    // Top-right panel
    if(newOffsetX + wallResX - pixelWidth < canvasWidth && newOffsetY + pixelHeight > 0) {
      ctx.strokeRect(newOffsetX + wallResX - pixelWidth, newOffsetY, pixelWidth, pixelHeight);
    }
    
    // Bottom-left panel
    if(newOffsetX + pixelWidth > 0 && newOffsetY + wallResY - pixelHeight < canvasHeight) {
      ctx.strokeRect(newOffsetX, newOffsetY + wallResY - pixelHeight, pixelWidth, pixelHeight);
    }
    
    // Bottom-right panel
    if(newOffsetX + wallResX - pixelWidth < canvasWidth && newOffsetY + wallResY - pixelHeight < canvasHeight) {
      ctx.strokeRect(newOffsetX + wallResX - pixelWidth, newOffsetY + wallResY - pixelHeight, pixelWidth, pixelHeight);
    }
    
    // Draw center lines through the wall (yellow)
    const centerX = newOffsetX + wallResX / 2;
    const centerY = newOffsetY + wallResY / 2;
    
    ctx.strokeStyle = '#FFFF00';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 3]);
    
    // Vertical center line
    ctx.beginPath();
    ctx.moveTo(centerX, newOffsetY);
    ctx.lineTo(centerX, newOffsetY + wallResY);
    ctx.stroke();
    
    // Horizontal center line
    ctx.beginPath();
    ctx.moveTo(newOffsetX, centerY);
    ctx.lineTo(newOffsetX + wallResX, centerY);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // Draw center crosshair for markers mode
    if(snapMode === 'markers') {
      if(centerX >= 0 && centerX <= canvasWidth && centerY >= 0 && centerY <= canvasHeight) {
        ctx.strokeStyle = '#FFFF00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }
  
  canvas.addEventListener('mousedown', function(e) {
    // Only handle left mouse button (button === 0) for screen selection/dragging
    // Middle mouse button (button === 1) is handled by initCanvasPanning for panning
    if(e.button !== 0) return;

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    // Detect which screen was clicked
    const clickedScreenId = getScreenAtPosition(mouseX, mouseY);
    
    if(clickedScreenId) {
      const screen = screens[clickedScreenId];
      const offsetX = screen.data.canvasX || 0;
      const offsetY = screen.data.canvasY || 0;
      
      // Set as selected screen IMMEDIATELY
      selectedCanvasScreenId = clickedScreenId;
      
      // Update X/Y input boxes to show selected screen's position
      document.getElementById('canvasX').value = offsetX;
      document.getElementById('canvasY').value = offsetY;
      
      draggedScreenId = clickedScreenId;
      canvasViewDragging = true;
      canvasViewDragStartX = mouseX;
      canvasViewDragStartY = mouseY;
      canvasViewStartOffsetX = offsetX;
      canvasViewStartOffsetY = offsetY;
      
      // Focus the canvas
      canvas.focus();
      
      // Use cached canvas image for instant highlight (no full redraw)
      const ctx = canvas.getContext('2d');
      if(cachedCanvasImageData) {
        ctx.putImageData(cachedCanvasImageData, 0, 0);
      }
      drawSelectionHighlight();
      updateCanvasInfoDisplay();

      // Save this state (with highlight) for drag preview
      canvasViewOriginalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      canvas.style.cursor = 'grabbing';
      e.preventDefault();
    } else {
      // Clicked on empty area - deselect
      if(selectedCanvasScreenId) {
        selectedCanvasScreenId = null;
        updateCanvasInfoDisplay();
        // Restore cached image without highlight
        const ctx = canvas.getContext('2d');
        if(cachedCanvasImageData) {
          ctx.putImageData(cachedCanvasImageData, 0, 0);
        }
      }
    }
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if(!canvasViewDragging || !draggedScreenId) return;

    const allPanels = getAllPanels();
    const screen = screens[draggedScreenId];
    if(!screen) return;

    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = allPanels[panelType];
    if(!p || !p.res_x || !p.res_y) return;

    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;

    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';

    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    const pixelWidth = p.res_x;
    const pixelHeight = p.res_y;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    const deltaX = mouseX - canvasViewDragStartX;
    const deltaY = mouseY - canvasViewDragStartY;
    
    let newOffsetX = canvasViewStartOffsetX + deltaX;
    let newOffsetY = canvasViewStartOffsetY + deltaY;
    
    // Get snap mode (checkbox)
    const snapEnabled = snapModeEnabled;
    const snapMode = snapEnabled ? 'markers' : 'none';
    // Snap threshold in canvas pixels - larger on mobile for better feel
    // On a 4K canvas (3840px), 80px is about 2% of width - feels firm
    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const snapThreshold = isMobile ? 80 : 30;
    
    if(snapMode === 'markers') {
      // Snap to canvas position markers - now snaps edges and center only
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      
      // Calculate all wall positions
      const wallLeft = newOffsetX;
      const wallRight = newOffsetX + wallResX;
      const wallTop = newOffsetY;
      const wallBottom = newOffsetY + wallResY;
      const wallCenterX = newOffsetX + wallResX / 2;
      const wallCenterY = newOffsetY + wallResY / 2;
      
      // X-axis markers - center only
      const xMarkers = [
        canvasWidth / 2            // Center
      ];
      
      // X-axis edge markers (prioritized)
      const xEdgeMarkers = [
        0,                          // Left edge
        canvasWidth                 // Right edge
      ];
      
      // Y-axis markers - center only
      const yMarkers = [
        canvasHeight / 2           // Center
      ];
      
      // Y-axis edge markers (prioritized)
      const yEdgeMarkers = [
        0,                          // Top edge
        canvasHeight                // Bottom edge
      ];
      
      // Find best X snap (check left edge, right edge, and center)
      let bestXSnap = null;
      let minXDist = Infinity;
      
      // First check center marker
      xMarkers.forEach(marker => {
        // Check left edge
        const leftDist = Math.abs(wallLeft - marker);
        if(leftDist < minXDist && leftDist < snapThreshold) {
          minXDist = leftDist;
          bestXSnap = {marker: marker, edge: 'left'};
        }
        
        // Check right edge
        const rightDist = Math.abs(wallRight - marker);
        if(rightDist < minXDist && rightDist < snapThreshold) {
          minXDist = rightDist;
          bestXSnap = {marker: marker, edge: 'right'};
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterX - marker);
        if(centerDist < minXDist && centerDist < snapThreshold) {
          minXDist = centerDist;
          bestXSnap = {marker: marker, edge: 'center'};
        }
      });
      
      // Then check edge markers with priority (they override fractional if within threshold)
      xEdgeMarkers.forEach(marker => {
        // Check left edge - prioritized
        const leftDist = Math.abs(wallLeft - marker);
        if(leftDist < snapThreshold) {
          if(!bestXSnap || leftDist <= minXDist) {
            minXDist = leftDist;
            bestXSnap = {marker: marker, edge: 'left', priority: true};
          }
        }
        
        // Check right edge - prioritized
        const rightDist = Math.abs(wallRight - marker);
        if(rightDist < snapThreshold) {
          if(!bestXSnap || rightDist <= minXDist) {
            minXDist = rightDist;
            bestXSnap = {marker: marker, edge: 'right', priority: true};
          }
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterX - marker);
        if(centerDist < snapThreshold) {
          if(!bestXSnap || centerDist <= minXDist) {
            minXDist = centerDist;
            bestXSnap = {marker: marker, edge: 'center', priority: true};
          }
        }
      });
      
      // Apply X snap
      if(bestXSnap) {
        if(bestXSnap.edge === 'left') {
          newOffsetX = bestXSnap.marker;
        } else if(bestXSnap.edge === 'right') {
          newOffsetX = bestXSnap.marker - wallResX;
        } else if(bestXSnap.edge === 'center') {
          newOffsetX = bestXSnap.marker - wallResX / 2;
        }
      }
      
      // Find best Y snap (check top edge, bottom edge, and center)
      let bestYSnap = null;
      let minYDist = Infinity;
      
      // First check center marker
      yMarkers.forEach(marker => {
        // Check top edge
        const topDist = Math.abs(wallTop - marker);
        if(topDist < minYDist && topDist < snapThreshold) {
          minYDist = topDist;
          bestYSnap = {marker: marker, edge: 'top'};
        }
        
        // Check bottom edge
        const bottomDist = Math.abs(wallBottom - marker);
        if(bottomDist < minYDist && bottomDist < snapThreshold) {
          minYDist = bottomDist;
          bestYSnap = {marker: marker, edge: 'bottom'};
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterY - marker);
        if(centerDist < minYDist && centerDist < snapThreshold) {
          minYDist = centerDist;
          bestYSnap = {marker: marker, edge: 'center'};
        }
      });
      
      // Then check edge markers with priority (they override fractional if within threshold)
      yEdgeMarkers.forEach(marker => {
        // Check top edge - prioritized
        const topDist = Math.abs(wallTop - marker);
        if(topDist < snapThreshold) {
          if(!bestYSnap || topDist <= minYDist) {
            minYDist = topDist;
            bestYSnap = {marker: marker, edge: 'top', priority: true};
          }
        }
        
        // Check bottom edge - prioritized
        const bottomDist = Math.abs(wallBottom - marker);
        if(bottomDist < snapThreshold) {
          if(!bestYSnap || bottomDist <= minYDist) {
            minYDist = bottomDist;
            bestYSnap = {marker: marker, edge: 'bottom', priority: true};
          }
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterY - marker);
        if(centerDist < snapThreshold) {
          if(!bestYSnap || centerDist <= minYDist) {
            minYDist = centerDist;
            bestYSnap = {marker: marker, edge: 'center', priority: true};
          }
        }
      });
      
      // Apply Y snap
      if(bestYSnap) {
        if(bestYSnap.edge === 'top') {
          newOffsetY = bestYSnap.marker;
        } else if(bestYSnap.edge === 'bottom') {
          newOffsetY = bestYSnap.marker - wallResY;
        } else if(bestYSnap.edge === 'center') {
          newOffsetY = bestYSnap.marker - wallResY / 2;
        }
      }
    }
    
    // Screen-to-screen snapping - snap to other visible screens' edges
    if(snapEnabled) {
      const screenSnapThreshold = isMobile ? 100 : 40; // Larger on mobile for better feel
      
      // Calculate current wall bounds
      const wallLeft = newOffsetX;
      const wallRight = newOffsetX + wallResX;
      const wallTop = newOffsetY;
      const wallBottom = newOffsetY + wallResY;
      
      let bestScreenXSnap = null;
      let minScreenXDist = Infinity;
      let bestScreenYSnap = null;
      let minScreenYDist = Infinity;
      
      // Check against all other visible screens
      Object.keys(screens).forEach(otherScreenId => {
        if(otherScreenId === draggedScreenId) return; // Skip self
        
        const otherScreen = screens[otherScreenId];
        if(!otherScreen.visible) return; // Skip invisible screens
        
        const otherData = otherScreen.data;
        const otherPanelType = otherData.panelType || 'CB5_MKII';
        const allPanelsSnap = getAllPanels();
        const otherPanel = allPanelsSnap[otherPanelType];
        
        if(!otherPanel || !otherPanel.res_x || !otherPanel.res_y) return;
        
        const otherPw = otherData.panelsWide || 0;
        const otherPh = otherData.panelsHigh || 0;
        
        if(otherPw === 0 || otherPh === 0) return;
        
        // Check if other screen has CB5 half panel row
        const otherHasCB5HalfRow = otherData.addCB5HalfRow && otherPanelType === 'CB5_MKII';
        
        let otherWallResX, otherWallResY;
        if(otherHasCB5HalfRow) {
          const halfPanel = panels['CB5_MKII_HALF'];
          otherWallResX = otherPw * otherPanel.res_x;
          otherWallResY = otherPh * otherPanel.res_y + halfPanel.res_y;
        } else {
          otherWallResX = otherPw * otherPanel.res_x;
          otherWallResY = otherPh * otherPanel.res_y;
        }
        
        const otherLeft = otherData.canvasX || 0;
        const otherRight = otherLeft + otherWallResX;
        const otherTop = otherData.canvasY || 0;
        const otherBottom = otherTop + otherWallResY;
        
        // X-axis snapping: check if walls are vertically overlapping (or close)
        const verticalOverlap = !(wallBottom < otherTop - 50 || wallTop > otherBottom + 50);
        
        if(verticalOverlap) {
          // Snap dragged wall's right edge to other wall's left edge
          const rightToLeftDist = Math.abs(wallRight - otherLeft);
          if(rightToLeftDist < minScreenXDist && rightToLeftDist < screenSnapThreshold) {
            minScreenXDist = rightToLeftDist;
            bestScreenXSnap = { target: otherLeft, edge: 'right' };
          }
          
          // Snap dragged wall's left edge to other wall's right edge
          const leftToRightDist = Math.abs(wallLeft - otherRight);
          if(leftToRightDist < minScreenXDist && leftToRightDist < screenSnapThreshold) {
            minScreenXDist = leftToRightDist;
            bestScreenXSnap = { target: otherRight, edge: 'left' };
          }
          
          // Snap left edges together
          const leftToLeftDist = Math.abs(wallLeft - otherLeft);
          if(leftToLeftDist < minScreenXDist && leftToLeftDist < screenSnapThreshold) {
            minScreenXDist = leftToLeftDist;
            bestScreenXSnap = { target: otherLeft, edge: 'left' };
          }
          
          // Snap right edges together
          const rightToRightDist = Math.abs(wallRight - otherRight);
          if(rightToRightDist < minScreenXDist && rightToRightDist < screenSnapThreshold) {
            minScreenXDist = rightToRightDist;
            bestScreenXSnap = { target: otherRight, edge: 'right' };
          }
        }
        
        // Y-axis snapping: check if walls are horizontally overlapping (or close)
        const horizontalOverlap = !(wallRight < otherLeft - 50 || wallLeft > otherRight + 50);
        
        if(horizontalOverlap) {
          // Snap dragged wall's bottom edge to other wall's top edge
          const bottomToTopDist = Math.abs(wallBottom - otherTop);
          if(bottomToTopDist < minScreenYDist && bottomToTopDist < screenSnapThreshold) {
            minScreenYDist = bottomToTopDist;
            bestScreenYSnap = { target: otherTop, edge: 'bottom' };
          }
          
          // Snap dragged wall's top edge to other wall's bottom edge
          const topToBottomDist = Math.abs(wallTop - otherBottom);
          if(topToBottomDist < minScreenYDist && topToBottomDist < screenSnapThreshold) {
            minScreenYDist = topToBottomDist;
            bestScreenYSnap = { target: otherBottom, edge: 'top' };
          }
          
          // Snap top edges together
          const topToTopDist = Math.abs(wallTop - otherTop);
          if(topToTopDist < minScreenYDist && topToTopDist < screenSnapThreshold) {
            minScreenYDist = topToTopDist;
            bestScreenYSnap = { target: otherTop, edge: 'top' };
          }
          
          // Snap bottom edges together
          const bottomToBottomDist = Math.abs(wallBottom - otherBottom);
          if(bottomToBottomDist < minScreenYDist && bottomToBottomDist < screenSnapThreshold) {
            minScreenYDist = bottomToBottomDist;
            bestScreenYSnap = { target: otherBottom, edge: 'bottom' };
          }
        }
      });
      
      // Apply screen X snap (prioritize screen snapping over canvas markers)
      if(bestScreenXSnap) {
        if(bestScreenXSnap.edge === 'left') {
          newOffsetX = bestScreenXSnap.target;
        } else if(bestScreenXSnap.edge === 'right') {
          newOffsetX = bestScreenXSnap.target - wallResX;
        }
      }
      
      // Apply screen Y snap
      if(bestScreenYSnap) {
        if(bestScreenYSnap.edge === 'top') {
          newOffsetY = bestScreenYSnap.target;
        } else if(bestScreenYSnap.edge === 'bottom') {
          newOffsetY = bestScreenYSnap.target - wallResY;
        }
      }
    }
    
    // Update the dragged screen's canvas position
    if(draggedScreenId && screens[draggedScreenId]) {
      screens[draggedScreenId].data.canvasX = Math.round(newOffsetX);
      screens[draggedScreenId].data.canvasY = Math.round(newOffsetY);

      // If this is the current screen, also update global variables
      if(draggedScreenId === currentScreenId) {
        canvasOffsetX = Math.round(newOffsetX);
        canvasOffsetY = Math.round(newOffsetY);
      }

      // Always update the X/Y input fields for the selected/dragged screen
      document.getElementById('canvasX').value = Math.round(newOffsetX);
      document.getElementById('canvasY').value = Math.round(newOffsetY);

      // Update coordinate display during drag
      updateCanvasInfoDisplay();
    }

    // Draw preview with snap guides
    drawCanvasPreviewWithGuides(newOffsetX, newOffsetY, snapMode);
  });
  
  canvas.addEventListener('mouseup', function(e) {
    if(canvasViewDragging) {
      const wasDraggingCurrentScreen = (draggedScreenId === currentScreenId);
      
      canvasViewDragging = false;
      draggedScreenId = null;
      canvas.style.cursor = 'grab';
      canvasViewOriginalImageData = null;
      
      // Only save current screen data if we weren't dragging the current screen
      // (to avoid overwriting the position we just set during drag)
      if(!wasDraggingCurrentScreen) {
        saveCurrentScreenData();
      }
      
      // Full redraw with actual content
      showCanvasView();

      // Re-draw selection highlight if there's a selected screen
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
        updateCanvasInfoDisplay();
      }

      // Save state after drag completes
      saveCanvasMoveState();
    }
  });

  canvas.addEventListener('mouseleave', function(e) {
    if(canvasViewDragging) {
      const wasDraggingCurrentScreen = (draggedScreenId === currentScreenId);
      
      canvasViewDragging = false;
      draggedScreenId = null;
      canvas.style.cursor = 'grab';
      canvasViewOriginalImageData = null;
      
      // Only save current screen data if we weren't dragging the current screen
      if(!wasDraggingCurrentScreen) {
        saveCurrentScreenData();
      }
      
      // Full redraw with actual content
      showCanvasView();
      
      // Re-draw selection highlight if there's a selected screen
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
      }
      
      // Save state after drag completes
      saveCanvasMoveState();
    }
  });

  // ===== TOUCH EVENT HANDLERS FOR MOBILE =====
  // Single finger = select/drag screens
  // Two-finger = pan and zoom (handled by initCanvasTouchPanZoom)
  let touchDragPending = false;
  let touchLastX = 0;
  let touchLastY = 0;

  canvas.addEventListener('touchstart', function(e) {
    // Only handle single-finger touch for screen selection/dragging
    // Two-finger gestures are handled by initCanvasTouchPanZoom for panning/zooming
    if(e.touches.length !== 1) return;

    const touch = e.touches[0];

    // Single finger always handles screen selection/dragging (at any zoom level)
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const touchX = (touch.clientX - rect.left) * scaleX;
    const touchY = (touch.clientY - rect.top) * scaleY;

    const clickedScreenId = getScreenAtPosition(touchX, touchY);

    if(clickedScreenId) {
      const screen = screens[clickedScreenId];
      const offsetX = screen.data.canvasX || 0;
      const offsetY = screen.data.canvasY || 0;

      selectedCanvasScreenId = clickedScreenId;
      draggedScreenId = clickedScreenId;
      canvasViewDragging = true;
      canvasViewDragStartX = touchX;
      canvasViewDragStartY = touchY;
      canvasViewStartOffsetX = offsetX;
      canvasViewStartOffsetY = offsetY;

      // Update X/Y input boxes to show selected screen's position
      document.getElementById('canvasX').value = offsetX;
      document.getElementById('canvasY').value = offsetY;

      // Simple highlight without heavy operations
      const ctx = canvas.getContext('2d');
      if(cachedCanvasImageData) {
        ctx.putImageData(cachedCanvasImageData, 0, 0);
      }
      drawSelectionHighlight();
      updateCanvasInfoDisplay();

      e.preventDefault();
    } else if(selectedCanvasScreenId) {
      // Tapped empty area - deselect
      selectedCanvasScreenId = null;
      updateCanvasInfoDisplay();
      const ctx = canvas.getContext('2d');
      if(cachedCanvasImageData) {
        ctx.putImageData(cachedCanvasImageData, 0, 0);
      }
    }
  }, {passive: false});

  canvas.addEventListener('touchmove', function(e) {
    // Only handle single-finger for screen dragging
    // Two-finger panning is handled by initCanvasTouchPanZoom
    if(e.touches.length !== 1) return;

    // Handle screen dragging
    if(!canvasViewDragging || !draggedScreenId) return;

    const touch = e.touches[0];

    e.preventDefault();

    touchLastX = touch.clientX;
    touchLastY = touch.clientY;

    // Throttle updates using requestAnimationFrame
    if(!touchDragPending) {
      touchDragPending = true;
      requestAnimationFrame(function() {
        touchDragPending = false;
        if(!canvasViewDragging || !draggedScreenId) return;

        const screen = screens[draggedScreenId];
        if(!screen) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const touchX = (touchLastX - rect.left) * scaleX;
        const touchY = (touchLastY - rect.top) * scaleY;

        const deltaX = touchX - canvasViewDragStartX;
        const deltaY = touchY - canvasViewDragStartY;

        let newOffsetX = Math.round(canvasViewStartOffsetX + deltaX);
        let newOffsetY = Math.round(canvasViewStartOffsetY + deltaY);

        // Apply snapping if enabled
        if(snapModeEnabled) {
          const allPanels = getAllPanels();
          const screenData = screen.data;
          const panelType = screenData.panelType || 'CB5_MKII';
          const p = allPanels[panelType];
          if(p && p.res_x && p.res_y) {
            const pw = screenData.panelsWide || 0;
            const ph = screenData.panelsHigh || 0;
            const wallResX = pw * p.res_x;
            const wallResY = ph * p.res_y;
            // Touch is always mobile, use larger threshold for firm snapping
            const snapThreshold = 80;

            // Canvas edge and center snapping
            const canvasW = canvas.width;
            const canvasH = canvas.height;
            const wallCenterX = newOffsetX + wallResX / 2;
            const wallCenterY = newOffsetY + wallResY / 2;

            // X-axis snap to edges and center
            if(Math.abs(newOffsetX) < snapThreshold) newOffsetX = 0;
            else if(Math.abs(newOffsetX + wallResX - canvasW) < snapThreshold) newOffsetX = canvasW - wallResX;
            else if(Math.abs(wallCenterX - canvasW/2) < snapThreshold) newOffsetX = canvasW/2 - wallResX/2;

            // Y-axis snap to edges and center
            if(Math.abs(newOffsetY) < snapThreshold) newOffsetY = 0;
            else if(Math.abs(newOffsetY + wallResY - canvasH) < snapThreshold) newOffsetY = canvasH - wallResY;
            else if(Math.abs(wallCenterY - canvasH/2) < snapThreshold) newOffsetY = canvasH/2 - wallResY/2;

            // Screen-to-screen snapping
            Object.keys(screens).forEach(otherId => {
              if(otherId === draggedScreenId) return;
              const otherScreen = screens[otherId];
              if(!otherScreen.visible) return;

              const od = otherScreen.data;
              const opt = od.panelType || 'CB5_MKII';
              const allPanelsTouch = getAllPanels();
              const op = allPanelsTouch[opt];
              if(!op) return;

              const oResX = (od.panelsWide || 0) * op.res_x;
              const oResY = (od.panelsHigh || 0) * op.res_y;
              const oX = od.canvasX || 0;
              const oY = od.canvasY || 0;

              // X snapping to other screen
              if(Math.abs(newOffsetX - (oX + oResX)) < snapThreshold) newOffsetX = oX + oResX;
              else if(Math.abs(newOffsetX + wallResX - oX) < snapThreshold) newOffsetX = oX - wallResX;
              else if(Math.abs(newOffsetX - oX) < snapThreshold) newOffsetX = oX;
              else if(Math.abs(newOffsetX + wallResX - (oX + oResX)) < snapThreshold) newOffsetX = oX + oResX - wallResX;

              // Y snapping to other screen
              if(Math.abs(newOffsetY - (oY + oResY)) < snapThreshold) newOffsetY = oY + oResY;
              else if(Math.abs(newOffsetY + wallResY - oY) < snapThreshold) newOffsetY = oY - wallResY;
              else if(Math.abs(newOffsetY - oY) < snapThreshold) newOffsetY = oY;
              else if(Math.abs(newOffsetY + wallResY - (oY + oResY)) < snapThreshold) newOffsetY = oY + oResY - wallResY;
            });
          }
        }

        // Update position
        screens[draggedScreenId].data.canvasX = newOffsetX;
        screens[draggedScreenId].data.canvasY = newOffsetY;

        // If this is the current screen, also update global variables
        if(draggedScreenId === currentScreenId) {
          canvasOffsetX = newOffsetX;
          canvasOffsetY = newOffsetY;
        }

        // Update coordinate display during drag
        updateCanvasInfoDisplay();

        // Simple redraw
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw all screens at their positions
        Object.keys(screens).forEach(id => {
          const s = screens[id];
          if(!s.visible) return;

          const d = s.data;
          const pt = d.panelType || 'CB5_MKII';
          const allPanelsDraw = getAllPanels();
          const panel = allPanelsDraw[pt];
          if(!panel) return;

          const pw = d.panelsWide || 0;
          const ph = d.panelsHigh || 0;
          if(pw <= 0 || ph <= 0) return;

          const resX = pw * panel.res_x;
          const resY = ph * panel.res_y;
          const x = d.canvasX || 0;
          const y = d.canvasY || 0;

          // Draw screen rectangle
          ctx.fillStyle = s.color || '#10b981';
          ctx.globalAlpha = 0.3;
          ctx.fillRect(x, y, resX, resY);
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = s.color || '#10b981';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, resX, resY);

          // Draw screen name
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(s.name, x + resX/2, y + resY/2);
        });

        // Highlight selected screen
        if(selectedCanvasScreenId && screens[selectedCanvasScreenId]) {
          const sel = screens[selectedCanvasScreenId];
          const sd = sel.data;
          const spt = sd.panelType || 'CB5_MKII';
          const allPanelsSel = getAllPanels();
          const sp = allPanelsSel[spt];
          if(sp) {
            const sx = sd.canvasX || 0;
            const sy = sd.canvasY || 0;
            const sw = (sd.panelsWide || 0) * sp.res_x;
            const sh = (sd.panelsHigh || 0) * sp.res_y;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(sx - 2, sy - 2, sw + 4, sh + 4);
            ctx.setLineDash([]);
          }
        }

        // Draw canvas boundary border
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 6;
        ctx.setLineDash([]);
        ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);

        // Draw yellow snap guide lines when snapping is enabled
        if(snapModeEnabled) {
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          ctx.strokeStyle = '#FFFF00';
          ctx.lineWidth = 3;
          ctx.setLineDash([8, 4]);

          // Vertical guide lines - edges (0, 1) and center (1/2)
          [0, 0.5, 1].forEach(ratio => {
            const x = canvasWidth * ratio;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvasHeight);
            ctx.stroke();
          });

          // Horizontal guide lines - edges (0, 1) and center (1/2)
          [0, 0.5, 1].forEach(ratio => {
            const y = canvasHeight * ratio;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvasWidth, y);
            ctx.stroke();
          });

          ctx.setLineDash([]);
        }
      });
    }
  }, {passive: false});

  canvas.addEventListener('touchend', function(e) {
    if(canvasViewDragging) {
      canvasViewDragging = false;
      draggedScreenId = null;
      touchDragPending = false;

      // Full redraw on end
      showCanvasView();
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
        updateCanvasInfoDisplay();
      }
      saveCanvasMoveState();
    }
  });

  canvas.addEventListener('touchcancel', function(e) {
    if(canvasViewDragging) {
      canvasViewDragging = false;
      draggedScreenId = null;
      touchDragPending = false;

      showCanvasView();
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
        updateCanvasInfoDisplay();
      }
      saveCanvasMoveState();
    }
  });
}

// Canvas Zoom Functions
function zoomCanvas(delta) {
  const oldZoom = canvasZoomLevel;
  canvasZoomLevel = Math.max(0.5, Math.min(5.0, canvasZoomLevel + delta));
  
  if(canvasZoomLevel !== oldZoom) {
    // Constrain pan when zooming out
    constrainCanvasPan();
    updateCanvasViewport();
    
    // Re-draw selection highlight if there's a selected screen
    if(selectedCanvasScreenId) {
      drawSelectionHighlight();
    }
  }
}

function setCanvasZoom(percent) {
  const value = parseFloat(percent);
  if(isNaN(value)) return;
  
  canvasZoomLevel = Math.max(0.5, Math.min(5.0, value / 100));
  constrainCanvasPan();
  updateCanvasViewport();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
}

function resetCanvasZoom() {
  canvasZoomLevel = 1.0;
  canvasPanX = 0;
  canvasPanY = 0;
  updateCanvasViewport();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
}

function updateCanvasViewport() {
  const viewport = document.getElementById('canvasViewport');
  const zoomInput = document.getElementById('canvasZoomInput');
  
  if(viewport) {
    // First reset to identity transform to clear any stale state
    viewport.style.transform = 'none';
    void viewport.offsetHeight; // Force reflow
    
    // Now apply the actual transform
    viewport.style.transform = `translate(${canvasPanX}px, ${canvasPanY}px) scale(${canvasZoomLevel})`;
    void viewport.offsetHeight; // Force reflow again
  }
  
  if(zoomInput) {
    zoomInput.value = Math.round(canvasZoomLevel * 100);
  }
}

function constrainCanvasPan() {
  const canvas = document.getElementById('canvasView');
  const wrapper = document.getElementById('canvasViewWrapper');
  if(!canvas || !wrapper) return;

  // Get actual wrapper dimensions from DOM
  const wrapperRect = wrapper.getBoundingClientRect();
  const wrapperWidth = wrapperRect.width || 800;
  const wrapperHeight = wrapperRect.height || 450;

  // Get actual canvas display size from DOM
  const canvasRect = canvas.getBoundingClientRect();
  // At zoom 1.0, the canvas display size equals the wrapper size (due to object-fit)
  // We need the base display size before zoom is applied
  const baseDisplayWidth = wrapperWidth;
  const baseDisplayHeight = wrapperHeight;

  // Calculate scaled size (how big the canvas appears with zoom)
  const scaledWidth = baseDisplayWidth * canvasZoomLevel;
  const scaledHeight = baseDisplayHeight * canvasZoomLevel;

  // Calculate pan limits
  // When zoomed in, we can pan to see the entire scaled canvas
  const minPanX = Math.min(0, wrapperWidth - scaledWidth);
  const minPanY = Math.min(0, wrapperHeight - scaledHeight);
  const maxPanX = 0;
  const maxPanY = 0;

  // Constrain pan
  canvasPanX = Math.max(minPanX, Math.min(maxPanX, canvasPanX));
  canvasPanY = Math.max(minPanY, Math.min(maxPanY, canvasPanY));
}

// Add mouse wheel zoom support
function initCanvasWheelZoom() {
  const wrapper = document.getElementById('canvasViewWrapper');
  if(!wrapper) return;
  
  wrapper.addEventListener('wheel', function(e) {
    // Only zoom if Ctrl key is held, otherwise allow normal scroll
    if(e.ctrlKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.25 : 0.25;
      zoomCanvas(delta);
    }
  }, { passive: false });
}

// Initialize canvas panning (middle mouse button only)
function initCanvasPanning() {
  const wrapper = document.getElementById('canvasViewWrapper');
  const viewport = document.getElementById('canvasViewport');
  if(!wrapper || !viewport) return;

  // Prevent default middle-click behavior (auto-scroll) on the wrapper
  wrapper.addEventListener('mousedown', function(e) {
    if(e.button === 1) {
      e.preventDefault();
    }
  });

  // Middle mouse button (button === 1) for panning
  wrapper.addEventListener('mousedown', function(e) {
    if(e.button === 1) {
      isPanningCanvas = true;
      panStartX = e.clientX - canvasPanX;
      panStartY = e.clientY - canvasPanY;
      viewport.style.cursor = 'grabbing';
      e.preventDefault();
    }
  });

  document.addEventListener('mousemove', function(e) {
    if(isPanningCanvas) {
      canvasPanX = e.clientX - panStartX;
      canvasPanY = e.clientY - panStartY;
      constrainCanvasPan();
      updateCanvasViewport();
    }
  });

  document.addEventListener('mouseup', function(e) {
    if(isPanningCanvas) {
      isPanningCanvas = false;
      viewport.style.cursor = 'grab';
    }
  });
}

// Touch panning and pinch-to-zoom for mobile
// Two-finger drag = pan (like middle mouse on desktop)
// Pinch = zoom
// Single finger = select/drag screens (handled by canvas touch events)
function initCanvasTouchPanZoom() {
  const wrapper = document.getElementById('canvasViewWrapper');
  const viewport = document.getElementById('canvasViewport');
  if(!wrapper || !viewport) return;

  let touchPanStartX = 0;
  let touchPanStartY = 0;
  let touchPanStartPanX = 0;
  let touchPanStartPanY = 0;
  let isTwoFingerPanning = false;
  let initialPinchDistance = 0;
  let initialPinchZoom = 1;

  // Get distance between two touch points
  function getTouchDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  wrapper.addEventListener('touchstart', function(e) {
    // Two-finger touch: prepare for pinch-zoom and pan
    if(e.touches.length === 2) {
      e.preventDefault();
      initialPinchDistance = getTouchDistance(e.touches);
      initialPinchZoom = canvasZoomLevel;

      // Prepare for two-finger pan (works at any zoom level)
      const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      touchPanStartX = midX;
      touchPanStartY = midY;
      touchPanStartPanX = canvasPanX;
      touchPanStartPanY = canvasPanY;
      isTwoFingerPanning = true;
    }
    // Single finger: let canvas handle screen selection/dragging (don't prevent default)
  }, { passive: false });

  wrapper.addEventListener('touchmove', function(e) {
    // Two-finger: pinch-zoom and pan
    if(e.touches.length === 2 && isTwoFingerPanning) {
      e.preventDefault();

      // Pinch zoom
      const currentDistance = getTouchDistance(e.touches);
      const scale = currentDistance / initialPinchDistance;
      const newZoom = Math.max(0.5, Math.min(5.0, initialPinchZoom * scale));

      if(newZoom !== canvasZoomLevel) {
        canvasZoomLevel = newZoom;
        constrainCanvasPan();
        updateCanvasViewport();
      }

      // Two-finger pan (works at any zoom level)
      const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      canvasPanX = touchPanStartPanX + (midX - touchPanStartX);
      canvasPanY = touchPanStartPanY + (midY - touchPanStartY);
      constrainCanvasPan();
      updateCanvasViewport();
    }
    // Single finger: let canvas handle screen dragging
  }, { passive: false });

  wrapper.addEventListener('touchend', function(e) {
    if(e.touches.length < 2) {
      isTwoFingerPanning = false;
      initialPinchDistance = 0;
    }
  });

  wrapper.addEventListener('touchcancel', function(e) {
    isTwoFingerPanning = false;
    initialPinchDistance = 0;
  });
}

// PDF Export Options Modal Functions
let pdfExportOptions = {
  specs: true,
  gearList: true,
  standard: true,
  power: true,
  data: true,
  structure: true
};

function openPdfExportModal() {
  const modal = document.getElementById('pdfExportModal');
  if (modal) {
    // Always reset all checkboxes to ON by default
    document.getElementById('pdfExportSpecs').checked = true;
    document.getElementById('pdfExportGearList').checked = true;
    document.getElementById('pdfExportStandard').checked = true;
    document.getElementById('pdfExportPower').checked = true;
    document.getElementById('pdfExportData').checked = true;
    document.getElementById('pdfExportStructure').checked = true;
    // Eco Friendly and Greyscale default to OFF
    document.getElementById('pdfExportEcoFriendly').checked = false;
    document.getElementById('pdfExportGreyscale').checked = false;
    modal.classList.add('active');
  }
}

function closePdfExportModal() {
  const modal = document.getElementById('pdfExportModal');
  if (modal) {
    modal.classList.remove('active');
  }
}

function confirmPdfExport() {
  // Save the options
  pdfExportOptions.specs = document.getElementById('pdfExportSpecs').checked;
  pdfExportOptions.gearList = document.getElementById('pdfExportGearList').checked;
  pdfExportOptions.standard = document.getElementById('pdfExportStandard').checked;
  pdfExportOptions.power = document.getElementById('pdfExportPower').checked;
  pdfExportOptions.data = document.getElementById('pdfExportData').checked;
  pdfExportOptions.structure = document.getElementById('pdfExportStructure').checked;

  closePdfExportModal();
  exportPDF();
}

function exportPDF(){
  try {
    // Save current screen data first to ensure all toggle states are persisted
    saveCurrentScreenData();

    // Reset print modes first to ensure clean state
    ecoPrintMode = false;
    greyscalePrintMode = false;

    // Enable eco-friendly printing mode if checkbox is checked (lighter colors, white backgrounds)
    const ecoFriendlyCheckbox = document.getElementById('pdfExportEcoFriendly');
    if (ecoFriendlyCheckbox && ecoFriendlyCheckbox.checked) {
      ecoPrintMode = true;
    }

    // Enable greyscale printing mode if checkbox is checked
    const greyscaleCheckbox = document.getElementById('pdfExportGreyscale');
    if (greyscaleCheckbox && greyscaleCheckbox.checked) {
      greyscalePrintMode = true;
    }

    if(!window.jspdf || !window.html2canvas){
      alert('PDF export libraries not loaded. Please check your internet connection and refresh the page.');
      ecoPrintMode = false; // Reset on error
      greyscalePrintMode = false;
      return;
    }

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'p',
      unit: 'mm',
      format: 'a4',
      compress: true
    });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 10;
    let yOffset = margin;
    
    // Save current screen so we can restore it later
    const originalScreenId = currentScreenId;
    
    // Create and show loading overlay to hide screen switching
    const overlay = document.createElement('div');
    overlay.id = 'pdfExportOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 26, 26, 1.0);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
    `;
    overlay.innerHTML = `
      <div style="font-size: 24px; margin-bottom: 20px;">Generating PDF...</div>
      <div id="pdfProgress" style="font-size: 16px; color: #888;">Preparing...</div>
      <div style="width: 200px; height: 4px; background: #333; border-radius: 2px; margin-top: 20px; overflow: hidden;">
        <div id="pdfProgressBar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s;"></div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    function updateProgress(text, percent) {
      const progressText = document.getElementById('pdfProgress');
      const progressBar = document.getElementById('pdfProgressBar');
      if(progressText) progressText.textContent = text;
      if(progressBar) progressBar.style.width = percent + '%';
    }
    
    function removeOverlay() {
      const overlay = document.getElementById('pdfExportOverlay');
      if(overlay) overlay.remove();
      // Reset print modes and re-render with normal colors
      if (ecoPrintMode || greyscalePrintMode) {
        ecoPrintMode = false;
        greyscalePrintMode = false;
        generateLayout('standard');
        generateLayout('power');
        generateLayout('data');
        generateStructureLayout();
      }
    }
    
    function checkPageBreak(heightNeeded) {
      if (yOffset + heightNeeded > pageHeight - margin) {
        pdf.addPage();
        yOffset = margin;
        return true;
      }
      return false;
    }
    
    // Title page
    pdf.setFontSize(16);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(0, 0, 0);
    pdf.text('LED Wall Calculator Report', margin, yOffset);
    
    // Add timestamp to the right of the title
    pdf.setFontSize(9);
    pdf.setFont(undefined, 'normal');
    pdf.setTextColor(100, 100, 100);
    const timestamp = new Date().toLocaleString();
    const timestampText = `Generated: ${timestamp}`;
    const timestampWidth = pdf.getTextWidth(timestampText);
    pdf.text(timestampText, pageWidth - margin - timestampWidth, yOffset);
    yOffset += 10;
    
    // Get all screen IDs sorted
    const screenIds = Object.keys(screens).sort((a, b) => {
      const numA = parseInt(a.split('_')[1]);
      const numB = parseInt(b.split('_')[1]);
      return numA - numB;
    });
    
    // ========== CALCULATE PROCESSOR GROUPS ACROSS ALL SCREENS ==========
    // Group screens by processor type and calculate combined totals
    const processorGroups = {}; // { processorType: { screens: [], totalMainPorts: 0, hasAnyRedundancy: false, firstScreenId: null } }
    
    screenIds.forEach(screenId => {
      const screen = screens[screenId];
      if(!screen || !screen.data) return;
      
      const processorType = screen.data.processor || 'Brompton_SX40';
      const calcData = screen.calculatedData || {};
      const dataLines = calcData.dataLines || 0;
      const hasRedundancy = screen.data.redundancy || false;
      const hasProcessorRedundancy = screen.data.processorRedundancy || false;
      const isIndirectMode = screen.data.mx40ConnectionMode === 'indirect';

      if(!processorGroups[processorType]) {
        processorGroups[processorType] = {
          screens: [],
          totalMainPorts: 0,
          totalPixels: 0,
          hasAnyRedundancy: false,
          hasAnyProcessorRedundancy: false,
          hasAnyIndirectMode: false,
          firstScreenId: screenId,
          firstScreenName: screen.name
        };
      }

      const screenPixels = calcData.totalPixels || 0;

      processorGroups[processorType].screens.push({
        screenId: screenId,
        screenName: screen.name,
        mainPorts: dataLines,
        hasRedundancy: hasRedundancy,
        totalPixels: screenPixels
      });
      processorGroups[processorType].totalMainPorts += dataLines;
      processorGroups[processorType].totalPixels += screenPixels;
      if(hasRedundancy) {
        processorGroups[processorType].hasAnyRedundancy = true;
      }
      if(hasProcessorRedundancy) {
        processorGroups[processorType].hasAnyProcessorRedundancy = true;
      }
      if(isIndirectMode) {
        processorGroups[processorType].hasAnyIndirectMode = true;
      }
    });
    
    // Calculate processor and distribution box counts for each group
    // IMPORTANT: For redundancy, we double the distribution box count (not the port count)
    // because each XD/distro box is dedicated to either main OR backup - can't mix
    // For processor redundancy, we double the processor count at the end
    Object.keys(processorGroups).forEach(processorType => {
      const group = processorGroups[processorType];
      const totalMainPorts = group.totalMainPorts;
      const hasRedundancy = group.hasAnyRedundancy;
      const hasProcessorRedundancy = group.hasAnyProcessorRedundancy;
      
      let processorCount = 0;
      let distBoxCount = 0;
      let distBoxName = '';
      
      if(processorType === 'Brompton_SX40') {
        // SX40: Each XD has 10 ports, each SX40 supports 4 XDs
        // Calculate XDs needed for main lines first
        const mainXDs = totalMainPorts > 0 ? Math.ceil(totalMainPorts / 10) : 0;
        // If redundancy, double the XD count (separate XDs for backup)
        distBoxCount = hasRedundancy ? mainXDs * 2 : mainXDs;
        processorCount = distBoxCount > 0 ? Math.ceil(distBoxCount / 4) : 0;
        distBoxName = 'XD';
      } else if(processorType === 'Brompton_S8') {
        // S8: 8 ports per processor
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 8) : 0;
        distBoxCount = 0;
      } else if(processorType === 'Brompton_M2') {
        // M2: 4 ports per processor
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 4) : 0;
        distBoxCount = 0;
      } else if(processorType === 'Brompton_S4') {
        // S4: 4 ports per processor
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 4) : 0;
        distBoxCount = 0;
      } else if(processorType === 'NovaStar_MX40_Pro') {
        // MX40 Pro logic:
        // Direct mode: 20 ports per processor
        // Indirect mode: 10 ports per CVT box, 4 CVTs per processor max
        const groupTotalPixels = group.totalPixels || 0;
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        const processorsByPixels = groupTotalPixels > 0 ? Math.ceil(groupTotalPixels / 9000000) : 0;

        if(group.hasAnyIndirectMode) {
          // Indirect mode: CVT boxes needed
          distBoxCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 10) : 0;
          distBoxName = 'CVT-10 Pro';
          // Processor count: max of pixels needed OR CVT boxes needed (4 CVTs per processor)
          const processorsByCVTs = Math.ceil(distBoxCount / 4);
          processorCount = Math.max(processorsByPixels, processorsByCVTs);
        } else {
          // Direct mode: no CVT boxes, processor count based on ports AND pixels
          const processorsByPorts = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 20) : 0;
          processorCount = Math.max(processorsByPixels, processorsByPorts);
        }
      } else {
        // Default/custom processor - use per-screen calculation
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 8) : group.screens.length;
        distBoxCount = 0;
      }
      
      // If processor redundancy is enabled, double the processor count
      if(hasProcessorRedundancy && processorCount > 0) {
        processorCount *= 2;
      }
      
      group.processorCount = processorCount;
      group.distBoxCount = distBoxCount;
      group.distBoxName = distBoxName;
      // Store for display purposes
      group.totalPorts = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
    });
    
    console.log('Processor groups calculated:', processorGroups);
    
    // Add summary of all screens (count only, no names)
    pdf.setFontSize(10);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(0, 0, 0);
    pdf.text(`Total Screens: ${screenIds.length}`, margin, yOffset);
    yOffset += 10;
    
    // Process each screen
    let screenIndex = 0;
    
    function processNextScreen() {
      if(screenIndex >= screenIds.length) {
        // All screens processed, finalize PDF (canvas view removed to reduce file size)
        finalizePDF();
        return;
      }

      const screenId = screenIds[screenIndex];
      const screen = screens[screenId];

      updateProgress(`Processing screen ${screenIndex + 1} of ${screenIds.length}: ${screen.name}`,
        Math.round((screenIndex / screenIds.length) * 80));

      // Switch to this screen to load its data
      switchToScreen(screenId);

      // Wait for calculate to complete, then capture
      setTimeout(() => {
        // Add page break before each screen (except first)
        if(screenIndex > 0) {
          pdf.addPage();
          yOffset = margin;
        }

        // ========== PAGE 1: Screen header + Two columns (Specs left, Gear List right) ==========

        // Screen header
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text(`Screen ${screenIndex + 1}: ${screen.name}`, margin, yOffset);
        yOffset += 8;

        // Two-column layout setup
        const col1X = margin;
        const col2X = pageWidth / 2 + 2;
        const colWidth = (pageWidth - 2 * margin - 4) / 2;
        const lineHeight = 3.5;
        let col1Y = yOffset;
        let col2Y = yOffset;

        // ========== LEFT COLUMN: SPECS (from screen data) ==========
        const allPanels = getAllPanels();
        const allProcessors = getAllProcessors();
        const data = screen.data;
        const calcData = screen.calculatedData || {};
        const panelType = data.panelType || 'CB5_MKII';
        const p = allPanels[panelType];
        const pw = parseInt(data.panelsWide) || 0;
        const ph = parseInt(data.panelsHigh) || 0;
        const pr = allProcessors[data.processor] || allProcessors['Brompton_SX40'];

        function addSpecLine(label, value) {
          if(value === undefined || value === null || value === '') return;
          pdf.setFontSize(8);
          pdf.setFont(undefined, 'bold');
          pdf.text(label, col1X, col1Y);
          const labelWidth = pdf.getTextWidth(label);
          pdf.setFont(undefined, 'normal');
          pdf.text(' ' + String(value), col1X + labelWidth, col1Y);
          col1Y += lineHeight;
        }

        function addSpecHeader(title) {
          col1Y += 2;
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'bold');
          pdf.text(title, col1X, col1Y);
          const textWidth = pdf.getTextWidth(title);
          pdf.line(col1X, col1Y + 0.5, col1X + textWidth, col1Y + 0.5);
          pdf.setFont(undefined, 'normal');
          col1Y += 4.5;
        }

        // Calculate wall dimensions
        if(p && pw > 0 && ph > 0) {
          const wallResX = pw * p.res_x;
          const wallResY = ph * p.res_y;
          // Panel dimensions are stored in meters (width_m, height_m)
          const panelWidthMm = (p.width_m || 0) * 1000;
          const panelHeightMm = (p.height_m || 0) * 1000;
          const wallWidthMm = pw * panelWidthMm;
          const wallHeightMm = ph * panelHeightMm;
          const wallWidthFt = wallWidthMm > 0 ? (wallWidthMm / 304.8).toFixed(2) : '0';
          const wallHeightFt = wallHeightMm > 0 ? (wallHeightMm / 304.8).toFixed(2) : '0';
          const wallWidthM = wallWidthMm > 0 ? (wallWidthMm / 1000).toFixed(2) : '0';
          const wallHeightM = wallHeightMm > 0 ? (wallHeightMm / 1000).toFixed(2) : '0';
          const activePanels = calcData.activePanels || (pw * ph);
          const totalPixels = wallResX * wallResY;
          const exportUseConnectingPlates = (panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF') && data.connectionMethod === 'plates';

          // Use stored panel-only weight (already calculated without bumpers)
          const panelOnlyWeightKg = calcData.panelWeightOnlyKg || (activePanels * getPanelWeight(panelType, exportUseConnectingPlates));
          const panelOnlyWeightLbs = (panelOnlyWeightKg * 2.20462).toFixed(1);

          // Calculate power (stored as power_max_w, power_avg_w in panels object)
          const powerType = data.powerType || 'max';
          const powerPerPanel = powerType === 'max' ? (p.power_max_w || 0) : (p.power_avg_w || 0);
          const totalPowerW = activePanels * powerPerPanel;
          const voltage = parseInt(data.voltage) || 208;
          const breaker = parseInt(data.breaker) || 20;
          const phase = parseInt(data.phase) || 3;
          const ampsSingle = voltage > 0 ? totalPowerW / voltage : 0;
          const ampsPerPhase = phase === 3 ? ampsSingle / 1.732 : ampsSingle;

          // Calculate max panels per circuit
          const derate = 1.0;
          const circuitW = voltage * breaker * derate;
          const maxPanelsPerCircuit = powerPerPanel > 0 ? Math.floor(circuitW / powerPerPanel) : 0;

          // Panel dimensions for display
          const panelWidthFt = (p.width_m * 3.28084).toFixed(3);
          const panelHeightFt = (p.height_m * 3.28084).toFixed(3);
          const panelWidthM = p.width_m.toFixed(3);
          const panelHeightM = p.height_m.toFixed(3);
          const exportPanelWeightKg = getPanelWeight(panelType, exportUseConnectingPlates);
          const panelWeightLbs = (exportPanelWeightKg * 2.20462).toFixed(2);

          // Only add specs if enabled in export options
          if(pdfExportOptions.specs) {
          // PANEL section
          addSpecHeader('PANEL');
          addSpecLine('Panel:', `${p.brand || ''} ${p.name || panelType}`);
          addSpecLine('Pixel Pitch:', `${p.pixel_pitch_mm} mm`);
          addSpecLine('Panel Size:', `${panelWidthFt}' × ${panelHeightFt}' (${panelWidthM} × ${panelHeightM} m)`);
          addSpecLine('Panel Res:', `${p.res_x} × ${p.res_y}`);

          // Show complex details if any layout or gear list option is selected (indicates complex/combined mode export)
          const showComplexDetails = pdfExportOptions.standard || pdfExportOptions.power || pdfExportOptions.data || pdfExportOptions.structure || pdfExportOptions.gearList;
          if(showComplexDetails) {
            // Complex mode: show additional panel specs
            if(p.brightness_nits) addSpecLine('Brightness:', `${p.brightness_nits} nits`);
            if(exportPanelWeightKg) addSpecLine('Weight/Panel:', `${panelWeightLbs} lbs (${exportPanelWeightKg.toFixed(2)} kg)`);
            addSpecLine('Panel Power:', `${p.power_max_w} W / ${p.power_avg_w} W (Max/Avg)`);
            if(p.max_hanging !== null && p.max_hanging !== undefined) addSpecLine('Max Hanging:', `${p.max_hanging} panels`);
            if(p.max_stacking !== null && p.max_stacking !== undefined) addSpecLine('Max Stacking:', `${p.max_stacking} panels`);
            if(p.bumper_1w_lbs !== null && p.bumper_1w_lbs !== undefined) {
              addSpecLine('Bumper Weights:', `1W=${p.bumper_1w_lbs.toFixed(1)} lbs, 2W=${p.bumper_2w_lbs.toFixed(1)} lbs`);
            }
          } else {
            // Simple mode: just weight per panel
            if(exportPanelWeightKg) addSpecLine('Weight/Panel:', `${panelWeightLbs} lbs (${exportPanelWeightKg.toFixed(2)} kg)`);
          }

          // WALL section
          addSpecHeader('WALL');
          addSpecLine('Dimensions:', `${wallWidthFt}' × ${wallHeightFt}' (${pw} × ${ph} panels)`);
          addSpecLine('Total Panels:', activePanels.toString());
          addSpecLine('Resolution:', `${wallResX} × ${wallResY} px`);
          addSpecLine('Total Pixels:', totalPixels.toLocaleString() + ' px');

          // Weight display depends on mode
          if(showComplexDetails) {
            // Complex mode: show total weight with breakdown
            // Structure = Bumpers + Connecting Plates + Ground Support Hardware (or Floor Frames for floor mode)
            const structureType = data.structureType || 'hanging';
            let structureWeightKg = 0;

            if(structureType === 'floor' && p && p.is_floor_panel && p.floor_frames) {
              // Floor mode: Structure = Floor Frames
              const floorFrames = calcData.floorFrames || {};
              if(floorFrames.totalWeightLbs) {
                structureWeightKg = floorFrames.totalWeightLbs / 2.20462;
              } else if(floorFrames.totalWeightKg) {
                structureWeightKg = floorFrames.totalWeightKg;
              }
            } else {
              // Hanging or Ground Stack: Structure = Bumpers + Plates + Ground Support
              const bumperWeightKg = calcData.bumperWeightKg || 0;
              structureWeightKg += bumperWeightKg;

              // Add connecting plates weight
              const platesWeightKg = calcData.platesWeightKg || 0;
              structureWeightKg += platesWeightKg;

              // Add ground support hardware weight for ground stack mode
              if(structureType === 'ground') {
                const groundSupportWeightKg = calcData.groundSupportWeightKg || 0;
                structureWeightKg += groundSupportWeightKg;
              }
            }

            const totalWeightKg = panelOnlyWeightKg + structureWeightKg;
            const totalWeightLbs = (totalWeightKg * 2.20462).toFixed(1);

            addSpecLine('Total Weight:', `${totalWeightLbs} lbs (${totalWeightKg.toFixed(1)} kg)`);
            if(structureWeightKg > 0 || structureType === 'floor') {
              addSpecLine('  Panels:', `${panelOnlyWeightLbs} lbs (${panelOnlyWeightKg.toFixed(1)} kg)`);
              const structureWeightLbs = (structureWeightKg * 2.20462).toFixed(1);
              addSpecLine('  Structure:', `${structureWeightLbs} lbs (${structureWeightKg.toFixed(1)} kg)`);
            }
          } else {
            // Simple mode: show panel-only weight
            addSpecLine('Wall Weight:', `${panelOnlyWeightLbs} lbs (${panelOnlyWeightKg.toFixed(1)} kg)`);
          }

          // POWER section
          const powerHeader = powerType === 'max' ? 'POWER (MAX)' : 'POWER (AVG)';
          addSpecHeader(powerHeader);
          addSpecLine('Total Power:', totalPowerW.toLocaleString() + ' W');
          addSpecLine('Total Amps:', `${ampsSingle.toFixed(2)} A @ ${voltage}V`);
          if(phase === 3) {
            addSpecLine('Amps/Phase:', `${ampsPerPhase.toFixed(2)} A @ ${voltage}V`);
          }
          const circuitsNeeded = calcData.circuitsNeeded || 0;
          addSpecLine('Circuits:', circuitsNeeded.toString());
          addSpecLine('Max Panels/Circuit:', maxPanelsPerCircuit.toString());

          // DATA section
          addSpecHeader('DATA');
          const portCapacity = pr.base_pixels_1g || 0;
          const maxPanelsPerData = p.max_panels_per_data || calcData.panelsPerDataLine || 0;

          if(showComplexDetails) {
            // Complex mode: show all data specs
            let processorName = pr.name || data.processor;
            // For PDF, just use plain text without HTML tags
            addSpecLine('Processor:', processorName);
            const dataLines = calcData.dataLines || 0;
            const portsNeeded = calcData.portsNeededFinal || calcData.portsNeeded || 0;
            addSpecLine('Data Lines:', dataLines.toString());
            addSpecLine('Ports Needed:', portsNeeded.toString());
            addSpecLine('Port Capacity:', portCapacity.toLocaleString() + ' px');
            addSpecLine('Max Panels/Data:', maxPanelsPerData.toString());
            const frameRate = data.frameRate || '60';
            const bitDepth = data.bitDepth || '8';
            addSpecLine('Frame Rate:', frameRate + ' Hz');
            addSpecLine('Bit Depth:', bitDepth + '-bit');
            const redundancy = data.redundancy ? 'Yes' : 'No';
            addSpecLine('Redundancy:', redundancy);
          } else {
            // Simple mode: only show port capacity and max panels per data line
            addSpecLine('Port Capacity:', portCapacity.toLocaleString() + ' px');
            addSpecLine('Max Panels/Data:', maxPanelsPerData.toString());
          }
          } // End of pdfExportOptions.specs check
        }

        // ========== RIGHT COLUMN: GEAR LIST ==========
        if(pdfExportOptions.gearList) {
          addGearListToColumn(screenId, screen.name, col2X, col2Y, colWidth, lineHeight, processorGroups);
        }

        // Include layouts if any layout option is selected
        const includeAnyLayout = pdfExportOptions.standard || pdfExportOptions.power || pdfExportOptions.data || pdfExportOptions.structure;
        if(includeAnyLayout) {
          // Force show main container first (parent of layout containers)
          // This is critical when exporting from Combined view where mainContainer is hidden
          const mainContainer = document.querySelector('.main-container');
          const mainContainerWasHidden = mainContainer && mainContainer.style.display === 'none';
          if(mainContainer) mainContainer.style.display = 'block';

          // Force show all layout containers before capturing
          const standardContainer = document.getElementById('standardContainer');
          const powerContainer = document.getElementById('powerContainer');
          const dataContainer = document.getElementById('dataContainer');
          const structureContainer = document.getElementById('structureContainer');

          if(standardContainer) standardContainer.style.display = 'block';
          if(powerContainer) powerContainer.style.display = 'block';
          if(dataContainer) dataContainer.style.display = 'block';
          if(structureContainer) structureContainer.style.display = 'block';

          // Force a browser reflow to ensure containers have proper width
          if(mainContainer) void mainContainer.offsetWidth;
          if(standardContainer) void standardContainer.offsetWidth;
          if(powerContainer) void powerContainer.offsetWidth;
          if(dataContainer) void dataContainer.offsetWidth;
          if(structureContainer) void structureContainer.offsetWidth;

          // Explicitly regenerate all layouts for this screen
          generateLayout('standard');
          generateLayout('power');
          generateLayout('data');
          generateStructureLayout();

          // Wait a bit for layouts to render, then capture them
          setTimeout(() => {
            addScreenLayouts(screenId, screen.name);
          }, 150);
        } else {
          // No layouts selected: skip layouts, move to next screen
          screenIndex++;
          setTimeout(processNextScreen, 50);
        }
      }, 50);
    }

    // Add gear list content to a column (inline version for page 1)
    function addGearListToColumn(screenId, screenName, colX, startY, colWidth, lineHeight, processorGroups) {
      let colY = startY;

      const screen = screens[screenId];
      if(!screen || !screen.data) return;

      const allPanels = getAllPanels();
      const data = screen.data;
      const calcData = screen.calculatedData || {};
      const panelType = data.panelType || 'CB5_MKII';
      const p = allPanels[panelType];
      const pw = parseInt(data.panelsWide) || 0;
      const ph = parseInt(data.panelsHigh) || 0;
      const isFirstScreen = (screenIndex === 0);

      // Check if canvas is 4K (need 12G SDI cables)
      const canvasSize = data.canvasSize || '4K_UHD';
      const is4KCanvas = (canvasSize === '4K_UHD' || canvasSize === '4K_DCI');

      // Equipment data
      const processorType = data.processor || 'Brompton_SX40';
      const processorGroup = processorGroups[processorType] || null;
      const isFirstScreenInGroup = processorGroup && processorGroup.firstScreenId === screenId;
      const processorName = calcData.processorName || '';
      const activePanels = calcData.activePanels || calcData.panelCount || 0;

      // Rigging
      const bumper1wCount = calcData.bumper1wCount || 0;
      const bumper2wCount = calcData.bumper2wCount || 0;
      const bumper4wCount = calcData.bumper4wCount || 0;
      const plates2way = calcData.plates2way || 0;
      const plates4way = calcData.plates4way || 0;
      const useBumpers = data.useBumpers !== false;

      // Ground Support
      const groundSupport = calcData.groundSupport || {
        totalRearTruss: 0,
        totalBaseTruss: 0,
        totalBridgeClamps: 0,
        totalRearBridgeClampAdapters: 0,
        totalSandbags: 0,
        totalSwivelCheeseboroughs: 0,
        totalPipes: 0,
        pipeInfo: []
      };

      // Power
      const socaCount = calcData.socaCount || 0;
      const circuitsNeeded = calcData.circuitsNeeded || 0;
      const columnsPerCircuit = calcData.columnsPerCircuit || 1;

      // Data cross jumpers calculation
      let dataCrossJumperCount = 0;
      if(pw > 0 && ph > 0) {
        const pr = processors[data.processor] || processors['Brompton_SX40'];
        const portCapacity = pr ? pr.base_pixels_1g : 525000;
        const frameRate = parseInt(data.frameRate) || 60;
        const bitDepth = parseInt(data.bitDepth) || 8;

        let adjustedCapacity = portCapacity;
        if(frameRate > 60) adjustedCapacity = Math.floor(portCapacity * (60 / frameRate));
        if(bitDepth > 8) adjustedCapacity = Math.floor(adjustedCapacity * (8 / bitDepth));

        const pixelsPerPanel = p ? (p.res_x * p.res_y) : 1;
        let capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
        // Cap at 500 panels per port (Brompton Tessera hardware limit)
        capacityBasedPanelsPerData = Math.min(capacityBasedPanelsPerData, 500);
        const panelSpecificDataLimit = p ? p.max_panels_per_data : null;
        const suggestedPanelsPerData = panelSpecificDataLimit
          ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
          : capacityBasedPanelsPerData;
        const userMaxPanelsPerData = parseInt(data.maxPanelsPerData) || 0;
        const panelsPerDataLine = userMaxPanelsPerData > 0 ? userMaxPanelsPerData : suggestedPanelsPerData;

        const startDir = data.dataStartDir || 'top';
        const customDataLines = data.customDataLineAssignments;
        const hasCustomDataLines = customDataLines && customDataLines.size > 0;
        const deletedPanels = data.deletedPanels;

        if(startDir !== 'all_top' && startDir !== 'all_bottom') {
          const dataLineColumns = new Map();
          const usedCustomDataLines = new Set();
          if(hasCustomDataLines) {
            for(let c = 0; c < pw; c++) {
              for(let r = 0; r < ph; r++) {
                const panelKey = `${c},${r}`;
                const isDeleted = deletedPanels && deletedPanels.has && deletedPanels.has(panelKey);
                if(!isDeleted && customDataLines.has(panelKey)) {
                  usedCustomDataLines.add(customDataLines.get(panelKey) - 1);
                }
              }
            }
          }

          let autoDataLineCounter = 0;
          let panelsInCurrentAutoDataLine = 0;
          while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;

          let serpentineGoingDown = (startDir === 'top');
          for(let c = 0; c < pw; c++) {
            const rows = serpentineGoingDown
              ? Array.from({length: ph}, (_, i) => i)
              : Array.from({length: ph}, (_, i) => ph - 1 - i);

            for(const r of rows) {
              const panelKey = `${c},${r}`;
              if(deletedPanels && deletedPanels.has && deletedPanels.has(panelKey)) continue;

              let dataLine;
              if(hasCustomDataLines && customDataLines.has(panelKey)) {
                dataLine = customDataLines.get(panelKey) - 1;
              } else {
                while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
                dataLine = autoDataLineCounter;
                panelsInCurrentAutoDataLine++;
                if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
                  autoDataLineCounter++;
                  panelsInCurrentAutoDataLine = 0;
                  while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
                }
              }

              if(!dataLineColumns.has(dataLine)) dataLineColumns.set(dataLine, new Set());
              dataLineColumns.get(dataLine).add(c);
            }
            serpentineGoingDown = !serpentineGoingDown;
          }

          dataLineColumns.forEach((columns, dataLine) => {
            if(columns.size > 1) dataCrossJumperCount += (columns.size - 1);
          });
        }
      }

      // Pipe length string
      let pipeLengthStr = '';
      if(groundSupport.totalPipes > 0 && groundSupport.pipeInfo && groundSupport.pipeInfo.length > 0) {
        const uniqueLengths = [...new Set(groundSupport.pipeInfo.map(pi => pi.pipeLengthFt))];
        pipeLengthStr = ' (' + uniqueLengths.map(l => l + 'ft').join(', ') + ')';
      }

      function addGearLine(label, value) {
        if(value === '0' || value === '' || value === null || value === undefined) return;
        pdf.setFontSize(8);
        pdf.setFont(undefined, 'normal');
        pdf.text(label, colX, colY);
        const labelWidth = pdf.getTextWidth(label);
        pdf.text(String(value), colX + labelWidth + 1, colY);
        colY += lineHeight;
      }

      function addGearHeader(title) {
        colY += 1.5;
        pdf.setFontSize(9);
        pdf.setFont(undefined, 'bold');
        pdf.text(title, colX, colY);
        colY += 4;
      }

      // Gear List Title
      pdf.setFontSize(11);
      pdf.setFont(undefined, 'bold');
      pdf.text('Gear List', colX, colY);
      colY += 5;

      // Equipment
      addGearHeader('Equipment');
      if(isFirstScreenInGroup && processorGroup && processorGroup.processorCount > 0) {
        addGearLine('Processor:', `${processorGroup.processorCount}x ${processorName}`);
        if(processorGroup.distBoxCount > 0) {
          addGearLine(`${processorGroup.distBoxName}:`, processorGroup.distBoxCount.toString());
        }
      } else if(processorGroup && processorGroup.firstScreenName) {
        pdf.setFontSize(8);
        pdf.setFont(undefined, 'normal');
        pdf.text(`Processor: See ${processorGroup.firstScreenName}`, colX, colY);
        colY += lineHeight;
      }
      addGearLine('Panel Count:', activePanels.toString());

      // Rigging
      addGearHeader('Rigging Hardware');
      addGearLine('1W Bumpers:', bumper1wCount.toString());
      addGearLine('2W Bumpers:', bumper2wCount.toString());
      addGearLine('4W Bumpers:', bumper4wCount.toString());
      addGearLine('4W Connecting Plates:', plates4way.toString());
      addGearLine('2W Connecting Plates:', plates2way.toString());

      // 5/8" Shackles and Cheeseye
      const needsShacklesAndCheeseye = ['CB5_MKII', 'CB5_MKII_HALF', 'MC7H', 'INFILED_AMT8_3'].includes(panelType);
      const isHanging = data.structureType === 'hanging';
      if(needsShacklesAndCheeseye && isHanging && useBumpers) {
        let shackleCount = 0;
        let cheeseyeCount = 0;
        if(panelType === 'INFILED_AMT8_3') {
          shackleCount = bumper1wCount + (bumper2wCount * 2);
          cheeseyeCount = bumper1wCount + (bumper2wCount * 2);
        } else {
          shackleCount = bumper1wCount + bumper2wCount;
          cheeseyeCount = bumper1wCount + bumper2wCount;
        }
        if(shackleCount > 0) addGearLine('5/8" Shackles:', shackleCount.toString());
        if(cheeseyeCount > 0) addGearLine('Cheeseye:', cheeseyeCount.toString());
      }

      // Ground Support
      addGearHeader('Ground Support');
      addGearLine('Rear Truss:', groundSupport.totalRearTruss.toString());
      addGearLine('Base Truss:', groundSupport.totalBaseTruss.toString());
      addGearLine('Bridge Clamps:', groundSupport.totalBridgeClamps.toString());
      addGearLine('Rear Bridge Adapter:', groundSupport.totalRearBridgeClampAdapters.toString());
      addGearLine('Sandbags:', groundSupport.totalSandbags.toString());
      addGearLine('Swivel Cheeseborough:', groundSupport.totalSwivelCheeseboroughs.toString());
      addGearLine('Pipe' + pipeLengthStr + ':', groundSupport.totalPipes.toString());

      // Floor Hardware - calculate fresh since it might not be in calculatedData yet
      const structureType = data.structureType || 'hanging';
      if(structureType === 'floor' && p && p.is_floor_panel && p.floor_frames && pw > 0 && ph > 0) {
        const deletedPanelsSet = data.deletedPanels || new Set();
        const frames = calculateFloorFrames(pw, ph, deletedPanelsSet);
        const frameCounts = getFloorFrameCounts(frames);
        const hasFloorFrames = frameCounts.frame_1x1 > 0 || frameCounts.frame_2x1 > 0 ||
                               frameCounts.frame_2x2 > 0 || frameCounts.frame_3x2 > 0;
        if(hasFloorFrames) {
          addGearHeader('Floor Hardware');
          if(frameCounts.frame_3x2 > 0) addGearLine('3×2 Frame:', frameCounts.frame_3x2.toString());
          if(frameCounts.frame_2x2 > 0) addGearLine('2×2 Frame:', frameCounts.frame_2x2.toString());
          if(frameCounts.frame_2x1 > 0) addGearLine('2×1 Frame:', frameCounts.frame_2x1.toString());
          if(frameCounts.frame_1x1 > 0) addGearLine('1×1 Frame:', frameCounts.frame_1x1.toString());
        }
      }

      // Data Cables
      addGearHeader('Data Cables');
      const dataJumperLen = p && p.data_jumper_ft ? p.data_jumper_ft : '';
      const dataCrossJumperLen = p && p.data_cross_jumper_ft ? p.data_cross_jumper_ft : '';
      const jumpersBuiltin = p && p.jumpers_builtin;

      if(!jumpersBuiltin && dataJumperLen) {
        addGearLine(`Data Jumpers ${dataJumperLen}:`, activePanels.toString());
      }
      if(dataCrossJumperLen && dataCrossJumperCount > 0) {
        addGearLine(`Data Cross Jumpers ${dataCrossJumperLen}:`, dataCrossJumperCount.toString());
      }
      if(jumpersBuiltin) {
        const dataLinesCount = calcData.dataLines || 0;
        const totalCat5Couplers = dataCrossJumperCount + dataLinesCount;
        if(totalCat5Couplers > 0) addGearLine('Cat5 Couplers:', totalCat5Couplers.toString());
      }
      addGearLine("200' Cat6:", '');
      addGearLine("100' Cat6:", '');
      addGearLine("50' Cat6:", '');
      addGearLine("25' Cat6:", '');
      addGearLine("10' Cat6:", '');
      addGearLine("5' Cat6:", '');

      // Power Cables
      addGearHeader('Power Cables');
      const powerJumperLen = p && p.power_jumper_ft ? p.power_jumper_ft : '';
      if(!jumpersBuiltin && powerJumperLen) {
        addGearLine(`Power Jumpers ${powerJumperLen}:`, activePanels.toString());
      }
      addGearLine('Soca Splays:', socaCount.toString());
      addGearLine("100' Soca:", '');
      addGearLine("75' Soca:", '');
      addGearLine("50' Soca:", '');
      addGearLine("25' Soca:", '');
      addGearLine("50' True1:", '');
      addGearLine("25' True1:", (socaCount * 2).toString());
      addGearLine("10' True1:", (socaCount * 2).toString());
      addGearLine("5' True1:", (socaCount * 4).toString());
      addGearLine("3' True1:", '');
      addGearLine('True1 Twofer:', columnsPerCircuit > 1 ? (circuitsNeeded * columnsPerCircuit).toString() : '');

      // Signal Cables (only on first screen)
      if(isFirstScreen) {
        addGearHeader('Signal Cables');
        addGearLine("500' Fiber Opticon:", '');
        addGearLine('Fiber 4ch Opticon Splay:', '');
        const processorCount = processorGroup ? processorGroup.processorCount : 0;
        const sdiPerProcessor = processorCount * 2;
        if(is4KCanvas) {
          addGearLine("100' 12G SDI:", sdiPerProcessor.toString());
          addGearLine("75' 12G SDI:", '');
          addGearLine("50' 12G SDI:", sdiPerProcessor.toString());
          addGearLine("25' 12G SDI:", sdiPerProcessor.toString());
        } else {
          addGearLine("100' SDI:", sdiPerProcessor.toString());
          addGearLine("75' SDI:", '');
          addGearLine("50' SDI:", sdiPerProcessor.toString());
          addGearLine("25' SDI:", sdiPerProcessor.toString());
          addGearLine("10' SDI:", '6');
          addGearLine("3' SDI:", '6');
        }
        addGearLine("25' HDMI:", '6');
        addGearLine("10' HDMI:", '6');
        addGearLine("6' HDMI:", '6');
      }

      // Utility (only on first screen)
      if(isFirstScreen) {
        addGearHeader('Utility');
        addGearLine("UG 10':", '8');
        addGearLine("UG 25':", '6');
        addGearLine("UG 50':", '6');
        addGearLine('UG Twofers:', '8');
        addGearLine('Power Bars:', '8');
      }

      // Spares
      addGearHeader('SPARES');
      addGearLine('Spare Soca Splays:', '');
      addGearLine('Spare Panel Count:', '');
      if(!jumpersBuiltin && dataJumperLen) {
        addGearLine(`Spare Data Jumpers ${dataJumperLen}:`, '');
      }
      if(dataCrossJumperLen) {
        addGearLine(`Spare Data Cross Jumpers ${dataCrossJumperLen}:`, '');
      }
      if(jumpersBuiltin) {
        addGearLine('Spare Cat5 Couplers:', '');
      }
      if(!jumpersBuiltin && powerJumperLen) {
        addGearLine(`Spare Power Jumpers ${powerJumperLen}:`, '');
      }
      addGearLine('Spare Soca:', '');
      addGearLine('Spare Data:', '');
      addGearLine('Spare Fiber:', '');
    }

    function addScreenLayouts(screenId, screenName) {
      // Build layouts array based on export options
      const layouts = [];
      if(pdfExportOptions.standard) {
        layouts.push({ containerId: 'standardContainer', canvasId: 'standardCanvas', title: 'Standard Layout' });
      }
      if(pdfExportOptions.power) {
        layouts.push({ containerId: 'powerContainer', canvasId: 'powerCanvas', title: 'Power Layout' });
      }
      if(pdfExportOptions.data) {
        layouts.push({ containerId: 'dataContainer', canvasId: 'dataCanvas', title: 'Data Layout' });
      }

      // Only add a new page if we have layouts to add
      if(layouts.length > 0) {
        pdf.addPage();
        yOffset = margin;
      }
      
      let layoutIndex = 0;
      
      function addNextLayout() {
        if(layoutIndex >= layouts.length) {
          // All main layouts done, now add Structure View page if enabled
          if(pdfExportOptions.structure) {
            addStructureViewPage(screenId, screenName, function() {
              // After structure view, move to next screen (gear list is already on page 1)
              screenIndex++;
              processNextScreen();
            });
          } else {
            // Skip structure view, move to next screen
            screenIndex++;
            processNextScreen();
          }
          return;
        }
        
        const layout = layouts[layoutIndex];
        const container = document.getElementById(layout.containerId);
        const canvas = document.getElementById(layout.canvasId);
        
        if(container && container.style.display !== 'none' && canvas && canvas.width > 0) {
          // Use print-friendly colors when in print mode
          const canvasImg = getCanvasDataURLForPDF(canvas);

          // Fixed WIDTH for all layouts, height scales proportionally
          const fixedWidth = 114; // mm - same width for all layouts
          const maxHeight = 70;   // mm - maximum height cap

          // Calculate height maintaining aspect ratio
          const aspectRatio = canvas.height / canvas.width;
          let imgWidth = fixedWidth;
          let imgHeight = fixedWidth * aspectRatio;

          // Cap height if too tall (for very vertical layouts)
          if(imgHeight > maxHeight) {
            imgHeight = maxHeight;
            imgWidth = maxHeight / aspectRatio;
          }

          // Check if we need a new page
          const neededHeight = imgHeight + 14;
          if(yOffset + neededHeight > pageHeight - margin) {
            pdf.addPage();
            yOffset = margin;
          }

          // Add layout title
          pdf.setFontSize(11);
          pdf.setTextColor(0, 0, 0);
          pdf.text(layout.title, margin, yOffset);
          yOffset += 6;

          // Add layout image - width is consistent, height varies by aspect ratio
          pdf.addImage(canvasImg, 'JPEG', margin, yOffset, imgWidth, imgHeight);
          yOffset += imgHeight + 4;

          yOffset += 4;
        }
        
        layoutIndex++;
        setTimeout(addNextLayout, 10);
      }
      
      addNextLayout();
    }
    
    // Add dedicated Structure View page
    function addStructureViewPage(screenId, screenName, callback) {
      const container = document.getElementById('structureContainer');
      const canvas = document.getElementById('structureCanvas');
      
      if(!container || container.style.display === 'none' || !canvas || canvas.width === 0) {
        // No structure view, skip to callback
        if(callback) setTimeout(callback, 10);
        return;
      }
      
      try {
        // Start new page for Structure View
        pdf.addPage();
        yOffset = margin;
        
        // Page title
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text('Structure Layout', margin, yOffset);
        yOffset += 8;
        
        // Add structure canvas image - use print-friendly colors when in print mode
        const canvasImg = getCanvasDataURLForPDF(canvas);
        const fixedWidth = 160; // Wider for structure view page
        const maxHeight = 80;

        const aspectRatio = canvas.height / canvas.width;
        let imgWidth = fixedWidth;
        let imgHeight = fixedWidth * aspectRatio;

        if(imgHeight > maxHeight) {
          imgHeight = maxHeight;
          imgWidth = maxHeight / aspectRatio;
        }

        pdf.addImage(canvasImg, 'JPEG', margin, yOffset, imgWidth, imgHeight);
        yOffset += imgHeight + 8;
        
        // Now add the structure info in a clean 2-column layout below
        const hasPickupWeights = bumpers.length > 0;
        const panelType = document.getElementById('panelType').value;
        const useConnectingPlates = shouldUseConnectingPlates(panelType);
        const platesBox = document.getElementById('structurePlatesBox');
        const hasConnectingPlates = useConnectingPlates && platesBox && platesBox.style.display !== 'none';
        const isGroundStacking = showBottomBumper;
        const {pw, ph} = getEffectivePanelCountsForLayout();
        
        // Column positions for structure info
        const col1X = margin;
        const col2X = margin + 95; // Second column starts 95mm from margin
        const colLabelX = 2;
        const colValueX = 48;
        
        let col1Y = yOffset;
        let col2Y = yOffset;
        
        const wtUnit = displayWeightUnit === 'lbs' ? 'lbs' : 'kg';
        
        // ========== COLUMN 1 ==========
        
        // Pickup Weights
        let pickupWeightKg = 0;
        if(hasPickupWeights) {
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.text('Pickup Weights', col1X, col1Y);
          col1Y += 5;
          
          const topBumpers = bumpers.filter(b => b.position === 'top');
          const bottomBumpers = bumpers.filter(b => b.position === 'bottom');
          
          // Helper function to check if a 2W bumper is under a 4W bumper
          function is2wUnder4wPdf(bumper2w, position) {
            const fourWayBumpers = bumpers.filter(b => b.type === '4w' && b.position === position);
            for(const b4w of fourWayBumpers) {
              const col4wStart = b4w.startCol - 1;
              const col4wEnd = b4w.endCol;
              if(bumper2w.startCol >= col4wStart && bumper2w.endCol <= col4wEnd) {
                return true;
              }
            }
            return false;
          }
          
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          
          // Top bumpers (skip 2W under 4W)
          if(topBumpers.length > 0) {
            const sortedTop = [...topBumpers].sort((a, b) => {
              const order = { '4w': 0, '2w': 1, '1w': 2 };
              return order[a.type] - order[b.type];
            });
            const counts = { '4w': 0, '2w': 0, '1w': 0 };
            sortedTop.forEach((bumper) => {
              // Skip 2W bumpers under 4W bumpers
              if(bumper.type === '2w' && is2wUnder4wPdf(bumper, 'top')) {
                return;
              }
              counts[bumper.type]++;
              const weight = calculateBumperPickupWeight(bumper);
              pickupWeightKg += weight.kg;
              const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
              const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
              pdf.text(`${label} #${counts[bumper.type]}`, col1X + colLabelX, col1Y);
              pdf.text(`${weightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            });
          }
          
          // Bottom bumpers (skip 2W under 4W)
          if(bottomBumpers.length > 0) {
            const sortedBottom = [...bottomBumpers].sort((a, b) => {
              const order = { '4w': 0, '2w': 1, '1w': 2 };
              return order[a.type] - order[b.type];
            });
            const counts = { '4w': 0, '2w': 0, '1w': 0 };
            sortedBottom.forEach((bumper) => {
              // Skip 2W bumpers under 4W bumpers
              if(bumper.type === '2w' && is2wUnder4wPdf(bumper, 'bottom')) {
                return;
              }
              counts[bumper.type]++;
              const weight = calculateBumperPickupWeight(bumper);
              pickupWeightKg += weight.kg;
              const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
              const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
              pdf.text(`${label} #${counts[bumper.type]}`, col1X + colLabelX, col1Y);
              pdf.text(`${weightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            });
          }
          
          // Total line
          pdf.setDrawColor(100, 100, 100);
          pdf.line(col1X + colLabelX, col1Y, col1X + colValueX, col1Y);
          col1Y += 3;
          pdf.setFont(undefined, 'bold');
          pdf.text('Total', col1X + colLabelX, col1Y);
          const totalPickupDisplay = displayWeightUnit === 'lbs' ? (pickupWeightKg * KG_TO_LBS).toFixed(0) : pickupWeightKg.toFixed(0);
          pdf.text(`${totalPickupDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
          pdf.setFont(undefined, 'normal');
          col1Y += 6;
        }
        
        // Ground Support Hardware (in column 1, below pickup weights)
        let groundSupportWeightKg = 0;
        if(isGroundStacking && pw > 0 && ph > 0) {
          const hardware = calculateGroundSupportHardware(pw, ph);
          
          if(hardware.totalRearTruss > 0 || hardware.totalBridgeClamps > 0 || hardware.totalBaseTruss > 0) {
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Ground Support Hardware', col1X, col1Y);
            col1Y += 5;
            
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            
            if(hardware.totalRearTruss > 0) {
              pdf.text('Rear Truss', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalRearTruss.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalBaseTruss > 0) {
              pdf.text('Base Truss', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalBaseTruss.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalBridgeClamps > 0) {
              pdf.text('Bridge Clamps', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalBridgeClamps.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalRearBridgeClampAdapters > 0) {
              pdf.text('Rear Bridge Clamp Adapter', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalRearBridgeClampAdapters.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalPipes > 0) {
              const uniqueLengths = [...new Set(hardware.pipeInfo.map(p => p.pipeLengthFt))];
              const pipeLengthStr = uniqueLengths.map(l => l + 'ft').join(', ');
              pdf.text('Pipe (' + pipeLengthStr + ')', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalPipes.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalSwivelCheeseboroughs > 0) {
              pdf.text('Swivel Cheeseborough', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalSwivelCheeseboroughs.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalSandbags > 0) {
              pdf.text('Sandbags (25lb)', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalSandbags.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            
            // Total weight
            pdf.setDrawColor(100, 100, 100);
            pdf.line(col1X + colLabelX, col1Y, col1X + colValueX, col1Y);
            col1Y += 3;
            pdf.setFont(undefined, 'bold');
            pdf.text('Total Weight', col1X + colLabelX, col1Y);
            groundSupportWeightKg = hardware.totalWeightKg;
            const gsWeightDisplay = displayWeightUnit === 'lbs' ? hardware.totalWeightLbs.toFixed(1) : hardware.totalWeightKg.toFixed(1);
            pdf.text(`${gsWeightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
            pdf.setFont(undefined, 'normal');
            col1Y += 6;
          }
        }

        // Floor Frames (in column 1, below ground support)
        let floorFramesWeightKg = 0;
        const structureType = document.getElementById('structureType').value;
        const allPanelsForFloor = getAllPanels();
        const pFloor = allPanelsForFloor[panelType];

        if(structureType === 'floor' && pFloor && pFloor.is_floor_panel && pFloor.floor_frames && pw > 0 && ph > 0) {
          const frames = calculateFloorFrames(pw, ph, deletedPanels);
          const frameCounts = getFloorFrameCounts(frames);

          if(frameCounts.frame_1x1 > 0 || frameCounts.frame_2x1 > 0 || frameCounts.frame_2x2 > 0 || frameCounts.frame_3x2 > 0) {
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Floor Frames', col1X, col1Y);
            col1Y += 5;

            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');

            let totalWeightLbs = 0;

            if(frameCounts.frame_3x2 > 0) {
              pdf.text('3×2 Frame', col1X + colLabelX, col1Y);
              pdf.text(frameCounts.frame_3x2.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
              if(pFloor.floor_frames.frame_3x2) totalWeightLbs += frameCounts.frame_3x2 * pFloor.floor_frames.frame_3x2.weight_lbs;
            }
            if(frameCounts.frame_2x2 > 0) {
              pdf.text('2×2 Frame', col1X + colLabelX, col1Y);
              pdf.text(frameCounts.frame_2x2.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
              if(pFloor.floor_frames.frame_2x2) totalWeightLbs += frameCounts.frame_2x2 * pFloor.floor_frames.frame_2x2.weight_lbs;
            }
            if(frameCounts.frame_2x1 > 0) {
              pdf.text('2×1 Frame', col1X + colLabelX, col1Y);
              pdf.text(frameCounts.frame_2x1.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
              if(pFloor.floor_frames.frame_2x1) totalWeightLbs += frameCounts.frame_2x1 * pFloor.floor_frames.frame_2x1.weight_lbs;
            }
            if(frameCounts.frame_1x1 > 0) {
              pdf.text('1×1 Frame', col1X + colLabelX, col1Y);
              pdf.text(frameCounts.frame_1x1.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
              if(pFloor.floor_frames.frame_1x1) totalWeightLbs += frameCounts.frame_1x1 * pFloor.floor_frames.frame_1x1.weight_lbs;
            }

            floorFramesWeightKg = totalWeightLbs / KG_TO_LBS;

            // Total weight
            pdf.setDrawColor(100, 100, 100);
            pdf.line(col1X + colLabelX, col1Y, col1X + colValueX, col1Y);
            col1Y += 3;
            pdf.setFont(undefined, 'bold');
            pdf.text('Total Weight', col1X + colLabelX, col1Y);
            const floorWeightDisplay = displayWeightUnit === 'lbs' ? totalWeightLbs.toFixed(1) : floorFramesWeightKg.toFixed(1);
            pdf.text(`${floorWeightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
            pdf.setFont(undefined, 'normal');
            col1Y += 6;
          }
        }

        // ========== COLUMN 2 ==========

        // Connecting Plates
        let platesWeightKg = 0;
        if(hasConnectingPlates && pw > 0 && ph > 0) {
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.text('Connecting Plates', col2X, col2Y);
          col2Y += 5;
          
          const plate2wayKg = 0.141;
          const plate4wayKg = 0.249;
          const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
          platesWeightKg = plates.totalPlateWeight;
          
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          
          if(plates.total2way > 0) {
            pdf.text('2-Way (yellow)', col2X + colLabelX, col2Y);
            pdf.text(plates.total2way.toString(), col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(plates.total4way > 0) {
            pdf.text('4-Way (red)', col2X + colLabelX, col2Y);
            pdf.text(plates.total4way.toString(), col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          
          pdf.setDrawColor(100, 100, 100);
          pdf.line(col2X + colLabelX, col2Y, col2X + colValueX, col2Y);
          col2Y += 3;
          pdf.setFont(undefined, 'bold');
          pdf.text('Total Weight', col2X + colLabelX, col2Y);
          const platesWeightDisplay = displayWeightUnit === 'lbs' ? (platesWeightKg * KG_TO_LBS).toFixed(1) : platesWeightKg.toFixed(1);
          pdf.text(`${platesWeightDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
          pdf.setFont(undefined, 'normal');
          col2Y += 6;
        }
        
        // Calculate bumper hardware weight (the actual weight of bumper hardware, not load being supported)
        const bumperHardwareWeightKg = calculateTotalBumperWeight(pw, ph);

        // Total Structure Weight (in column 2, below connecting plates)
        const totalStructureWeightKg = bumperHardwareWeightKg + platesWeightKg + groundSupportWeightKg + floorFramesWeightKg;
        const isFloorMode = structureType === 'floor';
        if(totalStructureWeightKg > 0 || isFloorMode) {
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.text('Total Structure Weight', col2X, col2Y);
          col2Y += 5;

          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');

          if(bumperHardwareWeightKg > 0 && !isFloorMode) {
            pdf.text('Bumpers', col2X + colLabelX, col2Y);
            const bumperDisplay = displayWeightUnit === 'lbs' ? (bumperHardwareWeightKg * KG_TO_LBS).toFixed(1) : bumperHardwareWeightKg.toFixed(1);
            pdf.text(`${bumperDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(platesWeightKg > 0) {
            pdf.text('Connecting Plates', col2X + colLabelX, col2Y);
            const platesDisplay = displayWeightUnit === 'lbs' ? (platesWeightKg * KG_TO_LBS).toFixed(1) : platesWeightKg.toFixed(1);
            pdf.text(`${platesDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(groundSupportWeightKg > 0) {
            pdf.text('Ground Support', col2X + colLabelX, col2Y);
            const gsDisplay = displayWeightUnit === 'lbs' ? (groundSupportWeightKg * KG_TO_LBS).toFixed(1) : groundSupportWeightKg.toFixed(1);
            pdf.text(`${gsDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(floorFramesWeightKg > 0) {
            pdf.text('Floor Frames', col2X + colLabelX, col2Y);
            const floorDisplay = displayWeightUnit === 'lbs' ? (floorFramesWeightKg * KG_TO_LBS).toFixed(1) : floorFramesWeightKg.toFixed(1);
            pdf.text(`${floorDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }

          pdf.setDrawColor(100, 100, 100);
          pdf.line(col2X + colLabelX, col2Y, col2X + colValueX, col2Y);
          col2Y += 3;
          pdf.setFont(undefined, 'bold');
          pdf.text('Total', col2X + colLabelX, col2Y);
          const totalDisplay = displayWeightUnit === 'lbs' ? (totalStructureWeightKg * KG_TO_LBS).toFixed(0) : totalStructureWeightKg.toFixed(0);
          pdf.text(`${totalDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
          pdf.setFont(undefined, 'normal');
          col2Y += 4;
        }
        
        yOffset = Math.max(col1Y, col2Y) + 4;
        
      } catch(err) {
        console.error('Error adding structure view page:', err);
      }
      
      if(callback) setTimeout(callback, 10);
    }
    
    // Add gear list page for a screen
    function addGearListPage(screenId, screenName, processorGroups, callback) {
      console.log('addGearListPage called:', screenId, screenName);
      try {
        // Start new page for gear list
        pdf.addPage();
        yOffset = margin;
        
        // Title
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text(`Gear List - ${screenName}`, margin, yOffset);
        yOffset += 10;
        
        console.log('Title added, yOffset:', yOffset);
        
        // Get screen data directly
        const screen = screens[screenId];
        if(!screen || !screen.data) {
          console.error('No screen data found for:', screenId);
          if(callback) setTimeout(callback, 10);
          return;
        }
        
        const allPanels = getAllPanels();
        const data = screen.data;
        const calcData = screen.calculatedData || {};
        console.log('Screen data:', data);
        console.log('Calculated data:', calcData);

        const panelType = data.panelType || 'CB5_MKII';
        const p = allPanels[panelType];

        const pw = parseInt(data.panelsWide) || 0;
        const ph = parseInt(data.panelsHigh) || 0;
        
        // Check if this is the first screen (for SDI/HDMI/UG which only appear once)
        const isFirstScreen = (screenIndex === 0);
        
        // Check if canvas is 4K (need 12G SDI cables)
        const canvasSize = data.canvasSize || '4K_UHD';
        const is4KCanvas = (canvasSize === '4K_UHD' || canvasSize === '4K_DCI');
        
        // ========== PROCESSOR GROUP INFO FOR THIS SCREEN ==========
        const processorType = data.processor || 'Brompton_SX40';
        const processorGroup = processorGroups[processorType] || null;
        const isFirstScreenInGroup = processorGroup && processorGroup.firstScreenId === screenId;
        
        // ========== READ FROM CALCULATED DATA ==========
        
        // Equipment - use combined processor group data instead of per-screen
        const processorName = calcData.processorName || '';
        const activePanels = calcData.activePanels || calcData.panelCount || 0;
        
        // Rigging Hardware - read from calculatedData (set by calculate())
        const bumper1wCount = calcData.bumper1wCount || 0;
        const bumper2wCount = calcData.bumper2wCount || 0;
        const bumper4wCount = calcData.bumper4wCount || 0;
        
        // Connecting Plates - read from calculatedData (set by updateStructurePlatesDisplay())
        const plates2way = calcData.plates2way || 0;
        const plates4way = calcData.plates4way || 0;
        
        // Ground Support - read from calculatedData (set by updateGroundSupportDisplay())
        const groundSupport = calcData.groundSupport || {
          totalRearTruss: 0,
          totalBaseTruss: 0,
          totalBridgeClamps: 0,
          totalRearBridgeClampAdapters: 0,
          totalSandbags: 0,
          totalSwivelCheeseboroughs: 0,
          totalPipes: 0,
          pipeInfo: []
        };
        
        // Power - read from calculatedData (set by calculate())
        const socaCount = calcData.socaCount || 0;
        const circuitsNeeded = calcData.circuitsNeeded || 0;
        const columnsPerCircuit = calcData.columnsPerCircuit || 1;
        
        // ========== CALCULATE DATA CROSS JUMPERS ==========
        // Count column transitions for each data line
        let dataCrossJumperCount = 0;
        
        if(pw > 0 && ph > 0) {
          // Get data calculation parameters from screen data
          const pr = processors[data.processor] || processors['Brompton_SX40'];
          const portCapacity = pr ? pr.base_pixels_1g : 525000;
          const frameRate = parseInt(data.frameRate) || 60;
          const bitDepth = parseInt(data.bitDepth) || 8;
          
          // Calculate adjusted port capacity
          let adjustedCapacity = portCapacity;
          if(frameRate > 60) {
            adjustedCapacity = Math.floor(portCapacity * (60 / frameRate));
          }
          if(bitDepth > 8) {
            adjustedCapacity = Math.floor(adjustedCapacity * (8 / bitDepth));
          }
          
          // Calculate panels per data line
          const pixelsPerPanel = p ? (p.res_x * p.res_y) : 1;
          let capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
          // Cap at 500 panels per port (Brompton Tessera hardware limit)
          capacityBasedPanelsPerData = Math.min(capacityBasedPanelsPerData, 500);
          const panelSpecificDataLimit = p ? p.max_panels_per_data : null;
          const suggestedPanelsPerData = panelSpecificDataLimit
            ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
            : capacityBasedPanelsPerData;
          const userMaxPanelsPerData = parseInt(data.maxPanelsPerData) || 0;
          const panelsPerDataLine = userMaxPanelsPerData > 0 ? userMaxPanelsPerData : suggestedPanelsPerData;
          
          const startDir = data.dataStartDir || 'top';
          const customDataLines = data.customDataLineAssignments;
          const hasCustomDataLines = customDataLines && customDataLines.size > 0;
          const deletedPanels = data.deletedPanels;
          
          if(startDir === 'all_top' || startDir === 'all_bottom') {
            // Each column is its own data line - no cross jumpers needed
            dataCrossJumperCount = 0;
          } else {
            // Serpentine layout - need to track which columns each data line spans
            // Build a map of data line -> set of columns it spans
            const dataLineColumns = new Map(); // dataLineNumber -> Set of column numbers
            
            // Collect custom data line numbers in use
            const usedCustomDataLines = new Set();
            if(hasCustomDataLines) {
              for(let c = 0; c < pw; c++) {
                for(let r = 0; r < ph; r++) {
                  const panelKey = `${c},${r}`;
                  const isDeleted = deletedPanels && deletedPanels.has && deletedPanels.has(panelKey);
                  if(!isDeleted && customDataLines.has(panelKey)) {
                    usedCustomDataLines.add(customDataLines.get(panelKey) - 1);
                  }
                }
              }
            }
            
            let autoDataLineCounter = 0;
            let panelsInCurrentAutoDataLine = 0;
            
            // Skip initial custom data lines
            while(usedCustomDataLines.has(autoDataLineCounter)) {
              autoDataLineCounter++;
            }
            
            // Build serpentine path and track columns per data line
            let serpentineGoingDown = (startDir === 'top');
            for(let c = 0; c < pw; c++) {
              const rows = serpentineGoingDown 
                ? Array.from({length: ph}, (_, i) => i) 
                : Array.from({length: ph}, (_, i) => ph - 1 - i);
              
              for(const r of rows) {
                const panelKey = `${c},${r}`;
                if(deletedPanels && deletedPanels.has && deletedPanels.has(panelKey)) continue;
                
                let dataLine;
                if(hasCustomDataLines && customDataLines.has(panelKey)) {
                  dataLine = customDataLines.get(panelKey) - 1;
                } else {
                  // Find next available data line number
                  while(usedCustomDataLines.has(autoDataLineCounter)) {
                    autoDataLineCounter++;
                  }
                  
                  dataLine = autoDataLineCounter;
                  panelsInCurrentAutoDataLine++;
                  
                  // Move to next data line when we reach the limit
                  if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
                    autoDataLineCounter++;
                    panelsInCurrentAutoDataLine = 0;
                    
                    while(usedCustomDataLines.has(autoDataLineCounter)) {
                      autoDataLineCounter++;
                    }
                  }
                }
                
                // Track which column this data line spans
                if(!dataLineColumns.has(dataLine)) {
                  dataLineColumns.set(dataLine, new Set());
                }
                dataLineColumns.get(dataLine).add(c);
              }
              
              serpentineGoingDown = !serpentineGoingDown;
            }
            
            // Count cross jumpers: for each data line, count (columns spanned - 1)
            dataLineColumns.forEach((columns, dataLine) => {
              const columnCount = columns.size;
              if(columnCount > 1) {
                dataCrossJumperCount += (columnCount - 1);
              }
            });
          }
        }
        
        // Pipe length string
        let pipeLengthStr = '';
        if(groundSupport.totalPipes > 0 && groundSupport.pipeInfo && groundSupport.pipeInfo.length > 0) {
          const uniqueLengths = [...new Set(groundSupport.pipeInfo.map(pi => pi.pipeLengthFt))];
          pipeLengthStr = ' (' + uniqueLengths.map(l => l + 'ft').join(', ') + ')';
        }
        
        // === TWO-COLUMN LAYOUT SETUP ===
        const colWidth = 90; // Width of each column in mm
        const col1X = margin;
        const col2X = margin + colWidth + 5; // 5mm gap between columns
        const lineHeight = 4.5;
        const labelValueGap = 2; // Gap between label and value (closer)
        const sectionGap = 2;
        
        let currentCol = 1;
        let col1Y = yOffset;
        let col2Y = yOffset;
        const startY = yOffset;
        
        function getCurrentY() {
          return currentCol === 1 ? col1Y : col2Y;
        }
        
        function setCurrentY(y) {
          if(currentCol === 1) col1Y = y;
          else col2Y = y;
        }
        
        function getLabelX() {
          return currentCol === 1 ? col1X : col2X;
        }
        
        function addLine(label, value) {
          // Skip items with value 0 or empty
          if(value === '0' || value === '' || value === null || value === undefined) {
            return;
          }
          const y = getCurrentY();
          if(y > pageHeight - margin - 10) {
            // Column overflow - would need new page, but we're designing to fit
            return;
          }
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(0, 0, 0);
          const labelX = getLabelX();
          pdf.text(label, labelX, y);
          // Value right after label with small gap
          const labelWidth = pdf.getTextWidth(label);
          pdf.text(String(value), labelX + labelWidth + labelValueGap, y);
          setCurrentY(y + lineHeight);
        }
        
        function addSectionHeader(title) {
          const y = getCurrentY();
          if(y > pageHeight - margin - 15) {
            return;
          }
          setCurrentY(y + sectionGap);
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(0, 0, 0);
          pdf.text(title, getLabelX(), getCurrentY());
          setCurrentY(getCurrentY() + 5);
        }
        
        function switchToColumn2() {
          currentCol = 2;
          col2Y = startY; // Start at same Y as column 1
        }
        
        console.log('Gear List Debug:', {
          panelType, pw, ph, activePanels,
          bumper1wCount, bumper2wCount, bumper4wCount,
          plates2way, plates4way,
          processorName, processorGroup, isFirstScreenInGroup,
          isFirstScreen, is4KCanvas
        });
        
        // ========== COLUMN 1 ==========
        
        // === EQUIPMENT SECTION ===
        addSectionHeader('Equipment');

        // Processor and Distribution Box - show combined totals on first screen of each processor group
        if(isFirstScreenInGroup && processorGroup) {
          const groupProcessorCount = processorGroup.processorCount || 0;
          const groupDistBoxCount = processorGroup.distBoxCount || 0;
          const distBoxName = processorGroup.distBoxName || 'Distribution Box';

          // Show processor count with name
          if(groupProcessorCount > 0) {
            addLine('Processor:', `${groupProcessorCount}x ${processorName}`);
          }

          // Show distribution box count with name (XD, CVT, etc.)
          if(groupDistBoxCount > 0) {
            addLine(`${distBoxName}:`, groupDistBoxCount.toString());
          }
        } else if(processorGroup && processorGroup.firstScreenName) {
          // This screen is tied to another screen's processor - show reference
          addLine('Processor:', `See ${processorGroup.firstScreenName}`);
        }

        addLine('Panel Count:', activePanels.toString());
        
        // === RIGGING SECTION ===
        addSectionHeader('Rigging Hardware');
        addLine('1W Bumpers:', bumper1wCount.toString());
        addLine('2W Bumpers:', bumper2wCount.toString());
        addLine('4W Bumpers:', bumper4wCount.toString());
        addLine('4W Connecting Plates:', plates4way.toString());
        addLine('2W Connecting Plates:', plates2way.toString());
        
        // 5/8" Shackles and Cheeseye - only for CB5, CB5 Half, MC7, and AMT 8.3 (hanging only)
        const needsShacklesAndCheeseye = ['CB5_MKII', 'CB5_MKII_HALF', 'MC7H', 'INFILED_AMT8_3'].includes(panelType);
        const isHanging = data.structureType === 'hanging';
        
        if(needsShacklesAndCheeseye && isHanging && useBumpers) {
          let shackleCount = 0;
          let cheeseyeCount = 0;
          
          if(panelType === 'INFILED_AMT8_3') {
            // AMT 8.3: 1 per 1W bumper, 2 per 2W bumper
            shackleCount = bumper1wCount + (bumper2wCount * 2);
            cheeseyeCount = bumper1wCount + (bumper2wCount * 2);
          } else {
            // CB5, CB5 Half, MC7: 1 per 1W bumper, 1 per 2W bumper
            shackleCount = bumper1wCount + bumper2wCount;
            cheeseyeCount = bumper1wCount + bumper2wCount;
          }
          
          if(shackleCount > 0) {
            addLine('5/8" Shackles:', shackleCount.toString());
          }
          if(cheeseyeCount > 0) {
            addLine('Cheeseye:', cheeseyeCount.toString());
          }
        }
        
        // === GROUND SUPPORT SECTION ===
        addSectionHeader('Ground Support');
        addLine('Rear Truss:', groundSupport.totalRearTruss.toString());
        addLine('Base Truss:', groundSupport.totalBaseTruss.toString());
        addLine('Bridge Clamps:', groundSupport.totalBridgeClamps.toString());
        addLine('Rear Bridge Adapter:', groundSupport.totalRearBridgeClampAdapters.toString());
        addLine('Sandbags:', groundSupport.totalSandbags.toString());
        addLine('Swivel Cheeseborough:', groundSupport.totalSwivelCheeseboroughs.toString());
        addLine('Pipe' + pipeLengthStr + ':', groundSupport.totalPipes.toString());

        // === FLOOR HARDWARE SECTION ===
        const floorFrames = calcData.floorFrames || {
          frame_1x1: 0,
          frame_2x1: 0,
          frame_2x2: 0,
          frame_3x2: 0,
          totalWeightLbs: 0
        };
        const hasFloorFrames = floorFrames.frame_1x1 > 0 || floorFrames.frame_2x1 > 0 ||
                               floorFrames.frame_2x2 > 0 || floorFrames.frame_3x2 > 0;
        if(hasFloorFrames) {
          addSectionHeader('Floor Hardware');
          if(floorFrames.frame_3x2 > 0) addLine('3×2 Frame:', floorFrames.frame_3x2.toString());
          if(floorFrames.frame_2x2 > 0) addLine('2×2 Frame:', floorFrames.frame_2x2.toString());
          if(floorFrames.frame_2x1 > 0) addLine('2×1 Frame:', floorFrames.frame_2x1.toString());
          if(floorFrames.frame_1x1 > 0) addLine('1×1 Frame:', floorFrames.frame_1x1.toString());
        }

        // === DATA CABLES SECTION (now includes Cat6) ===
        addSectionHeader('Data Cables');
        // Get cable lengths from panel specs
        const dataJumperLen = p && p.data_jumper_ft ? p.data_jumper_ft : '';
        const dataCrossJumperLen = p && p.data_cross_jumper_ft ? p.data_cross_jumper_ft : '';
        const jumpersBuiltin = p && p.jumpers_builtin;
        
        // Only show data jumpers if not built-in to panel
        if(!jumpersBuiltin && dataJumperLen) {
          addLine(`Data Jumpers ${dataJumperLen}:`, activePanels.toString());
        }
        if(dataCrossJumperLen && dataCrossJumperCount > 0) {
          addLine(`Data Cross Jumpers ${dataCrossJumperLen}:`, dataCrossJumperCount.toString());
        }
        // Cat5 Couplers - needed for CB5, CB5 Half, MC7 panels
        // Count = data cross jumpers (column transitions) + data lines (one per line to connect to distro)
        if(jumpersBuiltin) {
          const dataLinesCount = calcData.dataLines || 0;
          const totalCat5Couplers = dataCrossJumperCount + dataLinesCount;
          if(totalCat5Couplers > 0) {
            addLine('Cat5 Couplers:', totalCat5Couplers.toString());
          }
        }
        addLine("200' Cat6:", '');
        addLine("100' Cat6:", '');
        addLine("50' Cat6:", '');
        addLine("25' Cat6:", '');
        addLine("10' Cat6:", '');
        addLine("5' Cat6:", '');
        
        // === POWER CABLES SECTION ===
        addSectionHeader('Power Cables');
        // Get power jumper length from panel specs
        const powerJumperLen = p && p.power_jumper_ft ? p.power_jumper_ft : '';
        
        // Only show power jumpers if not built-in to panel
        if(!jumpersBuiltin && powerJumperLen) {
          addLine(`Power Jumpers ${powerJumperLen}:`, activePanels.toString());
        }
        addLine('Soca Splays:', socaCount.toString());
        addLine("100' Soca:", '');
        addLine("75' Soca:", '');
        addLine("50' Soca:", '');
        addLine("25' Soca:", '');
        addLine("50' True1:", '');
        addLine("25' True1:", (socaCount * 2).toString());
        addLine("10' True1:", (socaCount * 2).toString());
        addLine("5' True1:", (socaCount * 4).toString());
        addLine("3' True1:", '');
        addLine('True1 Twofer:', columnsPerCircuit > 1 ? (circuitsNeeded * columnsPerCircuit).toString() : '');
        
        // ========== COLUMN 2 ==========
        switchToColumn2();
        
        // === SIGNAL CABLES SECTION (only on first screen) ===
        if(isFirstScreen) {
          addSectionHeader('Signal Cables');
          addLine("500' Fiber Opticon:", '');
          addLine('Fiber 4ch Opticon Splay:', '');
          
          const processorCount = processorGroup ? processorGroup.processorCount : 0;
          const sdiPerProcessor = processorCount * 2;
          if(is4KCanvas) {
            // 4K canvas needs 12G SDI cables (25ft or longer only)
            addLine("100' 12G SDI:", sdiPerProcessor.toString());
            addLine("75' 12G SDI:", '');
            addLine("50' 12G SDI:", sdiPerProcessor.toString());
            addLine("25' 12G SDI:", sdiPerProcessor.toString());
          } else {
            // HD canvas uses regular SDI
            addLine("100' SDI:", sdiPerProcessor.toString());
            addLine("75' SDI:", '');
            addLine("50' SDI:", sdiPerProcessor.toString());
            addLine("25' SDI:", sdiPerProcessor.toString());
            addLine("10' SDI:", '6');
            addLine("3' SDI:", '6');
          }
          
          // HDMI
          addLine("25' HDMI:", '6');
          addLine("10' HDMI:", '6');
          addLine("6' HDMI:", '6');
        }
        
        // === UTILITY SECTION (only on first screen) ===
        if(isFirstScreen) {
          addSectionHeader('Utility');
          addLine("UG 10':", '8');
          addLine("UG 25':", '6');
          addLine("UG 50':", '6');
          addLine('UG Twofers:', '8');
          addLine('Power Bars:', '8');
        }
        
        // === SPARES SECTION ===
        addSectionHeader('SPARES');
        addLine('Spare Soca Splays:', '');
        addLine('Spare Panel Count:', '');
        // Only show spare jumpers if not built-in to panel
        if(!jumpersBuiltin && dataJumperLen) {
          addLine(`Spare Data Jumpers ${dataJumperLen}:`, '');
        }
        if(dataCrossJumperLen) {
          addLine(`Spare Data Cross Jumpers ${dataCrossJumperLen}:`, '');
        }
        // Spare Cat5 couplers only for panels with built-in jumpers
        if(jumpersBuiltin) {
          addLine('Spare Cat5 Couplers:', '');
        }
        if(!jumpersBuiltin && powerJumperLen) {
          addLine(`Spare Power Jumpers ${powerJumperLen}:`, '');
        }
        addLine('Spare Soca:', '');
        addLine('Spare Data:', '');
        addLine('Spare Fiber:', '');
        
        // Set final yOffset to the max of both columns
        yOffset = Math.max(col1Y, col2Y);
        
        console.log('Gear list completed, final yOffset:', yOffset);
        
      } catch(e) {
        console.error('Error generating gear list:', e);
        console.error('Stack trace:', e.stack);
      }
      
      // Call callback when done
      console.log('Calling gear list callback');
      if(callback) setTimeout(callback, 10);
    }
    
    function finalizePDF() {
      updateProgress('Saving PDF...', 95);

      // Restore original screen
      switchToScreen(originalScreenId);

      // Restore the original app mode view (this ensures containers are properly hidden/shown)
      // This is critical when exporting from Combined view to restore proper container visibility
      if(typeof switchMobileView === 'function' && typeof currentAppMode !== 'undefined') {
        switchMobileView(currentAppMode);
      }

      setTimeout(() => {
        updateProgress('Saving PDF...', 100);

        // Save the PDF
        const date = new Date().toISOString().slice(0,10);
        const configName = document.getElementById('configName').value.trim();
        const filename = configName
          ? `${configName}_${date}.pdf`
          : `LED_Wall_Calculator_${date}.pdf`;

        // Use blob approach for better iOS compatibility
        const pdfBlob = pdf.output('blob');

        // Download function
        function downloadPDF() {
          const blobUrl = URL.createObjectURL(pdfBlob);
          const link = document.createElement('a');
          link.href = blobUrl;
          link.download = filename;
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();

          setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(blobUrl);
          }, 100);

          setTimeout(removeOverlay, 100);
        }

        // Check if we're on a mobile device (touch-enabled and small screen or mobile user agent)
        const isMobileDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) &&
                               (window.innerWidth <= 1024 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));

        // Try native share API only on mobile (iOS/Android - allows "Save to Files")
        // Desktop browsers may support Share API but direct download is better UX
        if(isMobileDevice && navigator.share && navigator.canShare) {
          const file = new File([pdfBlob], filename, { type: 'application/pdf' });
          if(navigator.canShare({ files: [file] })) {
            // Only pass files - do NOT include title/text as they create separate text files
            navigator.share({
              files: [file]
            }).then(() => {
              removeOverlay();
            }).catch((err) => {
              // User cancelled or share failed - fall back to download
              console.log('Share cancelled or failed:', err);
              downloadPDF();
            });
            return;
          }
        }

        // Desktop or Share API not available - use direct download
        downloadPDF();
      }, 150);
    }
    
    // Start processing
    processNextScreen();
    
  } catch(err) {
    console.error('PDF export error:', err);
    alert('Error exporting PDF: ' + err.message);
    // Make sure to remove overlay and reset print modes on error
    const overlay = document.getElementById('pdfExportOverlay');
    if(overlay) overlay.remove();
    if (ecoPrintMode || greyscalePrintMode) {
      ecoPrintMode = false;
      greyscalePrintMode = false;
      generateLayout('standard');
      generateLayout('power');
      generateLayout('data');
      generateStructureLayout();
    }
  }
}

function exportCanvas(){
  try {
    const canvas = document.getElementById('canvasView');
    if(canvas.width === 0 || document.getElementById('canvasContainer').style.display === 'none'){
      alert('Please generate a canvas view first by clicking "Calculate".');
      return;
    }
    
    const format = document.getElementById('canvasExportFormat').value;
    
    // Get the canvas size label
    const canvasSizeSelect = document.getElementById('canvasSize');
    const canvasSizeValue = canvasSizeSelect.value;
    let canvasSizeLabel;
    
    // For custom size, use the actual dimensions
    if(canvasSizeValue === 'custom') {
      canvasSizeLabel = `${canvas.width}x${canvas.height}`;
    } else {
      // Clean up the label (e.g., "4K UHD (3840x2160)" -> "4K_UHD_3840x2160")
      canvasSizeLabel = canvasSizeSelect.options[canvasSizeSelect.selectedIndex].text
        .replace(/\s+/g, '_')
        .replace(/[()]/g, '');
    }
    
    const filenameInput = document.getElementById('canvasExportFilename');
    let customName = filenameInput ? filenameInput.value.trim() : '';
    
    // Always include canvas size in filename
    let filename;
    if(customName) {
      // If custom name provided, append canvas size
      filename = `${customName}_${canvasSizeLabel}`;
    } else {
      // Default name with canvas size
      filename = `LED_Wall_Canvas_${canvasSizeLabel}`;
    }
    
    // Clean filename of invalid characters
    filename = filename.replace(/[<>:"/\\|?*]/g, '_');
    
    // Create a clean canvas without selection highlight or border for export
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;
    const exportCtx = exportCanvas.getContext('2d');

    // Use cached image data without border for clean export
    if(cachedCanvasImageDataForExport) {
      exportCtx.putImageData(cachedCanvasImageDataForExport, 0, 0);
    } else if(cachedCanvasImageData) {
      // Fallback to regular cache if export cache not available
      exportCtx.putImageData(cachedCanvasImageData, 0, 0);
    } else {
      exportCtx.drawImage(canvas, 0, 0);
    }
    
    // Handle Resolume XML export
    if(format === 'resolume') {
      exportResolumeXML(filename);
      return;
    }

    // Export the clean canvas using blob for better mobile compatibility
    const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';
    const extension = format === 'jpeg' ? '.jpg' : '.png';
    const quality = format === 'jpeg' ? 0.95 : undefined;

    exportCanvas.toBlob(function(blob) {
      if(!blob) {
        alert('Failed to create image. Please try again.');
        return;
      }

      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename + extension;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();

      // Cleanup
      setTimeout(function() {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 100);
    }, mimeType, quality);
  } catch(err) {
    alert('Error exporting canvas: ' + err.message);
    console.error('Export error:', err);
  }
}

// Export Resolume Arena XML file
function exportResolumeXML(filename) {
  try {
    const screenKeys = Object.keys(screens);
    if(screenKeys.length === 0) {
      alert('No screens to export. Please add at least one screen.');
      return;
    }

    // Get canvas dimensions
    const canvas = document.getElementById('canvasView');
    const canvasWidth = canvas ? canvas.width : 1920;
    const canvasHeight = canvas ? canvas.height : 1080;

    // Get all panels (built-in + custom)
    const allPanels = getAllPanels();

    // Generate unique ID for Resolume
    function generateUniqueId() {
      return Math.floor(Math.random() * 9000000000000000) + 1000000000000000;
    }

    // Build slices XML for each screen
    let slicesXml = '';

    screenKeys.forEach(key => {
      const screen = screens[key];
      const screenData = screen.data || screen;
      const panelType = screenData.panelType || 'CB5_MKII';
      const panel = allPanels[panelType];
      if(!panel) return;

      // Skip non-visible screens
      if(screen.visible === false) return;

      // Calculate screen dimensions in pixels
      const panelResX = panel.res_x || 1;
      const panelResY = panel.res_y || 1;
      const screenResX = (screenData.panelsWide || 0) * panelResX;
      const screenResY = (screenData.panelsHigh || 0) * panelResY;

      if(screenResX === 0 || screenResY === 0) return;

      // Get screen position (default to 0,0 if not set)
      const screenX = screenData.canvasX || 0;
      const screenY = screenData.canvasY || 0;

      // Create bezier warper vertices (4x4 grid) - uses actual pixel positions
      let verticesXml = '';
      for(let row = 0; row < 4; row++) {
        for(let col = 0; col < 4; col++) {
          const x = screenX + Math.round((col / 3) * screenResX);
          const y = screenY + Math.round((row / 3) * screenResY);
          verticesXml += `
                  <v x="${x}" y="${y}"/>`;
        }
      }

      // InputRect vertices (source rectangle - at canvas position, same as output)
      const inputVertices = `
              <v x="${screenX}" y="${screenY}"/>
              <v x="${screenX + screenResX}" y="${screenY}"/>
              <v x="${screenX + screenResX}" y="${screenY + screenResY}"/>
              <v x="${screenX}" y="${screenY + screenResY}"/>`;

      // OutputRect vertices (destination rectangle - at canvas position)
      const outputVertices = `
              <v x="${screenX}" y="${screenY}"/>
              <v x="${screenX + screenResX}" y="${screenY}"/>
              <v x="${screenX + screenResX}" y="${screenY + screenResY}"/>
              <v x="${screenX}" y="${screenY + screenResY}"/>`;

      slicesXml += `
          <Slice>
            <Params name="Common">
              <Param name="Name" default="Layer" value="${screen.name || 'Screen'}"/>
            </Params>
            <InputRect orientation="0">${inputVertices}
            </InputRect>
            <OutputRect orientation="0">${outputVertices}
            </OutputRect>
            <Warper>
              <Params name="Warper">
                <ParamChoice name="Point Mode" default="PM_LINEAR" value="PM_LINEAR" storeChoices="0"/>
                <Param name="Flip" default="0" value="0"/>
              </Params>
              <BezierWarper controlWidth="4" controlHeight="4">
                <vertices>${verticesXml}
                </vertices>
              </BezierWarper>
            </Warper>
          </Slice>`;
    });

    // Calculate total canvas resolution (max extent of all screens)
    let totalWidth = canvasWidth;
    let totalHeight = canvasHeight;

    screenKeys.forEach(key => {
      const screen = screens[key];
      if(screen.visible === false) return;
      const screenData = screen.data || screen;
      const panelType = screenData.panelType || 'CB5_MKII';
      const panel = allPanels[panelType];
      if(!panel) return;

      const screenResX = (screenData.panelsWide || 0) * (panel.res_x || 1);
      const screenResY = (screenData.panelsHigh || 0) * (panel.res_y || 1);
      const screenX = screenData.canvasX || 0;
      const screenY = screenData.canvasY || 0;

      totalWidth = Math.max(totalWidth, screenX + screenResX);
      totalHeight = Math.max(totalHeight, screenY + screenResY);
    });

    // Generate unique ID for screen
    const screenUniqueId = generateUniqueId();

    // Build complete XML matching Resolume Arena 7 format
    const xml = `<?xml version="1.0" encoding="UTF-8"?>

<XmlState name="${filename}">
  <versionInfo name="Resolume Arena" majorVersion="7" minorVersion="23" microVersion="2"
               revision="51094"/>
  <ScreenSetup name="ScreenSetup">
    <Params name="ScreenSetupParams"/>
    <screens>
      <Screen name="Screen 1" uniqueId="${screenUniqueId}">
        <layers>${slicesXml}
        </layers>
        <OutputDevice>
          <OutputDeviceVirtual name="Screen 1" deviceId="VirtualScreen 1" idHash="${generateUniqueId()}"
                               width="${totalWidth}" height="${totalHeight}">
            <Params name="Params">
              <ParamRange name="Width" default="${totalWidth}" value="${totalWidth}"/>
              <ValueRange name="defaultRange" min="1" max="16384"/>
              <ParamRange name="Height" default="${totalHeight}" value="${totalHeight}"/>
            </Params>
          </OutputDeviceVirtual>
        </OutputDevice>
      </Screen>
    </screens>
  </ScreenSetup>
</XmlState>`;

    // Create blob and download
    const blob = new Blob([xml], { type: 'application/xml' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename + '.xml';
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();

    // Cleanup
    setTimeout(function() {
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }, 100);

  } catch(err) {
    alert('Error exporting Resolume XML: ' + err.message);
    console.error('Resolume export error:', err);
  }
}

function setupLive(){
  // Note: panelType is NOT included here because it has its own handler that calls resetCalculator()
  // Note: canvasX and canvasY have their own handler below to properly move screens
  const liveIds = ['processor','powerType','panelsWide','panelsHigh','voltage','breaker','phase','maxPanelsPerCircuit','maxPanelsPerData','dataStartDir','showArrows','canvasSize','wallWidth','wallHeight','frameRate','bitDepth','redundancy','customCanvasWidth','customCanvasHeight','addCB5HalfRow'];

  liveIds.forEach(id => {
    const el = document.getElementById(id);
    if(!el) {
      return;
    }

    // Add event listener to trigger canvas update when value changes
    const eventType = (el.type === 'checkbox' || el.tagName === 'SELECT') ? 'change' : 'input';
    el.addEventListener(eventType, function() {
      // Update current screen data when inputs change
      saveCurrentScreenData();
      // Trigger recalculation which will update all views including canvas
      calculate();
    });
  });

  // Special handler for canvasX and canvasY inputs - moves selected or current screen
  const canvasXInput = document.getElementById('canvasX');
  const canvasYInput = document.getElementById('canvasY');

  function handleCanvasPositionChange() {
    const newX = parseInt(canvasXInput.value) || 0;
    const newY = parseInt(canvasYInput.value) || 0;

    // Determine which screen to move - selected screen takes priority
    const screenToMove = selectedCanvasScreenId || currentScreenId;

    if(screens[screenToMove]) {
      // Update the screen's position
      screens[screenToMove].data.canvasX = newX;
      screens[screenToMove].data.canvasY = newY;

      // If moving the current screen, also update global offset variables
      if(screenToMove === currentScreenId) {
        canvasOffsetX = newX;
        canvasOffsetY = newY;
      }

      // Save undo state
      saveCanvasMoveState();

      // Redraw canvas view
      showCanvasView();

      // Redraw selection highlight if there's a selected screen
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
        updateCanvasInfoDisplay();
      }
    }
  }

  if(canvasXInput) {
    canvasXInput.addEventListener('input', handleCanvasPositionChange);
  }
  if(canvasYInput) {
    canvasYInput.addEventListener('input', handleCanvasPositionChange);
  }
}

// Custom Panel Modal
function openCustomPanelModal(editKey = null) {
  const modal = document.getElementById('customPanelModal');
  const title = document.getElementById('customPanelModalTitle');

  // Update labels based on current unit system
  const isMetric = displayLengthUnit === 'm';
  const lengthUnit = isMetric ? 'mm' : 'in';
  const weightUnit = isMetric ? 'kg' : 'lbs';

  // Update dimension labels
  document.getElementById('labelPixelPitch').textContent = 'Pixel Pitch (mm)'; // Always mm
  document.getElementById('labelPanelWidth').textContent = `Panel Width (${lengthUnit})`;
  document.getElementById('labelPanelHeight').textContent = `Panel Height (${lengthUnit})`;
  document.getElementById('labelPanelDepth').textContent = `Panel Depth (${lengthUnit})`;

  // Update weight labels
  document.getElementById('labelPanelWeight').textContent = `Panel Weight (${weightUnit})`;
  document.getElementById('labelFrameWeight').textContent = `Frame Weight (${weightUnit})`;
  document.getElementById('labelWeightNoFrame').textContent = `Weight Without Frame (${weightUnit})`;
  document.getElementById('label1wBumper').textContent = `1W Bumper Weight (${weightUnit})`;
  document.getElementById('label2wBumper').textContent = `2W Bumper Weight (${weightUnit})`;

  // Conversion constants
  const MM_TO_IN = 0.0393701;
  const IN_TO_MM = 25.4;

  if(editKey) {
    title.textContent = 'Edit Custom Panel';
    const panel = customPanels[editKey];
    document.getElementById('customPanelBrand').value = panel.brand || '';
    document.getElementById('customPanelName').value = panel.name || '';
    document.getElementById('customPanelPixelPitch').value = panel.pixel_pitch_mm || '';

    // Convert dimensions based on unit system (stored in mm internally)
    const widthMm = (panel.width_m * 1000) || '';
    const heightMm = (panel.height_m * 1000) || '';
    const depthMm = panel.depth_mm || '';

    if(isMetric) {
      document.getElementById('customPanelWidth').value = widthMm;
      document.getElementById('customPanelHeight').value = heightMm;
      document.getElementById('customPanelDepth').value = depthMm;
    } else {
      document.getElementById('customPanelWidth').value = widthMm ? (widthMm * MM_TO_IN).toFixed(2) : '';
      document.getElementById('customPanelHeight').value = heightMm ? (heightMm * MM_TO_IN).toFixed(2) : '';
      document.getElementById('customPanelDepth').value = depthMm ? (depthMm * MM_TO_IN).toFixed(2) : '';
    }

    document.getElementById('customPanelResX').value = panel.res_x || '';
    document.getElementById('customPanelResY').value = panel.res_y || '';
    document.getElementById('customPanelPowerMax').value = panel.power_max_w || '';
    document.getElementById('customPanelPowerAvg').value = panel.power_avg_w || '';
    document.getElementById('customPanelBrightness').value = panel.brightness_nits || '';
    document.getElementById('customPanelMaxHanging').value = panel.max_hanging || '';
    document.getElementById('customPanelMaxStacking').value = panel.max_stacking || '';

    // Convert weights based on unit system (stored in kg internally, bumpers in lbs)
    if(isMetric) {
      document.getElementById('customPanelWeight').value = panel.weight_kg || '';
      document.getElementById('customPanelFrameWeight').value = panel.frame_weight_kg || '';
      document.getElementById('customPanelWeightNoFrame').value = panel.weight_no_frame_kg || '';
      // Convert bumper weights from lbs to kg for display
      document.getElementById('customPanel1wBumper').value = panel.bumper_1w_lbs ? (panel.bumper_1w_lbs * LBS_TO_KG).toFixed(2) : '';
      document.getElementById('customPanel2wBumper').value = panel.bumper_2w_lbs ? (panel.bumper_2w_lbs * LBS_TO_KG).toFixed(2) : '';
    } else {
      // Convert kg to lbs for display
      document.getElementById('customPanelWeight').value = panel.weight_kg ? (panel.weight_kg * KG_TO_LBS).toFixed(2) : '';
      document.getElementById('customPanelFrameWeight').value = panel.frame_weight_kg ? (panel.frame_weight_kg * KG_TO_LBS).toFixed(2) : '';
      document.getElementById('customPanelWeightNoFrame').value = panel.weight_no_frame_kg ? (panel.weight_no_frame_kg * KG_TO_LBS).toFixed(2) : '';
      // Bumper weights already stored in lbs
      document.getElementById('customPanel1wBumper').value = panel.bumper_1w_lbs || '';
      document.getElementById('customPanel2wBumper').value = panel.bumper_2w_lbs || '';
    }

    document.getElementById('customPanelRemovableFrame').checked = panel.removable_frame || false;
    modal.dataset.editKey = editKey;
  } else {
    title.textContent = 'Add Custom Panel';
    // Clear all fields
    document.getElementById('customPanelBrand').value = '';
    document.getElementById('customPanelName').value = '';
    document.getElementById('customPanelPixelPitch').value = '';
    document.getElementById('customPanelWidth').value = '';
    document.getElementById('customPanelHeight').value = '';
    document.getElementById('customPanelDepth').value = '';
    document.getElementById('customPanelResX').value = '';
    document.getElementById('customPanelResY').value = '';
    document.getElementById('customPanelPowerMax').value = '';
    document.getElementById('customPanelPowerAvg').value = '';
    document.getElementById('customPanelBrightness').value = '';
    document.getElementById('customPanelMaxHanging').value = '';
    document.getElementById('customPanelMaxStacking').value = '';
    document.getElementById('customPanelWeight').value = '';
    document.getElementById('customPanelRemovableFrame').checked = false;
    document.getElementById('customPanelFrameWeight').value = '';
    document.getElementById('customPanelWeightNoFrame').value = '';
    document.getElementById('customPanel1wBumper').value = '';
    document.getElementById('customPanel2wBumper').value = '';

    delete modal.dataset.editKey;
  }

  modal.classList.add('active');
  updateFrameWeightFields();
}

function closeCustomPanelModal() {
  const modal = document.getElementById('customPanelModal');
  modal.classList.remove('active');
}

function updateFrameWeightFields() {
  const hasFrame = document.getElementById('customPanelRemovableFrame').checked;
  const frameFields = document.getElementById('frameWeightFields');
  frameFields.style.display = hasFrame ? 'block' : 'none';
}

function saveCustomPanel() {
  const brand = document.getElementById('customPanelBrand').value.trim();
  const name = document.getElementById('customPanelName').value.trim();

  if(!brand || !name) {
    alert('Please enter brand and name');
    return;
  }

  const modal = document.getElementById('customPanelModal');
  const editKey = modal.dataset.editKey;
  const key = editKey || `CUSTOM_${brand.replace(/\s+/g, '_')}_${name.replace(/\s+/g, '_')}`;

  // Check current unit system for conversion
  const isMetric = displayLengthUnit === 'm';
  const IN_TO_MM = 25.4;

  // Get raw input values
  const widthInput = parseFloat(document.getElementById('customPanelWidth').value) || null;
  const heightInput = parseFloat(document.getElementById('customPanelHeight').value) || null;
  const depthInput = parseFloat(document.getElementById('customPanelDepth').value) || null;
  const weightInput = parseFloat(document.getElementById('customPanelWeight').value) || null;
  const frameWeightInput = parseFloat(document.getElementById('customPanelFrameWeight').value) || null;
  const weightNoFrameInput = parseFloat(document.getElementById('customPanelWeightNoFrame').value) || null;
  const bumper1wInput = parseFloat(document.getElementById('customPanel1wBumper').value) || null;
  const bumper2wInput = parseFloat(document.getElementById('customPanel2wBumper').value) || null;

  // Convert dimensions to mm (stored as meters for width/height)
  let widthMm, heightMm, depthMm;
  if(isMetric) {
    // Input is in mm
    widthMm = widthInput;
    heightMm = heightInput;
    depthMm = depthInput;
  } else {
    // Input is in inches, convert to mm
    widthMm = widthInput ? widthInput * IN_TO_MM : null;
    heightMm = heightInput ? heightInput * IN_TO_MM : null;
    depthMm = depthInput ? depthInput * IN_TO_MM : null;
  }

  // Convert weights to kg (panel weights) and lbs (bumper weights)
  let weightKg, frameWeightKg, weightNoFrameKg, bumper1wLbs, bumper2wLbs;
  if(isMetric) {
    // Input is in kg
    weightKg = weightInput;
    frameWeightKg = frameWeightInput;
    weightNoFrameKg = weightNoFrameInput;
    // Bumper input is in kg, convert to lbs for storage
    bumper1wLbs = bumper1wInput ? bumper1wInput * KG_TO_LBS : null;
    bumper2wLbs = bumper2wInput ? bumper2wInput * KG_TO_LBS : null;
  } else {
    // Input is in lbs, convert to kg for panel weights
    weightKg = weightInput ? weightInput * LBS_TO_KG : null;
    frameWeightKg = frameWeightInput ? frameWeightInput * LBS_TO_KG : null;
    weightNoFrameKg = weightNoFrameInput ? weightNoFrameInput * LBS_TO_KG : null;
    // Bumper weights stay in lbs
    bumper1wLbs = bumper1wInput;
    bumper2wLbs = bumper2wInput;
  }

  const panel = {
    brand: brand,
    name: name,
    pixel_pitch_mm: parseFloat(document.getElementById('customPanelPixelPitch').value) || null,
    width_m: widthMm ? widthMm / 1000 : null,
    height_m: heightMm ? heightMm / 1000 : null,
    depth_mm: depthMm,
    res_x: parseInt(document.getElementById('customPanelResX').value) || null,
    res_y: parseInt(document.getElementById('customPanelResY').value) || null,
    power_max_w: parseFloat(document.getElementById('customPanelPowerMax').value) || null,
    power_avg_w: parseFloat(document.getElementById('customPanelPowerAvg').value) || null,
    brightness_nits: parseInt(document.getElementById('customPanelBrightness').value) || null,
    max_hanging: parseInt(document.getElementById('customPanelMaxHanging').value) || null,
    max_stacking: parseInt(document.getElementById('customPanelMaxStacking').value) || null,
    weight_kg: weightKg,
    removable_frame: document.getElementById('customPanelRemovableFrame').checked,
    frame_weight_kg: frameWeightKg,
    weight_no_frame_kg: weightNoFrameKg,
    bumper_1w_lbs: bumper1wLbs,
    bumper_2w_lbs: bumper2wLbs,
    bumper_4w_lbs: 66.15, // Default 4W bumper weight
    custom: true
  };

  customPanels[key] = panel;
  saveCustomPanels();
  updatePanelDropdowns();

  // Select the new/edited panel
  const panelSelect = document.getElementById('panelType');
  if(panelSelect) {
    panelSelect.value = key;
  }

  closeCustomPanelModal();
  alert(`Custom panel "${brand} ${name}" saved successfully!`);
}

// Request Item Modal
let currentRequestType = 'panel';

function setRequestType(type) {
  currentRequestType = type;
  document.getElementById('requestTypePanelBtn').classList.toggle('active', type === 'panel');
  document.getElementById('requestTypeProcessorBtn').classList.toggle('active', type === 'processor');
}

function openRequestItemModal() {
  const modal = document.getElementById('requestItemModal');
  document.getElementById('requestBrand').value = '';
  document.getElementById('requestModel').value = '';
  document.getElementById('requestNotes').value = '';
  setRequestType('panel');
  modal.classList.add('active');
}

function openProcessorRequestModal() {
  const modal = document.getElementById('requestItemModal');
  document.getElementById('requestBrand').value = '';
  document.getElementById('requestModel').value = '';
  document.getElementById('requestNotes').value = '';
  setRequestType('processor');
  modal.classList.add('active');
}

function closeRequestItemModal() {
  const modal = document.getElementById('requestItemModal');
  modal.classList.remove('active');
}

function sendItemRequest() {
  const brand = document.getElementById('requestBrand').value.trim();
  const model = document.getElementById('requestModel').value.trim();
  const notes = document.getElementById('requestNotes').value.trim();

  if(!brand || !model) {
    alert('Please enter both brand and model name');
    return;
  }

  const typeLabel = currentRequestType === 'panel' ? 'Panel' : 'Processor';
  const subject = encodeURIComponent(`LED Calculator - ${typeLabel} Request: ${brand} ${model}`);

  // Use %0D%0A for line breaks (works better on mobile email clients)
  const nl = '%0D%0A';
  let body = `Hi Gabriel,${nl}${nl}`;
  body += `I'd like to request adding a new ${typeLabel.toLowerCase()} to the LED Calculator app.${nl}${nl}`;
  body += `Type: ${typeLabel}${nl}`;
  body += `Brand: ${brand}${nl}`;
  body += `Model: ${model}${nl}`;
  if(notes) {
    body += `${nl}Additional Info:${nl}${encodeURIComponent(notes)}${nl}`;
  }
  body += `${nl}Thank you!`;

  const mailtoLink = `mailto:fearlesswandererproductions@gmail.com?subject=${subject}&body=${body}`;
  window.location.href = mailtoLink;

  closeRequestItemModal();
}

// Delete custom panel
function deleteCustomPanel(key) {
  const panel = customPanels[key];
  if(confirm(`Delete custom panel "${panel.brand} ${panel.name}"?`)) {
    delete customPanels[key];
    saveCustomPanels();
    updatePanelDropdowns();
    closeManageCustomModal();
  }
}

// Delete custom processor
function deleteCustomProcessor(key) {
  const proc = customProcessors[key];
  if(confirm(`Delete custom processor "${proc.name}"?`)) {
    delete customProcessors[key];
    saveCustomProcessors();
    updateProcessorDropdowns();
    closeManageCustomModal();
  }
}

// Manage Custom Panels Modal
function openManageCustomModal() {
  const modal = document.getElementById('manageCustomModal');

  // Populate panels list
  const panelsContent = document.getElementById('manageCustomPanelsContent');
  let panelsHtml = '';
  if(Object.keys(customPanels).length === 0) {
    panelsHtml = '<p style="color: #888; text-align: center; padding: 20px;">No custom panels saved yet.</p>';
  } else {
    panelsHtml = '<div class="custom-item-list">';
    Object.keys(customPanels).forEach(key => {
      const panel = customPanels[key];
      panelsHtml += `
        <div class="custom-item">
          <div class="custom-item-name">${panel.brand} ${panel.name}</div>
          <div class="custom-item-actions">
            <button class="btn-small" onclick="openCustomPanelModal('${key}'); closeManageCustomModal();">Edit</button>
            <button class="btn-small danger" onclick="deleteCustomPanel('${key}')">Delete</button>
          </div>
        </div>
      `;
    });
    panelsHtml += '</div>';
  }
  panelsContent.innerHTML = panelsHtml;

  modal.classList.add('active');
}

function closeManageCustomModal() {
  const modal = document.getElementById('manageCustomModal');
  modal.classList.remove('active');
}

// Setup removable frame checkbox listener
document.addEventListener('DOMContentLoaded', function() {
  const frameCheckbox = document.getElementById('customPanelRemovableFrame');
  if(frameCheckbox) {
    frameCheckbox.addEventListener('change', updateFrameWeightFields);
  }
});

// ==================== END CUSTOM MODAL FUNCTIONS ====================

// Canvas movement history functions
function saveCanvasMoveState() {
  // Save positions of ALL screens
  const state = {
    screenPositions: {}
  };
  
  // Store each screen's position
  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    state.screenPositions[screenId] = {
      x: screen.data.canvasX || 0,
      y: screen.data.canvasY || 0
    };
  });
  
  // Also store which screen is selected
  state.selectedScreenId = selectedCanvasScreenId;
  
  // Remove any states after current index (user made a new move after undoing)
  canvasMoveHistory = canvasMoveHistory.slice(0, canvasMoveHistoryIndex + 1);
  
  // Add new state
  canvasMoveHistory.push(state);
  
  // Limit history size
  if(canvasMoveHistory.length > MAX_CANVAS_HISTORY) {
    canvasMoveHistory.shift();
  } else {
    canvasMoveHistoryIndex++;
  }
  
  updateCanvasUndoRedoButtons();
}

function undoCanvasMove() {
  // Need at least 2 states to undo (current + previous)
  if(canvasMoveHistoryIndex <= 0) return;
  
  // Move back one step
  canvasMoveHistoryIndex--;
  
  // Restore the state at this index
  const previousState = canvasMoveHistory[canvasMoveHistoryIndex];
  
  // Restore all screen positions
  if(previousState.screenPositions) {
    Object.keys(previousState.screenPositions).forEach(screenId => {
      if(screens[screenId]) {
        screens[screenId].data.canvasX = previousState.screenPositions[screenId].x;
        screens[screenId].data.canvasY = previousState.screenPositions[screenId].y;
      }
    });
  } else {
    // Legacy format - single x/y (for backwards compatibility)
    if(selectedCanvasScreenId && screens[selectedCanvasScreenId]) {
      screens[selectedCanvasScreenId].data.canvasX = previousState.x;
      screens[selectedCanvasScreenId].data.canvasY = previousState.y;
    } else if(screens[currentScreenId]) {
      screens[currentScreenId].data.canvasX = previousState.x;
      screens[currentScreenId].data.canvasY = previousState.y;
    }
  }
  
  // Update X/Y inputs to show selected or current screen position
  const displayScreenId = selectedCanvasScreenId || currentScreenId;
  if(screens[displayScreenId]) {
    document.getElementById('canvasX').value = screens[displayScreenId].data.canvasX || 0;
    document.getElementById('canvasY').value = screens[displayScreenId].data.canvasY || 0;
    
    // Update global variables if it's the current screen
    if(displayScreenId === currentScreenId) {
      canvasOffsetX = screens[displayScreenId].data.canvasX || 0;
      canvasOffsetY = screens[displayScreenId].data.canvasY || 0;
    }
  }
  
  // Redraw canvas
  showCanvasView();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateCanvasUndoRedoButtons();
}

function redoCanvasMove() {
  // Check if we can redo
  if(canvasMoveHistoryIndex >= canvasMoveHistory.length - 1) return;
  
  // Move forward one step
  canvasMoveHistoryIndex++;
  
  // Restore the state at this index
  const nextState = canvasMoveHistory[canvasMoveHistoryIndex];
  
  // Restore all screen positions
  if(nextState.screenPositions) {
    Object.keys(nextState.screenPositions).forEach(screenId => {
      if(screens[screenId]) {
        screens[screenId].data.canvasX = nextState.screenPositions[screenId].x;
        screens[screenId].data.canvasY = nextState.screenPositions[screenId].y;
      }
    });
  } else {
    // Legacy format - single x/y (for backwards compatibility)
    if(selectedCanvasScreenId && screens[selectedCanvasScreenId]) {
      screens[selectedCanvasScreenId].data.canvasX = nextState.x;
      screens[selectedCanvasScreenId].data.canvasY = nextState.y;
    } else if(screens[currentScreenId]) {
      screens[currentScreenId].data.canvasX = nextState.x;
      screens[currentScreenId].data.canvasY = nextState.y;
    }
  }
  
  // Update X/Y inputs to show selected or current screen position
  const displayScreenId = selectedCanvasScreenId || currentScreenId;
  if(screens[displayScreenId]) {
    document.getElementById('canvasX').value = screens[displayScreenId].data.canvasX || 0;
    document.getElementById('canvasY').value = screens[displayScreenId].data.canvasY || 0;
    
    // Update global variables if it's the current screen
    if(displayScreenId === currentScreenId) {
      canvasOffsetX = screens[displayScreenId].data.canvasX || 0;
      canvasOffsetY = screens[displayScreenId].data.canvasY || 0;
    }
  }
  
  // Redraw canvas
  showCanvasView();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateCanvasUndoRedoButtons();
}

function updateCanvasUndoRedoButtons() {
  const undoBtn = document.getElementById('canvasUndoBtn');
  const redoBtn = document.getElementById('canvasRedoBtn');
  
  if(undoBtn) {
    undoBtn.disabled = canvasMoveHistoryIndex <= 0;
  }
  if(redoBtn) {
    redoBtn.disabled = canvasMoveHistoryIndex >= canvasMoveHistory.length - 1;
  }
}

// Save/Load configuration functions
function saveConfiguration() {
  const configName = document.getElementById('configName').value.trim() || 'LED_Wall_Config';
  
  // Save current screen data first
  saveCurrentScreenData();
  
  // Prepare screens data for saving (convert Sets to Arrays)
  const screensData = {};
  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    const data = screen.data;
    
    // Safely convert deletedPanels
    let deletedPanelsArray = [];
    if(data.deletedPanels instanceof Set) {
      deletedPanelsArray = Array.from(data.deletedPanels);
    } else if(Array.isArray(data.deletedPanels)) {
      deletedPanelsArray = data.deletedPanels;
    }
    
    // Safely convert customCircuitAssignments
    let circuitAssignmentsArray = [];
    if(data.customCircuitAssignments instanceof Map) {
      circuitAssignmentsArray = Array.from(data.customCircuitAssignments.entries());
    } else if(Array.isArray(data.customCircuitAssignments)) {
      circuitAssignmentsArray = data.customCircuitAssignments;
    }
    
    // Safely convert customDataLineAssignments
    let dataLineAssignmentsArray = [];
    if(data.customDataLineAssignments instanceof Map) {
      dataLineAssignmentsArray = Array.from(data.customDataLineAssignments.entries());
    } else if(Array.isArray(data.customDataLineAssignments)) {
      dataLineAssignmentsArray = data.customDataLineAssignments;
    }
    
    // Build data object explicitly without spread to avoid Set/Map issues
    screensData[screenId] = {
      name: screen.name,
      color: screen.color,
      color2: screen.color2,
      visible: screen.visible,
      data: {
        panelsWide: data.panelsWide,
        panelsHigh: data.panelsHigh,
        wallWidth: data.wallWidth,
        wallHeight: data.wallHeight,
        lengthUnit: data.lengthUnit,
        weightUnit: data.weightUnit,
        dimensionMode: data.dimensionMode,
        panelType: data.panelType,
        voltage: data.voltage,
        breaker: data.breaker,
        phase: data.phase,
        powerType: data.powerType,
        maxPanelsPerCircuit: data.maxPanelsPerCircuit,
        processor: data.processor,
        frameRate: data.frameRate,
        bitDepth: data.bitDepth,
        maxPanelsPerData: data.maxPanelsPerData,
        dataStartDir: data.dataStartDir,
        showArrows: data.showArrows,
        redundancy: data.redundancy,
        processorRedundancy: data.processorRedundancy,
        structureType: data.structureType,
        useBumpers: data.useBumpers,
        use4WayBumpers: data.use4WayBumpers,
        addCB5HalfRow: data.addCB5HalfRow,
        connectionMethod: data.connectionMethod,
        wallToFloor: data.wallToFloor,
        distroToWall: data.distroToWall,
        processorToWall: data.processorToWall,
        serverToProcessor: data.serverToProcessor,
        cablePick: data.cablePick,
        cableDropPosition: data.cableDropPosition,
        distBoxOnWall: data.distBoxOnWall,
        canvasX: data.canvasX,
        canvasY: data.canvasY,
        canvasSize: data.canvasSize,
        customCanvasWidth: data.customCanvasWidth,
        customCanvasHeight: data.customCanvasHeight,
        snapMode: data.snapMode,
        arrowKeyIncrement: data.arrowKeyIncrement,
        canvasExportFormat: data.canvasExportFormat,
        showTopBumper: data.showTopBumper,
        showBottomBumper: data.showBottomBumper,
        topBumper1wColumn: data.topBumper1wColumn,
        bottomBumper1wColumn: data.bottomBumper1wColumn,
        bumpers: Array.isArray(data.bumpers) ? data.bumpers : [],
        bumpersInitialized: data.bumpersInitialized || false,
        nextBumperId: data.nextBumperId || 1,
        deletedPanels: deletedPanelsArray,
        customCircuitAssignments: circuitAssignmentsArray,
        customDataLineAssignments: dataLineAssignmentsArray
      },
      calculatedData: screen.calculatedData || {}
    };
  });
  
  // Gather all configuration
  const config = {
    version: '2.0',
    timestamp: new Date().toISOString(),
    name: configName,
    currentScreenId: currentScreenId,
    screenIdCounter: screenIdCounter,
    screens: screensData,
    // Global settings
    displayLengthUnit: displayLengthUnit,
    displayWeightUnit: displayWeightUnit
  };
  
  // Convert to JSON and download
  const json = JSON.stringify(config, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${configName.replace(/\s+/g, '_')}.ledconfig`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  alert(`Configuration "${configName}" saved successfully!`);
}

function loadConfiguration(event) {
  const file = event.target.files[0];
  if(!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);
      
      // Verify version
      if(!config.version) {
        throw new Error('Invalid configuration file');
      }
      
      // Check if this is a v2.0 multi-screen config
      if(config.version === '2.0' && config.screens) {
        // Load multi-screen configuration
        
        // Clear existing screens UI
        const tabsContainer = document.getElementById('screenTabsContainer');
        if(tabsContainer) {
          tabsContainer.innerHTML = '';
        }
        
        // Reset screens object
        screens = {};
        
        // Restore screens data
        Object.keys(config.screens).forEach(screenId => {
          const savedScreen = config.screens[screenId];
          
          // Safely restore deletedPanels
          let deletedPanelsSet = new Set();
          if(Array.isArray(savedScreen.data.deletedPanels)) {
            deletedPanelsSet = new Set(savedScreen.data.deletedPanels);
          }
          
          // Safely restore customCircuitAssignments
          let circuitAssignmentsMap = new Map();
          if(Array.isArray(savedScreen.data.customCircuitAssignments)) {
            circuitAssignmentsMap = new Map(savedScreen.data.customCircuitAssignments);
          }
          
          // Safely restore customDataLineAssignments
          let dataLineAssignmentsMap = new Map();
          if(Array.isArray(savedScreen.data.customDataLineAssignments)) {
            dataLineAssignmentsMap = new Map(savedScreen.data.customDataLineAssignments);
          }
          
          // Get screen index for default colors
          const screenIndex = Object.keys(screens).length;
          const defaultColor = screenColors[screenIndex] || '#808080';
          const defaultColor2 = screenColors2[screenIndex] || '#606060';
          
          screens[screenId] = {
            name: savedScreen.name,
            color: savedScreen.color || defaultColor,
            color2: savedScreen.color2 || defaultColor2,
            visible: savedScreen.visible !== false,
            data: {
              ...savedScreen.data,
              deletedPanels: deletedPanelsSet,
              customCircuitAssignments: circuitAssignmentsMap,
              customDataLineAssignments: dataLineAssignmentsMap
            },
            calculatedData: savedScreen.calculatedData || {}
          };
        });
        
        // Restore counters
        screenIdCounter = config.screenIdCounter || Object.keys(screens).length;
        currentScreenId = config.currentScreenId || 'screen_1';
        
        // Restore global settings
        displayLengthUnit = config.displayLengthUnit || 'ft';
        displayWeightUnit = config.displayWeightUnit || 'lbs';
        
        // Update unit buttons
        const isImperial = displayLengthUnit === 'ft';
        document.getElementById('unitImperial')?.classList.toggle('active', isImperial);
        document.getElementById('unitMetric')?.classList.toggle('active', !isImperial);
        
        // Rebuild screen tabs using the proper render function
        renderScreenTabs();
        
        // Load current screen data into form
        loadScreenData(currentScreenId);
        
        // Clear histories
        undoHistory = [];
        redoHistory = [];
        canvasMoveHistory = [];
        canvasMoveHistoryIndex = -1;
        selectedPanels.clear();
        
        // Recalculate
        calculate();

        // Ensure visible screens toggles are updated after all screens are loaded
        setTimeout(function() {
          updateCanvasScreenToggles();
          // Refresh Combined view if it's currently visible
          if(typeof initCombinedView === 'function') {
            combinedSelectedScreens.clear(); // Reset selection for new project
            initCombinedView();
          }
        }, 100);

        alert(`Configuration "${config.name}" loaded successfully! (${Object.keys(screens).length} screens)`);
      } else {
        // Legacy v1.0 single-screen config - load into current screen
        document.getElementById('panelType').value = config.panelType || 'BP2_V2';
        document.getElementById('processor').value = config.processor || 'Brompton_SX40';
        document.getElementById('powerType').value = config.powerType || 'max';
        document.getElementById('panelsWide').value = config.panelsWide || '';
        document.getElementById('panelsHigh').value = config.panelsHigh || '';
        document.getElementById('wallWidth').value = config.wallWidth || '';
        document.getElementById('wallHeight').value = config.wallHeight || '';
        
        // Restore unit settings
        displayLengthUnit = config.lengthUnit || config.units || 'ft';
        displayWeightUnit = config.weightUnit || 'lbs';
        const isImperialLegacy = displayLengthUnit === 'ft';
        document.getElementById('unitImperial')?.classList.toggle('active', isImperialLegacy);
        document.getElementById('unitMetric')?.classList.toggle('active', !isImperialLegacy);
        
        document.getElementById('voltage').value = config.voltage || '208';
        document.getElementById('breaker').value = config.breaker || '20';
        document.getElementById('phase').value = config.phase || '3';
        document.getElementById('maxPanelsPerCircuit').value = config.maxPanelsPerCircuit || '';
        document.getElementById('maxPanelsPerData').value = config.maxPanelsPerData || '';
        document.getElementById('dataStartDir').value = config.dataStartDir || 'top';
        showArrowsEnabled = config.showArrows !== undefined ? config.showArrows : true;
        document.getElementById('frameRate').value = config.frameRate || '60';
        document.getElementById('bitDepth').value = config.bitDepth || '8';
        redundancyEnabled = config.redundancy || false;
        cb5HalfRowEnabled = config.addCB5HalfRow || false;
        document.getElementById('canvasSize').value = config.canvasSize || '4K_UHD';
        document.getElementById('customCanvasWidth').value = config.customCanvasWidth || '';
        document.getElementById('customCanvasHeight').value = config.customCanvasHeight || '';
        document.getElementById('canvasX').value = config.canvasX || '0';
        document.getElementById('canvasY').value = config.canvasY || '0';
        snapModeEnabled = config.snapMode !== undefined ? config.snapMode : true;
        document.getElementById('arrowKeyIncrement').value = config.arrowKeyIncrement || '10';
        document.getElementById('canvasExportFormat').value = config.canvasExportFormat || 'png';
        
        // Restore deleted panels and custom assignments
        deletedPanels = new Set(config.deletedPanels || []);
        customCircuitAssignments = new Map(config.customCircuitAssignments || []);
        customDataLineAssignments = new Map(config.customDataLineAssignments || []);
        
        // Restore bumper state
        showTopBumper = config.showTopBumper || false;
        showBottomBumper = config.showBottomBumper || false;
        topBumper1wColumn = config.topBumper1wColumn !== undefined ? config.topBumper1wColumn : -1;
        bottomBumper1wColumn = config.bottomBumper1wColumn !== undefined ? config.bottomBumper1wColumn : -1;
        
        // Update bumper button states
        const topBtn = document.getElementById('topBumperBtn');
        const bottomBtn = document.getElementById('bottomBumperBtn');
        if(topBtn) topBtn.textContent = showTopBumper ? 'Top Bumper: ON' : 'Top Bumper: OFF';
        if(bottomBtn) bottomBtn.textContent = showBottomBumper ? 'Bottom Bumper: ON' : 'Bottom Bumper: OFF';
        
        // Trigger visibility updates
        const panelTypeSelect = document.getElementById('panelType');
        if(panelTypeSelect) {
          panelTypeSelect.dispatchEvent(new Event('change'));
        }
        
        const canvasSizeSelect = document.getElementById('canvasSize');
        if(canvasSizeSelect) {
          canvasSizeSelect.dispatchEvent(new Event('change'));
        }
        
        // Clear histories
        undoHistory = [];
        redoHistory = [];
        canvasMoveHistory = [];
        canvasMoveHistoryIndex = -1;
        selectedPanels.clear();
        
        // Recalculate everything
        syncFromPanels();
        updateSuggestedDataLimit();
        calculate();
        
        alert(`Configuration "${config.name}" loaded successfully! (Legacy format)`);
      }
      
      // Reset file input
      event.target.value = '';
    } catch(err) {
      alert('Error loading configuration: ' + err.message);
      console.error('Load error:', err);
    }
  };
  reader.readAsText(file);
}

document.addEventListener('DOMContentLoaded', function() {
  console.log('DOMContentLoaded fired - v55.7 Multi-Screen');
  
  // Global click handler to dismiss context menus
  document.addEventListener('click', function(e) {
    if(contextMenuVisible && !e.target.closest('#bumperContextMenu')) {
      hideContextMenu();
    }
  });
  
  try {
    const btnPDF = document.getElementById('btnExportPDF');
    const btnExp = document.getElementById('btnExportCanvas');
    
    // Auto-calculate on any input change
    const autoCalculateInputs = [
      'addCB5HalfRow',
      'panelsWide', 'panelsHigh', 'wallWidth', 'wallHeight',
      'processor', 'frameRate', 'bitDepth', 'maxPanelsPerData', 'dataStartDir',
      'voltage', 'breaker', 'phase', 'powerType', 'maxPanelsPerCircuit',
      'installationType', 'use4WayBumpers', 'bumperDistribution',
      'plate2wayWeight', 'plate4wayWeight'
    ];
    
    // Add change listeners to all inputs
    autoCalculateInputs.forEach(id => {
      const element = document.getElementById(id);
      if(element) {
        element.addEventListener('change', () => {
          calculate();
        });
        // Also listen for input events on number fields for real-time updates
        if(element.type === 'number') {
          element.addEventListener('input', () => {
            calculate();
          });
        }
      }
    });
    
    // Listen for connection method radio changes
    const connectionRadios = document.querySelectorAll('input[name="connectionMethod"]');
    connectionRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        calculate();
      });
    });
    
    // Listen for dimension mode changes
    const dimModeRadios = document.querySelectorAll('input[name="dimensionMode"]');
    dimModeRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        calculate();
      });
    });
    
    // Listen for power-related field changes to update circuit limit placeholder
    const powerRelatedFields = ['voltage', 'breaker', 'powerType'];
    powerRelatedFields.forEach(id => {
      const element = document.getElementById(id);
      if(element) {
        element.addEventListener('change', () => {
          updateSuggestedCircuitLimit();
        });
        // Also listen for input events on number fields for real-time updates
        if(element.type === 'number') {
          element.addEventListener('input', () => {
            updateSuggestedCircuitLimit();
          });
        }
      }
    });
    
    // Listen for data-related field changes to update data limit placeholder
    const dataRelatedFields = ['frameRate', 'bitDepth', 'processor'];
    dataRelatedFields.forEach(id => {
      const element = document.getElementById(id);
      if(element) {
        element.addEventListener('change', () => {
          updateSuggestedDataLimit();
        });
        // Also listen for input events on number fields for real-time updates
        if(element.type === 'number') {
          element.addEventListener('input', () => {
            updateSuggestedDataLimit();
          });
        }
      }
    });
    
    if(btnPDF) btnPDF.addEventListener('click', function(e) {
      e.preventDefault();
      // Show modal for complex and combined views, simple view exports specs only
      if(currentMobileView === 'complex' || currentMobileView === 'combined') {
        openPdfExportModal();
      } else {
        // Simple view - export specs only directly
        pdfExportOptions.specs = true;
        pdfExportOptions.gearList = false;
        pdfExportOptions.standard = false;
        pdfExportOptions.power = false;
        pdfExportOptions.data = false;
        pdfExportOptions.structure = false;
        exportPDF();
      }
    });

    if(btnExp) btnExp.addEventListener('click', function(e) {
      e.preventDefault();
      exportCanvas();
    });
    
    setupLive();
    
    const dimModePanels = document.getElementById('dimModePanels');
    const dimModeSize = document.getElementById('dimModeSize');
    
    if(dimModePanels) {
      dimModePanels.addEventListener('change', function() {
        if(this.checked) {
          document.getElementById('panelCountInputs').style.display = 'block';
          document.getElementById('wallSizeInputs').style.display = 'none';
        }
      });
    }
    
    if(dimModeSize) {
      dimModeSize.addEventListener('change', function() {
        if(this.checked) {
          document.getElementById('panelCountInputs').style.display = 'none';
          document.getElementById('wallSizeInputs').style.display = 'block';
        }
      });
    }
    
    const canvasSizeSelect = document.getElementById('canvasSize');
    if(canvasSizeSelect) {
      canvasSizeSelect.addEventListener('change', function() {
        const customInputs = document.getElementById('customCanvasInputs');
        if(this.value === 'custom') {
          customInputs.style.display = 'block';
        } else {
          customInputs.style.display = 'none';
        }
        // Update export filename placeholder
        updateExportFilenamePlaceholder();
      });
    }
    
    // Function to update export filename placeholder
    function updateExportFilenamePlaceholder() {
      const filenameInput = document.getElementById('canvasExportFilename');
      const canvasSizeSelect = document.getElementById('canvasSize');
      if(filenameInput && canvasSizeSelect) {
        let sizeLabel = canvasSizeSelect.options[canvasSizeSelect.selectedIndex].text;
        if(canvasSizeSelect.value === 'custom') {
          const customW = document.getElementById('customCanvasWidth').value || '0';
          const customH = document.getElementById('customCanvasHeight').value || '0';
          sizeLabel = `${customW}x${customH}`;
        }
        filenameInput.placeholder = `LED_Wall_Canvas_${sizeLabel.replace(/\s+/g, '_').replace(/[()]/g, '')}`;
      }
    }
    
    // Also update placeholder when custom dimensions change
    const customWidthInput = document.getElementById('customCanvasWidth');
    const customHeightInput = document.getElementById('customCanvasHeight');
    if(customWidthInput) {
      customWidthInput.addEventListener('input', updateExportFilenamePlaceholder);
    }
    if(customHeightInput) {
      customHeightInput.addEventListener('input', updateExportFilenamePlaceholder);
    }
    
    // Initial placeholder update
    updateExportFilenamePlaceholder();
    
    // Show/hide CB5 half panel toggle based on panel type
    const panelTypeSelect = document.getElementById('panelType');
    const cb5HalfPanelToggle = document.getElementById('cb5HalfPanelToggle');
    
    function updateCB5HalfPanelVisibility() {
      if(panelTypeSelect && cb5HalfPanelToggle) {
        if(panelTypeSelect.value === 'CB5_MKII') {
          cb5HalfPanelToggle.style.display = 'block';
        } else {
          cb5HalfPanelToggle.style.display = 'none';
          // Reset checkbox when hidden
          const checkbox = document.getElementById('addCB5HalfRow');
          if(checkbox) checkbox.checked = false;
        }
      }
    }
    
    if(panelTypeSelect) {
      // IMPORTANT: Check for __ADD_CUSTOM__ FIRST before other handlers
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') {
          openCustomPanelModal();
          // Reset to previous value or first option
          const options = this.querySelectorAll('option:not([value="__ADD_CUSTOM__"])');
          if(options.length > 0) {
            this.value = options[0].value;
          }
          return; // Stop propagation
        }
      });
      
      // Reset everything when panel type changes (but not during screen loading)
      panelTypeSelect.addEventListener('change', function() {
        console.log('Panel type change triggered, isLoadingScreenData:', isLoadingScreenData);
        if (!isLoadingScreenData && this.value !== '__ADD_CUSTOM__') {
          console.log('Calling resetCalculator...');
          resetCalculator();
          console.log('resetCalculator completed');
        }
      });
      
      panelTypeSelect.addEventListener('change', updateCB5HalfPanelVisibility);
      updateCB5HalfPanelVisibility(); // Initial check
      
      // Update max panels per circuit/data placeholders when panel type changes
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        console.log('Updating circuit/data limits...');
        // Update circuit limit placeholder (calculated from power settings)
        updateSuggestedCircuitLimit();
        // Update data limit placeholder (uses panel-specific limit)
        updateSuggestedDataLimit();
        console.log('Circuit/data limits updated');
      });
      
      // Also update 4-way bumper visibility
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        const fourWayOption = document.getElementById('fourWayBumperOption');
        const isCB5 = this.value === 'CB5_MKII' || this.value === 'CB5_MKII_HALF';
        if(fourWayOption) {
          fourWayOption.style.display = isCB5 && useBumpers ? 'block' : 'none';
          if(!isCB5) {
            // Reset 4-way bumpers state when switching away from CB5
            use4WayBumpersEnabled = false;
            const btn = document.getElementById('use4WayBumpersBtn');
            if(btn) btn.classList.remove('active');
          }
        }
      });
      
      // Update connecting plates section visibility
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        updateConnectingPlatesVisibility(this.value);
      });
      
      // Update bumpers on/off based on panel type
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        updateBumpersForPanelType(this.value);
      });

      // Auto-switch to Floor structure for floor panels (like BM4)
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        const allPanels = getAllPanels();
        const p = allPanels[this.value];
        if(p && p.is_floor_panel) {
          const structureSelect = document.getElementById('structureType');
          if(structureSelect) {
            structureSelect.value = 'floor';
            // Trigger change event to update UI
            structureSelect.dispatchEvent(new Event('change'));
          }
        }
      });

      // Initial update for connecting plates
      updateConnectingPlatesVisibility(panelTypeSelect.value);
      
      // Initial update for bumpers based on panel type
      updateBumpersForPanelType(panelTypeSelect.value);
    }
    
    // Connection method radio buttons listener (reusing existing connectionRadios)
    // Already declared above, so we can just add another listener to the same elements
    document.querySelectorAll('input[name="connectionMethod"]').forEach(radio => {
      radio.addEventListener('change', function() {
        // Connection method changed - just recalculate
        calculate();
      });
    });
    
    // Bumper distribution mode toggle
    const bumperDistSelect = document.getElementById('bumperDistribution');
    if(bumperDistSelect) {
      bumperDistSelect.addEventListener('change', function() {
        const autoControls = document.getElementById('autoBumperControls');
        const manualControls = document.getElementById('manualBumperControls');
        
        if(this.value === 'auto') {
          if(autoControls) autoControls.style.display = 'block';
          if(manualControls) manualControls.style.display = 'none';
        } else {
          if(autoControls) autoControls.style.display = 'none';
          if(manualControls) manualControls.style.display = 'block';
        }
      });
    }
    
    // Structure type change - automatically set bumpers based on hanging/ground
    const structureTypeSelect = document.getElementById('structureType');
    if(structureTypeSelect) {
      structureTypeSelect.addEventListener('change', function() {
        updateBumpersBasedOnStructureType();
        // Recalculate to update weight breakdown in specs (panels vs structure)
        calculate();
      });
      // Initialize on load
      updateBumpersBasedOnStructureType();
    }
    
    // Listen to panel dimension changes to update weight display, reinitialize bumpers, and apply aspect ratio
    const panelsWideInput = document.getElementById('panelsWide');
    const panelsHighInput = document.getElementById('panelsHigh');
    const wallWidthInput = document.getElementById('wallWidth');
    const wallHeightInput = document.getElementById('wallHeight');

    if(panelsWideInput) {
      panelsWideInput.addEventListener('input', function() {
        applyAspectRatioFromWidth(); // Apply aspect ratio lock
        initializeBumpers(); // Reinitialize when width changes
        updateWeightDisplay();
      });
    }
    if(panelsHighInput) {
      panelsHighInput.addEventListener('input', function() {
        // No aspect ratio from height - only width triggers auto-calculation
        initializeBumpers(); // Reinitialize when height changes
        updateWeightDisplay();
      });
    }
    if(wallWidthInput) {
      wallWidthInput.addEventListener('input', function() {
        applyAspectRatioFromWidth(); // Apply aspect ratio lock
      });
    }
    if(wallHeightInput) {
      wallHeightInput.addEventListener('input', function() {
        // No aspect ratio from height - only width triggers auto-calculation
      });
    }

    // Listen to custom aspect ratio input changes
    const customARWidthInput = document.getElementById('customARWidth');
    const customARHeightInput = document.getElementById('customARHeight');
    if(customARWidthInput) {
      customARWidthInput.addEventListener('input', function() {
        if(currentAspectRatio === 'custom') {
          applyAspectRatioFromWidth(); // Re-apply with new ratio
          calculate();
        }
      });
    }
    if(customARHeightInput) {
      customARHeightInput.addEventListener('input', function() {
        if(currentAspectRatio === 'custom') {
          applyAspectRatioFromWidth(); // Re-apply with new ratio
          calculate();
        }
      });
    }
    
    // Cabling input listeners - save current screen data then update gear list
    const cablingInputIds = ['wallToFloor', 'distroToWall', 'processorToWall', 'serverToProcessor', 'cablePick'];
    cablingInputIds.forEach(id => {
      const el = document.getElementById(id);
      if(el) {
        el.addEventListener('input', function() {
          saveCurrentScreenData();
          generateGearList();
        });
      }
    });
    syncFromPanels();
    updateSuggestedDataLimit();
    showSpecWarningIfNeeded();
    updateUndoRedoButtons(); // Initialize button states

    // Initialize custom panels and processors dropdowns
    updatePanelDropdowns();
    updateProcessorDropdowns();
    
    // Add event listener for processor dropdown
    const processorSelect = document.getElementById('processor');
    if(processorSelect) {
      processorSelect.addEventListener('change', function() {
        // Show/hide MX40 mode toggle for MX40 Pro
        updateMX40ModeToggleVisibility();
      });
      // Initial check on page load
      updateMX40ModeToggleVisibility();
    }

// Show/hide MX40 mode toggle based on processor selection
function updateMX40ModeToggleVisibility() {
  const processorSelect = document.getElementById('processor');
  const mx40ModeToggleRow = document.getElementById('mx40ModeToggleRow');
  if(processorSelect && mx40ModeToggleRow) {
    const isMX40Pro = processorSelect.value === 'NovaStar_MX40_Pro';
    mx40ModeToggleRow.style.display = isMX40Pro ? 'block' : 'none';
  }
}
    
    // Add keyboard listeners for panel selection
    document.addEventListener('keydown', function(e) {
      // Check if we're focused on an input field
      const activeElement = document.activeElement;
      const isInputFocused = activeElement && (
        activeElement.tagName === 'INPUT' || 
        activeElement.tagName === 'TEXTAREA' || 
        activeElement.tagName === 'SELECT'
      );
      
      if(e.key === 'Delete' || e.key === 'Backspace') {
        // Only delete panels if NOT focused on an input field
        if(selectedPanels.size > 0 && !isInputFocused) {
          e.preventDefault();
          deleteSelectedPanels();
        }
      }
      
      // Escape to clear selection
      if(e.key === 'Escape') {
        selectedPanels.clear();
        if(currentCanvas) generateLayout('standard');
      }
      
      // Ctrl+Z for Undo
      if((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      
      // Ctrl+Y for Redo (also Ctrl+Shift+Z as alternative)
      if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
      }
    });
    
    // Clear selection when clicking outside canvas views
    document.addEventListener('click', function(e) {
      // Only process if we have selected panels
      if(selectedPanels.size === 0) return;
      
      // Check if click target IS a canvas element
      const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasView'];
      const clickedCanvas = canvases.some(id => {
        const canvas = document.getElementById(id);
        return canvas && e.target === canvas;
      });
      
      // If not clicking directly on a canvas, clear selection and redraw
      if(!clickedCanvas) {
        selectedPanels.clear();
        // Redraw the current layout if it exists
        const standardCanvas = document.getElementById('standardCanvas');
        if(standardCanvas && standardCanvas.width > 0) {
          generateLayout('standard');
        }
      }
    });
    
    // Initialize canvas undo/redo button states
    updateCanvasUndoRedoButtons();
    
    // Perform initial calculation on page load
    setTimeout(() => {
      calculate();
    }, 100);
    
    // Initialize v29 multi-screen system
    initializeScreenSystem();
    
    // Load the initial screen (screen_1) data into the UI
    loadScreenData('screen_1');
    
    // Set initial placeholders based on the actual default panel type
    updateSuggestedCircuitLimit();
    updateSuggestedDataLimit();
    
    // Update canvas view to ensure correct positioning
    setTimeout(() => {
      showCanvasView();
    }, 150);
    
    // Initialize canvas wheel zoom
    initCanvasWheelZoom();
    initCanvasPanning();
    initCanvasTouchPanZoom();

    console.log('Initialization complete - v55.6 Multi-Screen');
  } catch(err) {
    console.error('Initialization error:', err);
    alert('Error initializing calculator: ' + err.message);
  }
});



// ==================== V29 MULTI-SCREEN SYSTEM (ENHANCED) ====================

// Screen management
let screens = {};
let currentScreenId = 'screen_1';
let screenIdCounter = 1;
let isLoadingScreenData = false; // Flag to prevent resetCalculator during screen loading

// Screen colors (50% brightness)
// Screen 1 = gray, Screen 2 = red/gray, Screen 3 = green/gray, Screen 4 = blue/gray, Screen 5 = yellow/gray
// Screen 6 = cyan/gray, Screen 7 = magenta/gray, Screen 8 = orange/gray, Screen 9 = aqua/gray, Screen 10 = purple/gray
// Screen colors (primary color for each screen)
// Screen 1 uses standard layout colors (magenta/cyan), screens 2-10 alternate with gray
const screenColors = [
  '#800080', // Screen 1 - Magenta (50% brightness)
  '#804040', // Screen 2 - Red/Gray
  '#408040', // Screen 3 - Green/Gray
  '#404080', // Screen 4 - Blue/Gray
  '#808040', // Screen 5 - Yellow/Gray
  '#408080', // Screen 6 - Cyan/Gray
  '#804080', // Screen 7 - Magenta/Gray
  '#C06030', // Screen 8 - Orange/Gray (slightly brighter for visibility)
  '#40A0A0', // Screen 9 - Aqua/Gray (brighter cyan variant)
  '#604080'  // Screen 10 - Purple/Gray
];

// Secondary colors for alternating pattern (paired with screenColors)
const screenColors2 = [
  '#008080', // Screen 1 - Cyan (50% brightness)
  '#808080', // Screen 2 - Gray
  '#808080', // Screen 3 - Gray
  '#808080', // Screen 4 - Gray
  '#808080', // Screen 5 - Gray
  '#808080', // Screen 6 - Gray
  '#808080', // Screen 7 - Gray
  '#808080', // Screen 8 - Gray
  '#808080', // Screen 9 - Gray
  '#808080'  // Screen 10 - Gray
];

// Helper function to darken a hex color
function darkenColor(hex, percent) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = Math.max(0, (num >> 16) - Math.round(255 * percent / 100));
  const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.round(255 * percent / 100));
  const b = Math.max(0, (num & 0x0000FF) - Math.round(255 * percent / 100));
  return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
}

// Convert a color to a pastel/lighter version for eco-friendly printing
// Increases lightness to 85% while keeping hue and reducing saturation
function toPastelColor(hex) {
  const num = parseInt(hex.replace('#', ''), 16);
  let r = (num >> 16) & 255;
  let g = (num >> 8) & 255;
  let b = num & 255;

  // Convert to HSL
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
    }
  }

  // Make pastel: moderate lightness (70%), moderate saturation (50%) for better differentiation
  l = 0.70;
  s = s * 0.5;

  // Convert back to RGB
  let r2, g2, b2;
  if (s === 0) {
    r2 = g2 = b2 = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r2 = hue2rgb(p, q, h + 1/3);
    g2 = hue2rgb(p, q, h);
    b2 = hue2rgb(p, q, h - 1/3);
  }

  return '#' + [r2, g2, b2].map(x => Math.round(x * 255).toString(16).padStart(2, '0')).join('');
}

// Convert a color to greyscale for print-friendly output
function toGreyscale(hex) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = (num >> 16) & 255;
  const g = (num >> 8) & 255;
  const b = num & 255;

  // Use luminance formula for perceptually accurate greyscale
  let grey = Math.round(0.299 * r + 0.587 * g + 0.114 * b);

  // Lighten by blending with white (70% grey, 30% white)
  grey = Math.round(grey * 0.7 + 255 * 0.3);
  grey = Math.min(255, grey); // Cap at 255

  return '#' + grey.toString(16).padStart(2, '0').repeat(3);
}

function getDefaultScreenData() {
  return {
    // Dimensions
    panelsWide: 0,
    panelsHigh: 0,
    wallWidth: '',
    wallHeight: '',
    units: 'ft',
    dimensionMode: 'panels',
    
    // Panel Type
    panelType: 'BP2_V2',
    addCB5HalfRow: false,
    connectionMethod: 'airframes', // 'airframes' or 'plates'
    
    // Optional display name (separate from tab name)
    screenDisplayName: '',
    
    // Power
    voltage: 208,
    breaker: 20,
    phase: '3',
    derate: false,
    powerType: 'max',
    maxPanelsPerCircuit: '',
    
    // Data
    processor: 'Brompton_SX40',
    frameRate: 60,
    bitDepth: 8,
    maxPanelsPerData: '',
    dataStartDir: 'top',
    showArrows: true,
    redundancy: true,
    processorRedundancy: false,
    
    // Structure
    structureType: 'hanging',
    useBumpers: true,
    use4WayBumpers: false,
    
    // Cabling
    wallToFloor: 5,
    distroToWall: 10,
    processorToWall: 15,
    serverToProcessor: 50,
    cablePick: 0,
    cableDropPosition: 'behind',
    distBoxOnWall: false,
    
    // Canvas
    canvasX: 0,
    canvasY: 0,
    canvasSize: '4K_UHD',
    customCanvasWidth: '',
    customCanvasHeight: '',
    snapMode: false,
    
    // Per-screen state (previously global)
    bumpers: [],
    nextBumperId: 1,
    deletedPanels: new Set(),
    selectedPanels: new Set(),
    customCircuitAssignments: new Map(),
    customDataLineAssignments: new Map(),
    undoHistory: [],
    redoHistory: []
  };
}

function initializeScreenSystem() {
  screens['screen_1'] = {
    id: 'screen_1',
    name: 'Screen 1',
    color: screenColors[0],
    color2: screenColors2[0],
    visible: true,
    data: getDefaultScreenData()
  };

  renderScreenTabs();
  updateCanvasScreenToggles();
  initializeCanvases();
}

function renderScreenTabs() {
  const container = document.getElementById('screenTabsContainer');
  if(!container) return;
  
  // Sort screen IDs numerically (screen_1, screen_2, ..., screen_10, screen_11)
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });

  let html = '';
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    const isActive = screenId === currentScreenId;
    html += `
      <div class="screen-tab ${isActive ? 'active' : ''}"
           onclick="switchToScreen('${screenId}')">
        <span class="screen-tab-name">${screen.name}</span>
        <button class="screen-tab-edit" onclick="event.stopPropagation(); openScreenRenameModal('${screenId}')" title="Edit screen">✎</button>
        ${screenIds.length > 1 ? `<button class="screen-tab-close" onclick="event.stopPropagation(); deleteScreen('${screenId}')" title="Delete screen">×</button>` : ''}
      </div>
    `;
  });

  // Render tabs into the screen-tabs wrapper, keep the static + button outside
  let tabsWrapper = container.querySelector('.screen-tabs');
  if(!tabsWrapper) {
    tabsWrapper = document.createElement('div');
    tabsWrapper.className = 'screen-tabs';
    container.insertBefore(tabsWrapper, container.firstChild);
  }
  tabsWrapper.innerHTML = html;
}

function switchToScreen(screenId) {
  console.log('=== SWITCHING TO SCREEN ===');
  console.log('Target screen ID:', screenId);
  console.log('Current screen ID before switch:', currentScreenId);
  
  if(!screens[screenId]) {
    console.error('Screen not found:', screenId);
    return;
  }
  
  // Save current screen data
  console.log('Saving current screen data...');
  saveCurrentScreenData();
  
  // Switch to new screen
  currentScreenId = screenId;
  console.log('Current screen ID after switch:', currentScreenId);
  
  // Reset canvas viewport pan and zoom for fresh view of new screen
  canvasZoomLevel = 1.0;
  canvasPanX = 0;
  canvasPanY = 0;
  updateCanvasViewport();
  
  // Load new screen data
  console.log('Loading new screen data...');
  loadScreenData(screenId);
  
  // Update UI
  console.log('Rendering screen tabs...');
  renderScreenTabs();
  
  // Recalculate for new screen
  console.log('Calling calculate()...');
  calculate();
  console.log('=== SCREEN SWITCH COMPLETE ===');
}

function saveCurrentScreenData() {
  const screen = screens[currentScreenId];
  if(!screen) return;
  
  const data = screen.data;
  
  // Dimensions
  data.panelsWide = parseInt(document.getElementById('panelsWide').value) || 0;
  data.panelsHigh = parseInt(document.getElementById('panelsHigh').value) || 0;
  data.wallWidth = document.getElementById('wallWidth').value;
  data.wallHeight = document.getElementById('wallHeight').value;
  data.lengthUnit = displayLengthUnit;
  data.weightUnit = displayWeightUnit;
  data.dimensionMode = document.querySelector('input[name="dimensionMode"]:checked')?.value || 'panels';
  
  // Panel Type
  data.panelType = document.getElementById('panelType').value;
  
  // Power
  data.voltage = parseInt(document.getElementById('voltage').value) || 208;
  data.breaker = parseInt(document.getElementById('breaker').value) || 20;
  data.phase = document.getElementById('phase').value;
  data.powerType = document.getElementById('powerType').value;
  data.maxPanelsPerCircuit = document.getElementById('maxPanelsPerCircuit').value;
  
  // Data
  data.processor = document.getElementById('processor').value;
  data.frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  data.bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  data.maxPanelsPerData = document.getElementById('maxPanelsPerData').value;
  data.dataStartDir = document.getElementById('dataStartDir').value;
  data.showArrows = showArrowsEnabled;
  data.redundancy = redundancyEnabled;
  data.processorRedundancy = processorRedundancyEnabled;
  data.mx40ConnectionMode = mx40ConnectionMode;

  // Structure
  data.structureType = document.getElementById('structureType').value;
  data.useBumpers = useBumpers; // Save bumper toggle state
  data.use4WayBumpers = use4WayBumpersEnabled; // Save 4-way bumpers state
  
  // CB5-specific options - use the global toggle state
  data.addCB5HalfRow = cb5HalfRowEnabled;
  
  const connectionMethod = document.querySelector('input[name="connectionMethod"]:checked');
  if(connectionMethod) data.connectionMethod = connectionMethod.value;
  
  // Cabling - use value if present, otherwise fall back to placeholder default
  const wallToFloorEl = document.getElementById('wallToFloor');
  const distroToWallEl = document.getElementById('distroToWall');
  const processorToWallEl = document.getElementById('processorToWall');
  const serverToProcessorEl = document.getElementById('serverToProcessor');
  const cablePickEl = document.getElementById('cablePick');

  if(wallToFloorEl) data.wallToFloor = wallToFloorEl.value !== '' ? parseFloat(wallToFloorEl.value) : parseFloat(wallToFloorEl.placeholder);
  if(distroToWallEl) data.distroToWall = distroToWallEl.value !== '' ? parseFloat(distroToWallEl.value) : parseFloat(distroToWallEl.placeholder);
  if(processorToWallEl) data.processorToWall = processorToWallEl.value !== '' ? parseFloat(processorToWallEl.value) : parseFloat(processorToWallEl.placeholder);
  if(serverToProcessorEl) data.serverToProcessor = serverToProcessorEl.value !== '' ? parseFloat(serverToProcessorEl.value) : parseFloat(serverToProcessorEl.placeholder);
  if(cablePickEl) data.cablePick = cablePickEl.value !== '' ? parseFloat(cablePickEl.value) : 0;
  data.cableDropPosition = cableDropPosition;
  data.distBoxOnWall = distBoxOnWallEnabled;
  
  // Canvas
  console.log(`Saving screen data for ${currentScreenId}: canvasOffsetX=${canvasOffsetX}, canvasOffsetY=${canvasOffsetY}`);
  data.canvasX = canvasOffsetX;
  data.canvasY = canvasOffsetY;
  console.log(`After save: data.canvasX=${data.canvasX}, data.canvasY=${data.canvasY}`);
  data.canvasSize = document.getElementById('canvasSize').value;
  data.customCanvasWidth = document.getElementById('customCanvasWidth').value;
  data.customCanvasHeight = document.getElementById('customCanvasHeight').value;
  const snapMode = document.getElementById('snapMode');
  if(snapMode) data.snapMode = snapMode.checked;
  
  // Per-screen state - save current global state to screen data
  data.bumpers = JSON.parse(JSON.stringify(bumpers)); // Deep copy array
  data.nextBumperId = nextBumperId;
  data.bumpersInitialized = true; // Mark that bumpers have been saved (even if empty from deletions)
  data.deletedPanels = new Set(deletedPanels); // Copy Set
  data.selectedPanels = new Set(selectedPanels); // Copy Set
  data.customCircuitAssignments = new Map(customCircuitAssignments); // Copy Map
  data.customDataLineAssignments = new Map(customDataLineAssignments); // Copy Map
  
  // Deep copy undo/redo history
  data.undoHistory = undoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  }));
  data.redoHistory = redoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  }));
}

function loadScreenData(screenId) {
  const screen = screens[screenId];
  if(!screen) return;
  
  // Set flag to prevent resetCalculator from running during load
  isLoadingScreenData = true;
  
  const data = screen.data;
  
  console.log(`Loading screen data for ${screenId}, canvasX: ${data.canvasX}, canvasY: ${data.canvasY}`);
  
  // Dimensions
  document.getElementById('panelsWide').value = data.panelsWide || '';
  document.getElementById('panelsHigh').value = data.panelsHigh || '';
  document.getElementById('wallWidth').value = data.wallWidth || '';
  document.getElementById('wallHeight').value = data.wallHeight || '';
  
  // Restore unit settings if saved with screen
  if(data.lengthUnit) {
    displayLengthUnit = data.lengthUnit;
  }
  if(data.weightUnit) {
    displayWeightUnit = data.weightUnit;
  }
  // Update unit buttons
  const isImperialScreen = displayLengthUnit === 'ft';
  document.getElementById('unitImperial')?.classList.toggle('active', isImperialScreen);
  document.getElementById('unitMetric')?.classList.toggle('active', !isImperialScreen);
  
  // Set dimension mode
  const modeRadio = document.querySelector(`input[name="dimensionMode"][value="${data.dimensionMode}"]`);
  if(modeRadio) modeRadio.checked = true;
  
  // Show/hide appropriate inputs
  document.getElementById('panelCountInputs').style.display = data.dimensionMode === 'panels' ? 'block' : 'none';
  document.getElementById('wallSizeInputs').style.display = data.dimensionMode === 'size' ? 'block' : 'none';
  
  // Panel Type
  document.getElementById('panelType').value = data.panelType || 'BP2_V2';
  
  // Power
  document.getElementById('voltage').value = data.voltage || 208;
  document.getElementById('breaker').value = data.breaker || 20;
  document.getElementById('phase').value = data.phase || '3';
  document.getElementById('powerType').value = data.powerType || 'max';
  document.getElementById('maxPanelsPerCircuit').value = data.maxPanelsPerCircuit || '';
  
  // Data
  document.getElementById('processor').value = data.processor || 'Brompton_SX40';
  document.getElementById('frameRate').value = data.frameRate || 60;
  document.getElementById('bitDepth').value = data.bitDepth || 8;
  document.getElementById('maxPanelsPerData').value = data.maxPanelsPerData || '';
  document.getElementById('dataStartDir').value = data.dataStartDir || 'top';
  showArrowsEnabled = data.showArrows !== false;
  redundancyEnabled = data.redundancy !== false; // Default to true if undefined
  processorRedundancyEnabled = data.processorRedundancy || false;
  
  // Update redundancy button visual state
  const redundancyBtn = document.getElementById('redundancyBtn');
  if(redundancyBtn) {
    redundancyBtn.classList.toggle('active', redundancyEnabled);
  }
  
  // Update processor redundancy button visual state
  const processorRedundancyBtn = document.getElementById('processorRedundancyBtn');
  if(processorRedundancyBtn) {
    processorRedundancyBtn.classList.toggle('active', processorRedundancyEnabled);
  }

  // Restore MX40 connection mode toggle state
  mx40ConnectionMode = data.mx40ConnectionMode || 'direct';
  const mx40DirectBtn = document.getElementById('mx40DirectBtn');
  const mx40IndirectBtn = document.getElementById('mx40IndirectBtn');
  if(mx40DirectBtn && mx40IndirectBtn) {
    mx40DirectBtn.classList.toggle('active', mx40ConnectionMode === 'direct');
    mx40IndirectBtn.classList.toggle('active', mx40ConnectionMode === 'indirect');
  }

  // Update show arrows button visual state
  const showArrowsBtn = document.getElementById('showArrowsBtn');
  if(showArrowsBtn) {
    showArrowsBtn.classList.toggle('active', showArrowsEnabled);
  }
  
  // Structure
  document.getElementById('structureType').value = data.structureType || 'hanging';
  
  // Restore bumpers toggle state
  // Check if useBumpers is explicitly set in data, otherwise check panel default
  if(data.useBumpers !== undefined) {
    useBumpers = data.useBumpers;
  } else {
    // Check if panel type has bumpers disabled by default
    const allPanels = getAllPanels();
    const panel = allPanels[data.panelType];
    useBumpers = !(panel && panel.uses_bumpers === false);
  }
  document.getElementById('useBumpersBtn').classList.toggle('active', useBumpers);
  
  // Show/hide bumper controls based on state
  const bumperControls = document.getElementById('bumperControls');
  const fourWayOption = document.getElementById('fourWayBumperOption');
  if(bumperControls) bumperControls.style.display = useBumpers ? '' : 'none';
  if(!useBumpers && fourWayOption) fourWayOption.style.display = 'none';
  
  // Restore 4-way bumpers state
  use4WayBumpersEnabled = data.use4WayBumpers || false;
  const use4WayBtn = document.getElementById('use4WayBumpersBtn');
  if(use4WayBtn) use4WayBtn.classList.toggle('active', use4WayBumpersEnabled);
  
  // Cabling
  const wallToFloorEl = document.getElementById('wallToFloor');
  const distroToWallEl = document.getElementById('distroToWall');
  const processorToWallEl = document.getElementById('processorToWall');
  const serverToProcessorEl = document.getElementById('serverToProcessor');
  const cablePickEl = document.getElementById('cablePick');

  // Set value only if non-default, otherwise leave empty to show placeholder
  if(wallToFloorEl) wallToFloorEl.value = (data.wallToFloor && data.wallToFloor !== 5) ? data.wallToFloor : '';
  if(distroToWallEl) distroToWallEl.value = (data.distroToWall && data.distroToWall !== 10) ? data.distroToWall : '';
  if(processorToWallEl) processorToWallEl.value = (data.processorToWall && data.processorToWall !== 15) ? data.processorToWall : '';
  const serverVal = data.serverToProcessor ?? data.fohToProcessor;
  if(serverToProcessorEl) serverToProcessorEl.value = (serverVal && serverVal !== 50) ? serverVal : '';
  if(cablePickEl) cablePickEl.value = (data.cablePick && data.cablePick !== 0) ? data.cablePick : '';

  // Restore cable drop toggle buttons
  cableDropPosition = data.cableDropPosition || 'behind';
  document.getElementById('cableDropBehindBtn')?.classList.toggle('active', cableDropPosition === 'behind');
  document.getElementById('cableDropSRBtn')?.classList.toggle('active', cableDropPosition === 'sr');
  document.getElementById('cableDropSLBtn')?.classList.toggle('active', cableDropPosition === 'sl');

  distBoxOnWallEnabled = data.distBoxOnWall || false;
  document.getElementById('distBoxOnWallBtn')?.classList.toggle('active', distBoxOnWallEnabled);
  
  // Canvas - FORCE to proper values
  const loadedX = (typeof data.canvasX === 'number') ? data.canvasX : 0;
  const loadedY = (typeof data.canvasY === 'number') ? data.canvasY : 0;
  
  // Set global variables
  canvasOffsetX = loadedX;
  canvasOffsetY = loadedY;
  
  // Update input fields
  document.getElementById('canvasX').value = loadedX;
  document.getElementById('canvasY').value = loadedY;
  
  // ALSO update the screen data to ensure it's correct
  data.canvasX = loadedX;
  data.canvasY = loadedY;
  
  console.log(`After loading: global canvasOffsetX=${canvasOffsetX}, canvasOffsetY=${canvasOffsetY}`);
  console.log(`After loading: data.canvasX=${data.canvasX}, data.canvasY=${data.canvasY}`);
  
  document.getElementById('canvasSize').value = data.canvasSize || '4K_UHD';
  document.getElementById('customCanvasWidth').value = data.customCanvasWidth || '';
  document.getElementById('customCanvasHeight').value = data.customCanvasHeight || '';
  const snapMode = document.getElementById('snapMode');
  if(snapMode) snapMode.checked = data.snapMode || false;
  
  // Trigger panel type change to update 4-way bumper visibility
  const panelType = data.panelType || 'CB5_MKII';
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  if(fourWayOption) {
    fourWayOption.style.display = isCB5 && useBumpers ? 'block' : 'none';
  }
  
  // Update placeholders to show panel-specific defaults
  // Circuit limit is calculated dynamically based on power settings
  // Data limit uses panel-specific maximum
  const allPanels = getAllPanels();
  const p = allPanels[panelType];
  if(p) {
    // Update max panels per data placeholder (panel-specific)
    const dataInput = document.getElementById('maxPanelsPerData');
    if(dataInput && p.max_panels_per_data) {
      dataInput.placeholder = p.max_panels_per_data.toString();
    }
  }
  // Update circuit limit after a short delay to ensure power settings are loaded
  setTimeout(() => {
    updateSuggestedCircuitLimit();
  }, 0);
  
  // Per-screen state - restore from screen data to global variables
  bumpers = data.bumpers ? JSON.parse(JSON.stringify(data.bumpers)) : [];
  nextBumperId = data.nextBumperId || 1;
  deletedPanels = data.deletedPanels ? new Set(data.deletedPanels) : new Set();
  selectedPanels = data.selectedPanels ? new Set(data.selectedPanels) : new Set();
  customCircuitAssignments = data.customCircuitAssignments ? new Map(data.customCircuitAssignments) : new Map();
  customDataLineAssignments = data.customDataLineAssignments ? new Map(data.customDataLineAssignments) : new Map();
  
  // Restore undo/redo history
  undoHistory = data.undoHistory ? data.undoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  })) : [];
  redoHistory = data.redoHistory ? data.redoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  })) : [];
  
  // Update undo/redo button states
  updateUndoRedoButtons();
  
  // Clear all canvases when switching screens
  const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
  canvases.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  });
  
  // Clear results display
  const resultsEl = document.getElementById('results');
  if(resultsEl) resultsEl.innerText = '';
  
  // Update CB5 half panel toggle visibility (panelType and isCB5 already declared above)
  const cb5HalfPanelToggle = document.getElementById('cb5HalfPanelToggle');
  if(cb5HalfPanelToggle) {
    cb5HalfPanelToggle.style.display = (panelType === 'CB5_MKII') ? 'block' : 'none';
  }
  
  // Update connecting plates visibility
  updateConnectingPlatesVisibility(panelType);
  
  // Restore addCB5HalfRow checkbox state if saved
  const addCB5HalfRow = document.getElementById('addCB5HalfRow');
  if(addCB5HalfRow) {
    addCB5HalfRow.checked = data.addCB5HalfRow || false;
  }
  
  // Restore connection method if saved
  if(data.connectionMethod) {
    const connectionRadio = document.querySelector(`input[name="connectionMethod"][value="${data.connectionMethod}"]`);
    if(connectionRadio) connectionRadio.checked = true;
  }
  
  // Reset bumper globals based on structure type - this ensures structure view shows correct bumpers
  const structureType = data.structureType || 'hanging';
  if(structureType === 'hanging') {
    showTopBumper = true;
    showBottomBumper = false;
  } else { // ground
    showTopBumper = false;
    showBottomBumper = true;
  }
  
  // Only initialize bumpers if they haven't been customized/saved yet for this screen
  // If bumpersInitialized is true, the bumpers array (even if empty) reflects user's choices
  if(!data.bumpersInitialized && (showTopBumper || showBottomBumper) && data.panelsWide > 0) {
    initializeBumpers();
  }
  
  // Clear flag after all data is loaded
  isLoadingScreenData = false;
}

// Generate a distinct color for screens beyond the predefined 10
function generateCustomScreenColor(screenNumber) {
  // Use HSL color space for better color distribution
  // Start after the 10 predefined colors, cycle through hues
  const baseHue = ((screenNumber - 11) * 137) % 360; // Golden angle for good distribution
  const saturation = 40; // 40% saturation for muted colors
  const lightness = 50;  // 50% lightness
  
  return `hsl(${baseHue}, ${saturation}%, ${lightness}%)`;
}

function addNewScreen() {
  console.log('=== ADDING NEW SCREEN ===');
  
  // Save current screen data first (including any name changes)
  console.log('Saving current screen before adding new screen...');
  saveCurrentScreenData();
  
  screenIdCounter++;
  const newScreenId = `screen_${screenIdCounter}`;
  const screenNumber = Object.keys(screens).length + 1;
  
  // Use predefined colors for first 10 screens, generate custom colors for the rest
  let color, color2;
  if(screenNumber <= screenColors.length) {
    color = screenColors[screenNumber - 1];
    color2 = screenColors2[screenNumber - 1];
  } else {
    color = generateCustomScreenColor(screenNumber);
    color2 = darkenColor(color, 30);
  }
  
  console.log('New screen ID:', newScreenId);
  console.log('Screen number:', screenNumber);
  console.log('Screen color:', color);
  
  screens[newScreenId] = {
    id: newScreenId,
    name: `Screen ${screenNumber}`,
    color: color,
    color2: color2,
    visible: true,
    data: getDefaultScreenData()
  };

  console.log('New screen created:', screens[newScreenId]);
  console.log('All screens:', Object.keys(screens));

  // Add new screen to all canvases' visibility tracking
  // Visible only in current canvas, hidden in others
  Object.keys(canvases).forEach(canvasId => {
    if(!canvases[canvasId].data.screenVisibility) {
      canvases[canvasId].data.screenVisibility = {};
    }
    canvases[canvasId].data.screenVisibility[newScreenId] = (canvasId === currentCanvasId);
  });

  renderScreenTabs();
  updateCanvasScreenToggles();

  // Switch to the new screen
  console.log('Switching to new screen...');
  switchToScreen(newScreenId);

  // If we're on the canvas page, make sure canvas stays visible
  if(currentMobileView === 'canvas') {
    const canvasContainer = document.getElementById('canvasContainer');
    const canvasTabsEl = document.getElementById('canvasTabsContainer');
    if(canvasTabsEl) canvasTabsEl.style.display = 'flex';
    if(canvasContainer) canvasContainer.style.display = 'block';
    if(typeof showCanvasView === 'function') {
      showCanvasView();
    }
  }
}

function deleteScreen(screenId) {
  if(Object.keys(screens).length === 1) {
    alert('Cannot delete the last screen');
    return;
  }

  delete screens[screenId];

  // Remove screen from all canvases' visibility tracking
  Object.keys(canvases).forEach(canvasId => {
    if(canvases[canvasId].data.screenVisibility) {
      delete canvases[canvasId].data.screenVisibility[screenId];
    }
  });

  // Clear canvas selection if the deleted screen was selected
  if(selectedCanvasScreenId === screenId) {
    selectedCanvasScreenId = null;
  }

  if(currentScreenId === screenId) {
    currentScreenId = Object.keys(screens)[0];
    loadScreenData(currentScreenId);
  }

  renderScreenTabs();
  updateCanvasScreenToggles();
  calculate();

  // Explicitly redraw canvas to remove deleted screen
  showCanvasView();
}

let screenToRename = null;

function openScreenRenameModal(screenId) {
  screenToRename = screenId;
  const screen = screens[screenId];
  document.getElementById('screenRenameInput').value = screen.name;
  
  // Set primary color picker value
  const colorInput = document.getElementById('screenColorInput');
  const colorPreview = document.getElementById('screenColorPreview');
  colorInput.value = screen.color;
  colorPreview.textContent = screen.color;
  colorPreview.style.background = screen.color;
  
  // Set secondary color picker value
  const color2Input = document.getElementById('screenColor2Input');
  const color2Preview = document.getElementById('screenColor2Preview');
  const color2Value = screen.color2 || darkenColor(screen.color, 30);
  color2Input.value = color2Value;
  color2Preview.textContent = color2Value;
  color2Preview.style.background = color2Value;
  
  // Update preview when primary color changes
  colorInput.oninput = function() {
    colorPreview.textContent = this.value;
    colorPreview.style.background = this.value;
  };
  
  // Update preview when secondary color changes
  color2Input.oninput = function() {
    color2Preview.textContent = this.value;
    color2Preview.style.background = this.value;
  };
  
  document.getElementById('screenRenameModal').classList.add('active');
}

function closeScreenRenameModal() {
  document.getElementById('screenRenameModal').classList.remove('active');
  screenToRename = null;
}

function saveScreenRename() {
  const newName = document.getElementById('screenRenameInput').value.trim();
  if(!newName) {
    alert('Please enter a screen name');
    return;
  }
  
  if(screenToRename && screens[screenToRename]) {
    screens[screenToRename].name = newName;
    screens[screenToRename].color = document.getElementById('screenColorInput').value;
    screens[screenToRename].color2 = document.getElementById('screenColor2Input').value;
    renderScreenTabs();
    updateCanvasScreenToggles();
    // Update all views to show the new name/color
    generateLayout('standard');
    generateStructureLayout();
    generateLayout('power');
    generateLayout('data');
    showCanvasView();
  }
  
  closeScreenRenameModal();
}

function duplicateScreen() {
  if(!screenToRename || !screens[screenToRename]) {
    alert('No screen selected to duplicate');
    return;
  }

  const sourceScreen = screens[screenToRename];

  // Generate new screen ID
  screenIdCounter++;
  const newScreenId = `screen_${screenIdCounter}`;
  const screenNumber = Object.keys(screens).length + 1;

  // Deep clone the screen data
  const newScreen = {
    id: newScreenId,
    name: sourceScreen.name + ' (Copy)',
    color: sourceScreen.color,
    color2: sourceScreen.color2,
    visible: true,
    data: JSON.parse(JSON.stringify(sourceScreen.data))
  };

  screens[newScreenId] = newScreen;

  // Add new screen to all canvases' visibility tracking
  Object.keys(canvases).forEach(canvasId => {
    if(!canvases[canvasId].data.screenVisibility) {
      canvases[canvasId].data.screenVisibility = {};
    }
    canvases[canvasId].data.screenVisibility[newScreenId] = (canvasId === currentCanvasId);
  });

  renderScreenTabs();
  updateCanvasScreenToggles();

  closeScreenRenameModal();

  // Switch to the new screen
  switchToScreen(newScreenId);
}

function updateCanvasScreenToggles() {
  const container = document.getElementById('canvasScreenToggles');
  if(!container) return;

  let html = '<div style="margin-top: 16px; margin-bottom: 12px; display: inline-block; background: #222; border: 1px solid var(--primary); padding: 4px 10px; font-family: Bangers, cursive; font-size: 14px; letter-spacing: 1px; text-transform: uppercase; color: var(--primary); transform: rotate(-2deg);">Visible Screens</div>';

  // Sort screen IDs numerically
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    const showCoords = screen.showCoordinates !== false;
    const showPixels = screen.showPixelDimensions !== false;
    const showCrosshair = screen.showCrosshair !== false;

    const textOutline = 'text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;';
    html += `
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; padding: 4px 6px; background: #333; border-radius: 4px;">
        <button type="button" class="toggle-btn ${screen.visible ? 'active' : ''}"
                style="padding: 3px 6px; font-size: 10px; min-height: 24px; line-height: 1; display: inline-flex; align-items: center; gap: 4px; width: 110px; justify-content: flex-start; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1); ${screen.visible ? textOutline : ''}"
                onclick="toggleScreenVisibility('${screenId}', ${!screen.visible})">
          <span style="display: inline-block; width: 10px; height: 10px; background: ${screen.color}; border: 1px solid #666; flex-shrink: 0;"></span>
          ${screen.name}
        </button>
        <div style="display: flex; gap: 4px;">
          <button type="button" class="toggle-btn ${showCoords ? 'active' : ''}"
                  style="padding: 3px 6px; font-size: 10px; min-width: 28px; min-height: 24px; line-height: 1; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1); ${showCoords ? textOutline : ''}"
                  onclick="toggleScreenCoordinates('${screenId}')">X/Y</button>
          <button type="button" class="toggle-btn ${showPixels ? 'active' : ''}"
                  style="padding: 3px 6px; font-size: 10px; min-width: 38px; min-height: 24px; line-height: 1; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1); ${showPixels ? textOutline : ''}"
                  onclick="toggleScreenPixelDimensions('${screenId}')">Pixels</button>
          <button type="button" class="toggle-btn ${showCrosshair ? 'active' : ''}"
                  style="padding: 3px 6px; font-size: 10px; min-width: 24px; min-height: 24px; line-height: 1; border: 2px solid #000; box-shadow: 2px 2px 0px 0px rgba(0,0,0,1); ${showCrosshair ? textOutline : ''}"
                  onclick="toggleScreenCrosshair('${screenId}')" title="Show X crosshair">X</button>
        </div>
      </div>
    `;
  });

  container.innerHTML = html;
}

function toggleScreenVisibility(screenId, visible) {
  if(screens[screenId]) {
    screens[screenId].visible = visible;
    // Update current canvas's visibility tracking
    if(currentCanvasId && canvases[currentCanvasId]) {
      if(!canvases[currentCanvasId].data.screenVisibility) {
        canvases[currentCanvasId].data.screenVisibility = {};
      }
      canvases[currentCanvasId].data.screenVisibility[screenId] = visible;

      // If turning ON a screen, turn it OFF in all other canvases
      if(visible) {
        Object.keys(canvases).forEach(canvasId => {
          if(canvasId !== currentCanvasId) {
            if(!canvases[canvasId].data.screenVisibility) {
              canvases[canvasId].data.screenVisibility = {};
            }
            canvases[canvasId].data.screenVisibility[screenId] = false;
          }
        });
      }
    }
    // Update toggle button states and redraw canvas view
    updateCanvasScreenToggles();
    showCanvasView();
  }
}

function toggleScreenCoordinates(screenId) {
  if(screens[screenId]) {
    // Toggle - default is true (shown), so undefined or true becomes false, false becomes true
    screens[screenId].showCoordinates = screens[screenId].showCoordinates === false ? true : false;
    updateCanvasScreenToggles();
    showCanvasView();
  }
}

function toggleScreenPixelDimensions(screenId) {
  if(screens[screenId]) {
    // Toggle - default is true (shown), so undefined or true becomes false, false becomes true
    screens[screenId].showPixelDimensions = screens[screenId].showPixelDimensions === false ? true : false;
    updateCanvasScreenToggles();
    showCanvasView();
  }
}

function toggleScreenCrosshair(screenId) {
  if(screens[screenId]) {
    // Toggle - default is true (shown), so undefined or true becomes false, false becomes true
    screens[screenId].showCrosshair = screens[screenId].showCrosshair === false ? true : false;
    updateCanvasScreenToggles();
    showCanvasView();
  }
}

function resetCurrentScreenOnPanelChange() {
  const screen = screens[currentScreenId];
  if(!screen) return;
  
  // Only reset dimensions and canvas position, keep other settings
  screen.data.panelsWide = 0;
  screen.data.panelsHigh = 0;
  screen.data.wallWidth = '';
  screen.data.wallHeight = '';
  screen.data.canvasX = 0;
  screen.data.canvasY = 0;
  
  document.getElementById('panelsWide').value = '';
  document.getElementById('panelsHigh').value = '';
  document.getElementById('wallWidth').value = '';
  document.getElementById('wallHeight').value = '';
  canvasOffsetX = 0;
  canvasOffsetY = 0;
}

// ==================== CABLING CALCULATION SYSTEM ====================

function roundUpToStandard(lengthFt) {
  const standards = [25, 50, 75, 100, 150, 200, 250, 300];
  for(const s of standards) {
    if(lengthFt <= s) return s;
  }
  return Math.ceil(lengthFt / 50) * 50;
}

// Returns array mapping data line index to its entry panel {col, row}
function getDataLineEntryPoints(pw, ph, panelsPerDataLine, startDir, deletedPanelsSet, customDataLineAssignmentsMap) {
  const entryPoints = {};
  const usedCustomDataLines = new Set();

  for(let c = 0; c < pw; c++) {
    for(let r = 0; r < ph; r++) {
      const panelKey = `${c},${r}`;
      if(!deletedPanelsSet.has(panelKey) && customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey)) {
        usedCustomDataLines.add(customDataLineAssignmentsMap.get(panelKey) - 1);
      }
    }
  }

  if(startDir === 'all_top') {
    let autoDataLineCounter = 0;
    for(let c = 0; c < pw; c++) {
      while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
      for(let r = 0; r < ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanelsSet.has(panelKey)) {
          const dl = (customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey))
            ? customDataLineAssignmentsMap.get(panelKey) - 1
            : autoDataLineCounter;
          if(!(dl in entryPoints)) entryPoints[dl] = {col: c, row: r};
          break;
        }
      }
      autoDataLineCounter++;
    }
  } else if(startDir === 'all_bottom') {
    let autoDataLineCounter = 0;
    for(let c = 0; c < pw; c++) {
      while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
      for(let r = ph - 1; r >= 0; r--) {
        const panelKey = `${c},${r}`;
        if(!deletedPanelsSet.has(panelKey)) {
          const dl = (customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey))
            ? customDataLineAssignmentsMap.get(panelKey) - 1
            : autoDataLineCounter;
          if(!(dl in entryPoints)) entryPoints[dl] = {col: c, row: r};
          break;
        }
      }
      autoDataLineCounter++;
    }
  } else {
    // Serpentine: top or bottom
    const startFromTop = (startDir === 'top');
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;

    while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;

    let currentColumn = 0;
    let serpentineGoingDown = startFromTop;

    while(currentColumn < pw) {
      const rows = serpentineGoingDown
        ? Array.from({length: ph}, (_, i) => i)
        : Array.from({length: ph}, (_, i) => ph - 1 - i);

      for(const r of rows) {
        const panelKey = `${currentColumn},${r}`;
        if(deletedPanelsSet.has(panelKey)) continue;

        let dataLine;
        if(customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey)) {
          dataLine = customDataLineAssignmentsMap.get(panelKey) - 1;
        } else {
          while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
          dataLine = autoDataLineCounter;
          panelsInCurrentAutoDataLine++;
          if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
            autoDataLineCounter++;
            panelsInCurrentAutoDataLine = 0;
            while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
          }
        }

        if(!(dataLine in entryPoints)) {
          entryPoints[dataLine] = {col: currentColumn, row: r};
        }
      }

      currentColumn++;
      serpentineGoingDown = !serpentineGoingDown;
    }
  }

  return entryPoints;
}

// Get ALL panels per data line in serpentine order (for inter-panel cable calculations)
function getDataLinePanelOrdering(pw, ph, panelsPerDataLine, startDir, deletedPanelsSet, customDataLineAssignmentsMap) {
  const dataLinePanels = {}; // { dataLineIndex: [{col, row}, ...] in order }
  const usedCustomDataLines = new Set();

  for(let c = 0; c < pw; c++) {
    for(let r = 0; r < ph; r++) {
      const panelKey = `${c},${r}`;
      if(!deletedPanelsSet.has(panelKey) && customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey)) {
        usedCustomDataLines.add(customDataLineAssignmentsMap.get(panelKey) - 1);
      }
    }
  }

  if(startDir === 'all_top') {
    let autoDataLineCounter = 0;
    for(let c = 0; c < pw; c++) {
      while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
      for(let r = 0; r < ph; r++) {
        const panelKey = `${c},${r}`;
        if(deletedPanelsSet.has(panelKey)) continue;
        const dl = (customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey))
          ? customDataLineAssignmentsMap.get(panelKey) - 1
          : autoDataLineCounter;
        if(!dataLinePanels[dl]) dataLinePanels[dl] = [];
        dataLinePanels[dl].push({col: c, row: r});
      }
      autoDataLineCounter++;
    }
  } else if(startDir === 'all_bottom') {
    let autoDataLineCounter = 0;
    for(let c = 0; c < pw; c++) {
      while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
      for(let r = ph - 1; r >= 0; r--) {
        const panelKey = `${c},${r}`;
        if(deletedPanelsSet.has(panelKey)) continue;
        const dl = (customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey))
          ? customDataLineAssignmentsMap.get(panelKey) - 1
          : autoDataLineCounter;
        if(!dataLinePanels[dl]) dataLinePanels[dl] = [];
        dataLinePanels[dl].push({col: c, row: r});
      }
      autoDataLineCounter++;
    }
  } else {
    // Serpentine: top or bottom
    const startFromTop = (startDir === 'top');
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;

    while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;

    let currentColumn = 0;
    let serpentineGoingDown = startFromTop;

    while(currentColumn < pw) {
      const rows = serpentineGoingDown
        ? Array.from({length: ph}, (_, i) => i)
        : Array.from({length: ph}, (_, i) => ph - 1 - i);

      for(const r of rows) {
        const panelKey = `${currentColumn},${r}`;
        if(deletedPanelsSet.has(panelKey)) continue;

        let dataLine;
        if(customDataLineAssignmentsMap && customDataLineAssignmentsMap.has(panelKey)) {
          dataLine = customDataLineAssignmentsMap.get(panelKey) - 1;
        } else {
          while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
          dataLine = autoDataLineCounter;
          panelsInCurrentAutoDataLine++;
          if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
            autoDataLineCounter++;
            panelsInCurrentAutoDataLine = 0;
            while(usedCustomDataLines.has(autoDataLineCounter)) autoDataLineCounter++;
          }
        }

        if(!dataLinePanels[dataLine]) dataLinePanels[dataLine] = [];
        dataLinePanels[dataLine].push({col: currentColumn, row: r});
      }

      currentColumn++;
      serpentineGoingDown = !serpentineGoingDown;
    }
  }

  return dataLinePanels;
}

// Calculate Manhattan detour around knockout areas
function calculateKnockoutDetour(startCol, startRow, endCol, endRow, deletedPanelsSet, pw, ph) {
  // If no knockouts between start and end, Manhattan distance is fine
  // Check if direct Manhattan path (horizontal then vertical) crosses any deleted panel
  const minCol = Math.min(startCol, endCol);
  const maxCol = Math.max(startCol, endCol);
  const minRow = Math.min(startRow, endRow);
  const maxRow = Math.max(startRow, endRow);

  let pathBlocked = false;
  // Check horizontal segment (at startRow)
  for(let c = minCol; c <= maxCol; c++) {
    if(deletedPanelsSet.has(`${c},${startRow}`)) { pathBlocked = true; break; }
  }
  if(!pathBlocked) {
    // Check vertical segment (at endCol)
    for(let r = minRow; r <= maxRow; r++) {
      if(deletedPanelsSet.has(`${endCol},${r}`)) { pathBlocked = true; break; }
    }
  }

  if(!pathBlocked) {
    // Direct Manhattan is clear
    return Math.abs(endCol - startCol) + Math.abs(endRow - startRow);
  }

  // BFS to find shortest Manhattan path avoiding knockouts
  const visited = new Set();
  const queue = [{col: startCol, row: startRow, dist: 0}];
  visited.add(`${startCol},${startRow}`);

  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // up, down, right, left

  while(queue.length > 0) {
    const {col, row, dist} = queue.shift();

    if(col === endCol && row === endRow) {
      return dist;
    }

    for(const [dc, dr] of directions) {
      const nc = col + dc;
      const nr = row + dr;
      const key = `${nc},${nr}`;

      if(nc < 0 || nc >= pw || nr < 0 || nr >= ph) continue;
      if(visited.has(key)) continue;
      if(deletedPanelsSet.has(key) && !(nc === endCol && nr === endRow)) continue;

      visited.add(key);
      queue.push({col: nc, row: nr, dist: dist + 1});
    }
  }

  // If no path found (completely blocked), fall back to Manhattan distance
  return Math.abs(endCol - startCol) + Math.abs(endRow - startRow);
}

// Main cabling calculation for a screen
function calculateCabling(screenId) {
  const screen = screens[screenId];
  if(!screen || !screen.calculatedData) return null;

  const data = screen.data;
  const calc = screen.calculatedData;
  const allPanels = {...panels, ...customPanels};
  const panelType = data.panelType;
  const p = allPanels[panelType];
  if(!p) return null;

  const pw = data.panelsWide;
  const ph = data.panelsHigh;
  if(pw === 0 || ph === 0) return null;

  const M_TO_FT = 3.28084;

  // Panel dimensions in feet
  const panelWidthFt = p.width_m * M_TO_FT;
  const panelHeightFt = p.height_m * M_TO_FT;

  // Wall dimensions in feet
  let wallHeightFt = ph * panelHeightFt;
  let wallWidthFt = pw * panelWidthFt;

  // Account for CB5 half panel row
  const hasCB5HalfRow = data.addCB5HalfRow && panelType === 'CB5_MKII';
  if(hasCB5HalfRow) {
    const halfP = allPanels['CB5_MKII_HALF'];
    if(halfP) {
      wallHeightFt += halfP.height_m * M_TO_FT;
    }
  }

  // Cabling inputs - use nullish coalescing so 0 values are respected
  const wallToFloor = data.wallToFloor ?? 5;
  const distroToWall = data.distroToWall ?? 10;
  const processorToWall = data.processorToWall ?? 15;
  const serverToProcessor = data.serverToProcessor ?? 50;
  const cablePick = data.cablePick ?? 0;
  const dropPos = data.cableDropPosition ?? 'behind';
  const distBoxOnWall = data.distBoxOnWall ?? false;

  // Deleted panels
  const deletedPanelsSet = data.deletedPanels || new Set();

  // Cable drop horizontal position (in feet from left edge)
  let dropPositionFt;
  if(dropPos === 'behind') {
    dropPositionFt = wallWidthFt / 2;
  } else if(dropPos === 'sr') {
    dropPositionFt = wallWidthFt;
  } else {
    dropPositionFt = 0;
  }

  // ---- A. SOCA (Power) Cable Calculation ----
  const socaCables = [];
  const circuitsNeeded = calc.circuitsNeeded || 0;
  const socaCount = calc.socaCount || 0;
  const columnsPerCircuit = calc.columnsPerCircuit || 1;

  for(let s = 0; s < socaCount; s++) {
    // Each SOCA covers up to 6 circuits
    const firstCircuit = s * 6;
    const lastCircuit = Math.min(firstCircuit + 5, circuitsNeeded - 1);

    // First and last columns this SOCA covers
    const firstCol = firstCircuit * columnsPerCircuit;
    const lastCol = Math.min((lastCircuit + 1) * columnsPerCircuit - 1, pw - 1);

    // Center of the SOCA's column group (in feet)
    const socaCenterFt = ((firstCol + lastCol) / 2 + 0.5) * panelWidthFt;

    // Horizontal distance from drop to SOCA center
    const horizontalFt = Math.abs(dropPositionFt - socaCenterFt);

    // Vertical: cable runs from bottom of wall down to floor, then to distro
    const verticalFt = wallHeightFt;

    const totalFt = verticalFt + horizontalFt + wallToFloor + distroToWall + cablePick;
    socaCables.push({
      index: s + 1,
      lengthFt: Math.round(totalFt * 10) / 10,
      roundedFt: roundUpToStandard(totalFt)
    });
  }

  // ---- B. Data Cable Calculation ----
  const dataCables = [];
  const distBoxCables = [];
  const dataLines = calc.dataLines || 0;
  const panelsPerDataLine = calc.panelsPerDataLine || 16;
  const redundancy = data.redundancy;
  const distributionBoxCount = calc.distributionBoxCount || 0;
  const distributionBoxName = calc.distributionBoxName || '';
  const hasDistBox = distributionBoxCount > 0;

  // Effective ph for layout (includes CB5 half row)
  const effectivePh = hasCB5HalfRow ? ph + 1 : ph;

  // Get entry points for each data line
  const entryPoints = getDataLineEntryPoints(
    pw, effectivePh, panelsPerDataLine,
    data.dataStartDir || 'top',
    deletedPanelsSet,
    data.customDataLineAssignments
  );

  if(distBoxOnWall && hasDistBox) {
    // Distribution box on wall: center top of wall
    const distBoxCol = Math.floor(pw / 2);
    const distBoxRow = 0; // top row
    const distBoxPositionFt = wallWidthFt / 2; // center horizontal

    // Data cables from dist box to each data line entry
    for(let dl = 0; dl < dataLines; dl++) {
      const entry = entryPoints[dl];
      if(!entry) continue;

      // Panel center position
      const panelCenterFt = (entry.col + 0.5) * panelWidthFt;
      const panelCenterVertFt = (entry.row + 0.5) * panelHeightFt;
      const distBoxCenterVertFt = 0.5 * panelHeightFt; // center of top row

      // Manhattan distance in panel units, accounting for knockouts
      const detourPanels = calculateKnockoutDetour(distBoxCol, distBoxRow, entry.col, entry.row, deletedPanelsSet, pw, effectivePh);
      const detourFt = detourPanels * Math.max(panelWidthFt, panelHeightFt); // approximate: use larger dimension

      // More precise: convert horizontal and vertical separately
      const hDist = Math.abs(panelCenterFt - distBoxPositionFt);
      const vDist = Math.abs(panelCenterVertFt - distBoxCenterVertFt);

      // Check if knockouts add extra distance
      const directManhattan = Math.abs(entry.col - distBoxCol) + Math.abs(entry.row - distBoxRow);
      const extraDetour = (detourPanels - directManhattan);
      const extraDetourFt = extraDetour > 0 ? extraDetour * ((panelWidthFt + panelHeightFt) / 2) : 0;

      const totalFt = hDist + vDist + extraDetourFt + cablePick;

      dataCables.push({
        lineIndex: dl + 1,
        lengthFt: Math.round(totalFt * 10) / 10,
        roundedFt: roundUpToStandard(totalFt),
        type: 'cat6a'
      });
    }

    // If redundancy, double the data cables (backup follows same paths)
    if(redundancy) {
      const backupCables = dataCables.map(c => ({...c, lineIndex: c.lineIndex, backup: true}));
      dataCables.push(...backupCables);
    }

    // Processor-to-distribution-box cables
    // Cable route: processor → floor → up wall to dist box at center top
    const procToDistBoxFt = processorToWall + wallToFloor + wallHeightFt + cablePick;
    const cableType = procToDistBoxFt > 200 ? 'fiber' : 'cat6a';

    for(let b = 0; b < distributionBoxCount; b++) {
      // 2 cables per dist box (main + backup)
      distBoxCables.push({
        boxIndex: b + 1,
        lengthFt: Math.round(procToDistBoxFt * 10) / 10,
        roundedFt: roundUpToStandard(procToDistBoxFt),
        type: cableType,
        label: 'main'
      });
      distBoxCables.push({
        boxIndex: b + 1,
        lengthFt: Math.round(procToDistBoxFt * 10) / 10,
        roundedFt: roundUpToStandard(procToDistBoxFt),
        type: cableType,
        label: 'backup'
      });
    }
  } else {
    // No dist box on wall: data cables run from processor back to each entry point
    for(let dl = 0; dl < dataLines; dl++) {
      const entry = entryPoints[dl];
      if(!entry) continue;

      // Panel center horizontal position
      const panelCenterFt = (entry.col + 0.5) * panelWidthFt;

      // Horizontal distance from drop position to panel center
      const horizontalFt = Math.abs(dropPositionFt - panelCenterFt);

      // Vertical: full wall height (cable runs top to bottom or bottom to top)
      const verticalFt = wallHeightFt;

      // Check for knockout detours from drop column to entry panel
      const dropCol = dropPos === 'sr' ? pw - 1 : (dropPos === 'sl' ? 0 : Math.floor(pw / 2));
      const entryRow = (data.dataStartDir === 'bottom' || data.dataStartDir === 'all_bottom') ? effectivePh - 1 : 0;
      const directManhattan = Math.abs(entry.col - dropCol) + Math.abs(entry.row - entryRow);
      const detourPanels = calculateKnockoutDetour(dropCol, entryRow, entry.col, entry.row, deletedPanelsSet, pw, effectivePh);
      const extraDetour = detourPanels - directManhattan;
      const extraDetourFt = extraDetour > 0 ? extraDetour * ((panelWidthFt + panelHeightFt) / 2) : 0;

      const totalFt = verticalFt + horizontalFt + wallToFloor + processorToWall + cablePick + extraDetourFt;

      dataCables.push({
        lineIndex: dl + 1,
        lengthFt: Math.round(totalFt * 10) / 10,
        roundedFt: roundUpToStandard(totalFt),
        type: 'cat6a'
      });
    }

    // If redundancy, double the data cables (backup follows same paths)
    if(redundancy) {
      const backupCables = dataCables.map(c => ({...c, lineIndex: c.lineIndex, backup: true}));
      dataCables.push(...backupCables);
    }
  }

  // ---- C. Knockout Bridge Cables ----
  // When knockouts create gaps between consecutive panels in a data line,
  // a longer cable is needed to bridge the gap (data cross jumper)
  const knockoutBridgeCables = [];

  const dataLinePanelOrdering = getDataLinePanelOrdering(
    pw, effectivePh, panelsPerDataLine,
    data.dataStartDir || 'top',
    deletedPanelsSet,
    data.customDataLineAssignments
  );

  for(const [dlIndex, panels] of Object.entries(dataLinePanelOrdering)) {
    if(panels.length < 2) continue;

    for(let i = 1; i < panels.length; i++) {
      const prev = panels[i - 1];
      const curr = panels[i];

      // Check if panels are physically adjacent (same column vertically adjacent, or column transition at boundary)
      const colDiff = Math.abs(curr.col - prev.col);
      const rowDiff = Math.abs(curr.row - prev.row);
      const isAdjacent = (colDiff === 0 && rowDiff === 1) ||
                         (colDiff === 1 && rowDiff === 0);

      if(!isAdjacent) {
        // Non-adjacent panels — need a bridge cable
        // Calculate physical distance between panel centers
        const hDist = Math.abs((curr.col + 0.5) * panelWidthFt - (prev.col + 0.5) * panelWidthFt);
        const vDist = Math.abs((curr.row + 0.5) * panelHeightFt - (prev.row + 0.5) * panelHeightFt);
        const bridgeFt = hDist + vDist + cablePick;

        knockoutBridgeCables.push({
          dataLine: parseInt(dlIndex) + 1,
          fromPanel: `${prev.col + 1},${prev.row + 1}`,
          toPanel: `${curr.col + 1},${curr.row + 1}`,
          lengthFt: Math.round(bridgeFt * 10) / 10,
          roundedFt: roundUpToStandard(bridgeFt)
        });
      }
    }
  }

  // ---- D. Totals ----
  const fiberCount = distBoxCables.filter(c => c.type === 'fiber').length;
  const cat6aDistBoxCount = distBoxCables.filter(c => c.type === 'cat6a').length;

  const result = {
    socaCables,
    dataCables,
    distBoxCables,
    knockoutBridgeCables,
    serverCable: {lengthFt: serverToProcessor},
    wallHeightFt: Math.round(wallHeightFt * 10) / 10,
    wallWidthFt: Math.round(wallWidthFt * 10) / 10,
    inputs: {wallToFloor, distroToWall, processorToWall, cablePick},
    totals: {
      socaCount: socaCables.length,
      dataCount: dataCables.length,
      knockoutBridgeCount: knockoutBridgeCables.length,
      distBoxCableCount: distBoxCables.length,
      fiberCount,
      cat6aCount: dataCables.length + cat6aDistBoxCount
    }
  };

  // Store in calculatedData
  screen.calculatedData.cabling = result;
  return result;
}

// ==================== GEAR VIEW FUNCTIONS ====================
let gearSelectedScreens = new Set();

function initGearView() {
  const togglesContainer = document.getElementById('gearScreenToggles');
  if(!togglesContainer) return;

  togglesContainer.innerHTML = '';

  // Auto-select all screens if none selected yet
  if(gearSelectedScreens.size === 0) {
    Object.keys(screens).forEach(id => gearSelectedScreens.add(id));
  }

  // Remove any screens that no longer exist
  gearSelectedScreens.forEach(id => {
    if(!screens[id]) gearSelectedScreens.delete(id);
  });

  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    const btn = document.createElement('button');
    btn.className = 'slider-toggle-btn';
    btn.dataset.screenId = screenId;
    btn.style.cssText = 'padding: 4px 12px; min-height: 26px; font-size: 10px; border: 2px solid #000; border-radius: 0; box-shadow: 1px 1px 0px 0px rgba(0,0,0,1); white-space: nowrap; width: fit-content; flex-grow: 0; flex-shrink: 0;';

    if(gearSelectedScreens.has(screenId)) {
      btn.classList.add('active');
      btn.style.background = screen.color || '#10b981';
      btn.style.color = '#fff';
      btn.style.textShadow = '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000';
    } else {
      btn.style.background = '#333';
      btn.style.color = '#9ca3af';
      btn.style.textShadow = 'none';
    }

    btn.textContent = screen.name;
    btn.onclick = function() {
      toggleGearScreen(screenId);
    };

    togglesContainer.appendChild(btn);
  });

  generateGearList();
}

function toggleGearScreen(screenId) {
  if(gearSelectedScreens.has(screenId)) {
    gearSelectedScreens.delete(screenId);
  } else {
    gearSelectedScreens.add(screenId);
  }
  initGearView();
}

function generateGearList() {
  const gearListContainer = document.getElementById('gearListContainer');
  const gearListContent = document.getElementById('gearListContent');

  if(!gearListContainer || !gearListContent) return;

  // Use selected screens if on gear tab, otherwise show all
  const allScreenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  const screenIds = (typeof currentAppMode !== 'undefined' && currentAppMode === 'gear' && gearSelectedScreens.size > 0)
    ? allScreenIds.filter(id => gearSelectedScreens.has(id))
    : allScreenIds;

  let html = '<div style="font-size: 14px;">';

  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    const data = screen.data;
    const W = data.panelsWide;
    const H = data.panelsHigh;

    if(W === 0 || H === 0) return;

    const panelType = data.panelType || document.getElementById('panelType').value;
    const allPanels = {...panels, ...customPanels};
    const p = allPanels[panelType];
    if(!p) return;

    const hasCB5HalfRow = data.addCB5HalfRow && panelType === 'CB5_MKII';
    const fullPanelRows = hasCB5HalfRow ? H - 1 : H;
    const fullPanelCount = W * fullPanelRows;
    const halfPanelCount = hasCB5HalfRow ? W : 0;

    html += `<div style="margin-bottom: 24px; padding: 16px; background: #2a2a2a; border-radius: 6px; border-left: 4px solid ${screen.color};">`;
    html += `<h3 style="color: #fff; margin-bottom: 12px; font-size: 16px;">${screen.name}</h3>`;
    html += `<div><strong>Panels:</strong> ${fullPanelCount}x ${p.brand} ${p.name}</div>`;
    if(halfPanelCount > 0) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      const halfName = halfPanel ? halfPanel.name : 'CB5 MKII Half Panel';
      html += `<div style="margin-left: 60px;">${halfPanelCount}x ${p.brand} ${halfName}</div>`;
    }
    html += `<div><strong>Dimensions:</strong> ${(W * p.width_m).toFixed(2)}m × ${(H * p.height_m).toFixed(2)}m</div>`;
    html += `<div><strong>Resolution:</strong> ${W * p.res_x} × ${H * p.res_y} px</div>`;

    // Show floor frames if this screen has them calculated
    if(screen.calculatedData && screen.calculatedData.floorFrames) {
      const ff = screen.calculatedData.floorFrames;
      if(ff.frame_1x1 > 0 || ff.frame_2x1 > 0 || ff.frame_2x2 > 0 || ff.frame_3x2 > 0) {
        html += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #444;"><strong style="color: #4ecdc4;">Floor Frames:</strong></div>`;
        if(ff.frame_3x2 > 0) html += `<div style="margin-left: 12px;">3×2 Frame: ${ff.frame_3x2}</div>`;
        if(ff.frame_2x2 > 0) html += `<div style="margin-left: 12px;">2×2 Frame: ${ff.frame_2x2}</div>`;
        if(ff.frame_2x1 > 0) html += `<div style="margin-left: 12px;">2×1 Frame: ${ff.frame_2x1}</div>`;
        if(ff.frame_1x1 > 0) html += `<div style="margin-left: 12px;">1×1 Frame: ${ff.frame_1x1}</div>`;
        const wtUnit = getWeightUnitLabel();
        const wtDisplay = displayWeightUnit === 'lbs' ? ff.totalWeightLbs.toFixed(1) : ff.totalWeightKg.toFixed(1);
        html += `<div style="margin-left: 12px; color: #4ecdc4;"><strong>Frame Weight:</strong> ${wtDisplay} ${wtUnit}</div>`;
      }
    }

    // Calculate and show cabling for this screen (inside same container)
    const cabling = calculateCabling(screenId);
    if(cabling) {
      html += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">`;
      html += `<div style="margin-bottom: 6px; color: #999; font-size: 12px;">Wall: ${cabling.wallWidthFt}' W × ${cabling.wallHeightFt}' H</div>`;

      // Power Cables (SOCA)
      if(cabling.socaCables.length > 0) {
        html += `<div style="margin-top: 8px;"><strong style="color: #ff9800;">Power (SOCA):</strong></div>`;
        const socaByLength = {};
        cabling.socaCables.forEach(s => {
          if(!socaByLength[s.roundedFt]) socaByLength[s.roundedFt] = 0;
          socaByLength[s.roundedFt]++;
        });
        for(const [len, count] of Object.entries(socaByLength).sort((a,b) => a[0] - b[0])) {
          html += `<div style="margin-left: 12px;">${count}x ${len}'</div>`;
        }
        html += `<details style="margin-left: 12px; margin-top: 4px;"><summary style="cursor: pointer; color: #999; font-size: 12px;">Detail</summary>`;
        cabling.socaCables.forEach(s => {
          html += `<div style="margin-left: 12px; font-size: 12px; color: #bbb;">SOCA ${s.index}: ${s.lengthFt}' → ${s.roundedFt}'</div>`;
        });
        html += `</details>`;
      }

      // Data Cables (including knockout bridge cables)
      const primaryCables = cabling.dataCables.filter(c => !c.backup);
      const backupCables = cabling.dataCables.filter(c => c.backup);
      const knockoutCables = cabling.knockoutBridgeCables || [];
      const hasDataCables = primaryCables.length > 0 || knockoutCables.length > 0;

      if(hasDataCables) {
        html += `<div style="margin-top: 8px;"><strong style="color: #4ecdc4;">Data Cables:</strong></div>`;
        // Combine data cables and knockout cables into one grouped list
        const allDataByLength = {};
        primaryCables.forEach(c => {
          if(!allDataByLength[c.roundedFt]) allDataByLength[c.roundedFt] = 0;
          allDataByLength[c.roundedFt]++;
        });
        knockoutCables.forEach(c => {
          if(!allDataByLength[c.roundedFt]) allDataByLength[c.roundedFt] = 0;
          allDataByLength[c.roundedFt]++;
        });
        for(const [len, count] of Object.entries(allDataByLength).sort((a,b) => a[0] - b[0])) {
          html += `<div style="margin-left: 12px;">${count}x ${len}'</div>`;
        }
        if(backupCables.length > 0) {
          html += `<div style="margin-left: 12px; color: #999;">+ ${backupCables.length}x Backup (same lengths)</div>`;
        }
        // Detail dropdown with knockout cables labeled
        html += `<details style="margin-left: 12px; margin-top: 4px;"><summary style="cursor: pointer; color: #999; font-size: 12px;">Detail</summary>`;
        primaryCables.forEach(c => {
          html += `<div style="margin-left: 12px; font-size: 12px; color: #bbb;">Line ${c.lineIndex}: ${c.lengthFt}' → ${c.roundedFt}'</div>`;
        });
        knockoutCables.forEach(c => {
          html += `<div style="margin-left: 12px; font-size: 12px; color: #ffab40;">Knockout Line ${c.dataLine}: ${c.lengthFt}' → ${c.roundedFt}'</div>`;
        });
        html += `</details>`;
      }

      // Distribution Box Cables (processor to dist box)
      if(cabling.distBoxCables.length > 0) {
        const mainBoxCables = cabling.distBoxCables.filter(c => c.label === 'main');
        html += `<div style="margin-top: 8px;"><strong style="color: #e040fb;">Processor → Dist Box:</strong></div>`;
        const boxCableType = mainBoxCables[0]?.type || 'cat6a';
        const boxCableRounded = mainBoxCables[0]?.roundedFt || 0;
        html += `<div style="margin-left: 12px;">${cabling.distBoxCables.length}x ${boxCableType === 'fiber' ? 'Fiber' : 'Cat6A'} ${boxCableRounded}'</div>`;
        if(boxCableType === 'fiber') {
          html += `<div style="margin-left: 12px; color: #e040fb; font-size: 12px;">(Fiber required: distance > 200')</div>`;
        }
      }

      // Server Cable
      html += `<div style="margin-top: 8px;"><strong style="color: #78909c;">Server → Processor:</strong> ${cabling.serverCable.lengthFt}'</div>`;

      html += `</div>`;
    }

    html += `</div>`;
  });

  html += '</div>';

  gearListContent.innerHTML = html;
  // Only show container if we're on the gear tab
  if(typeof currentAppMode !== 'undefined' && currentAppMode === 'gear') {
    gearListContainer.style.display = 'block';
  }
}

// ==================== COMBINED VIEW FUNCTIONS ====================

// Track which screens are selected for combined view
let combinedSelectedScreens = new Set();

// Combined specs power/phase toggle state
let combinedPowerType = 'max';
let combinedPhase = 3;

function setCombinedPowerType(type) {
  combinedPowerType = type;
  document.getElementById('combinedPowerMaxBtn').classList.toggle('active', type === 'max');
  document.getElementById('combinedPowerAvgBtn').classList.toggle('active', type === 'avg');
  renderCombinedSpecs(Array.from(combinedSelectedScreens));
}

function setCombinedPhase(phase) {
  combinedPhase = phase;
  document.getElementById('combinedPhase3Btn').classList.toggle('active', phase === 3);
  document.getElementById('combinedPhase1Btn').classList.toggle('active', phase === 1);
  renderCombinedSpecs(Array.from(combinedSelectedScreens));
}

// Store screen dimensions for click handling in Combined view
let combinedScreenDimensions = [];
let combinedPanelSize = 40;
let combinedTopPadding = 60;
let combinedLeftPadding = 20;
let combinedPixelScale = 1; // Uniform scale for mirroring canvas positions
let combinedZoomLevel = 100; // Zoom percentage (100 = 100%)

// Combined view panel selection state
let combinedSelectedPanel = null; // { screenId, col, row, key } - for single selection (mobile)
let combinedSelectedPanels = new Set(); // Set of "screenId:col,row" strings for multi-selection (desktop)

// Screen positions for Combined view (custom offsets)
// Format: { screenId: { x: offsetX, y: offsetY } }
let combinedScreenPositions = {};
const STORAGE_KEY_COMBINED_POSITIONS = 'ledcalc_combined_positions';

// Manual adjust mode for Combined view (controls whether dragging is enabled)
let combinedManualAdjust = false;

// Load combined screen positions from localStorage
function loadCombinedPositions() {
  try {
    const data = localStorage.getItem(STORAGE_KEY_COMBINED_POSITIONS);
    if(data) {
      combinedScreenPositions = JSON.parse(data);
    }
  } catch(e) {
    console.error('Error loading combined positions:', e);
    combinedScreenPositions = {};
  }
}

// Save combined screen positions to localStorage
function saveCombinedPositions() {
  try {
    localStorage.setItem(STORAGE_KEY_COMBINED_POSITIONS, JSON.stringify(combinedScreenPositions));
  } catch(e) {
    console.error('Error saving combined positions:', e);
  }
}

// Get screen at position for dragging (checks screen label area)
function getCombinedScreenAtPosition(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  const canvasX = (clientX - rect.left) * scaleX;
  const canvasY = (clientY - rect.top) * scaleY;

  // Check each screen - include label area above panels for easier dragging
  const zoomFactor = combinedZoomLevel / 100;
  for(const dim of combinedScreenDimensions) {
    // Scale both base position and custom offset by zoom factor
    const customPos = combinedScreenPositions[dim.screenId] || { x: 0, y: 0 };
    const screenX = combinedLeftPadding + (dim.x + customPos.x) * zoomFactor;
    const screenY = combinedTopPadding + customPos.y * zoomFactor;
    const screenWidth = dim.pw * combinedPanelSize;
    const screenHeight = dim.ph * combinedPanelSize;
    const labelHeight = 25; // Height above panels for label

    // Check if click is within this screen's bounds (including label area)
    if(canvasX >= screenX && canvasX < screenX + screenWidth &&
       canvasY >= screenY - labelHeight && canvasY < screenY + screenHeight) {
      return dim;
    }
  }
  return null;
}

// Drag state for Combined view screens
let combinedDragState = {
  isDragging: false,
  screenDim: null,
  startX: 0,
  startY: 0,
  startPosX: 0,
  startPosY: 0
};

// Setup drag handlers for Combined view screens (now handled by setupCombinedCanvasHandlers)
function setupCombinedDragHandlers() {
  // Drag handling is now integrated into setupCombinedCanvasHandlers
  // This function is kept for backward compatibility
}

// Reset all screen positions in Combined view
function resetCombinedPositions() {
  combinedScreenPositions = {};
  combinedMirrorCanvas = false;
  combinedManualAdjust = false;
  combinedZoomLevel = 100; // Reset zoom to 100%
  updateCombinedZoomDisplay();
  updateMirrorCanvasButton();
  updateManualAdjustButton();
  saveCombinedPositions();
  renderCombinedView();
}

// Toggle manual adjust mode for Combined view
function toggleManualAdjust() {
  combinedManualAdjust = !combinedManualAdjust;
  updateManualAdjustButton();
}

// Update manual adjust button visual state
function updateManualAdjustButton() {
  const btn = document.getElementById('manualAdjustBtn');
  if(btn) {
    if(combinedManualAdjust) {
      btn.classList.add('active');
      btn.style.backgroundColor = '#10b981';
      btn.style.color = '#fff';
    } else {
      btn.classList.remove('active');
      btn.style.backgroundColor = '';
      btn.style.color = '';
    }
  }
}

// Mirror Canvas Layout mode
let combinedMirrorCanvas = false;

// Toggle mirroring of Canvas view layout positions
function toggleMirrorCanvasLayout() {
  combinedMirrorCanvas = !combinedMirrorCanvas;

  if(combinedMirrorCanvas) {
    // Copy positions from Canvas view to Combined view
    mirrorCanvasPositions();
    // Auto-fit zoom to show all screens
    autoFitCombinedZoom();
  } else {
    // Clear mirrored positions and use default/custom positions
    combinedScreenPositions = {};
    saveCombinedPositions();
    // Reset zoom to 100%
    combinedZoomLevel = 100;
    updateCombinedZoomDisplay();
  }

  updateMirrorCanvasButton();
  renderCombinedView();
}

// Copy positions from Canvas view to Combined view
function mirrorCanvasPositions() {
  // Get all screen canvas positions and convert to Combined view coordinates
  const allPanels = getAllPanels();
  const selectedIds = Array.from(combinedSelectedScreens);

  if(selectedIds.length === 0) return;

  // Find the bounds of all SELECTED screens in Canvas view (pixel coordinates)
  let minCanvasX = Infinity, minCanvasY = Infinity;

  selectedIds.forEach(screenId => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;

    const data = screen.data;
    const canvasX = data.canvasX || 0;
    const canvasY = data.canvasY || 0;

    minCanvasX = Math.min(minCanvasX, canvasX);
    minCanvasY = Math.min(minCanvasY, canvasY);
  });

  if(minCanvasX === Infinity) return;

  // Get a reference panel for pixel-to-panel conversion
  // Use the first selected screen's panel type
  const firstScreen = screens[selectedIds[0]];
  const refPanelType = firstScreen?.data?.panelType || 'CB5_MKII';
  const refPanel = allPanels[refPanelType];
  if(!refPanel) return;

  // Pixel size of one panel in the Canvas view
  const pixelsPerPanel = refPanel.res_x; // Assuming square-ish panels for simplicity

  // Combined view panel size (will be recalculated in renderCombinedView)
  const combinedPanelPx = combinedPanelSize || 40;

  // Scale factor: Combined pixels per Canvas pixel
  const scale = combinedPanelPx / pixelsPerPanel;

  // Convert Canvas positions directly to Combined view absolute positions
  combinedScreenPositions = {};

  selectedIds.forEach((screenId, index) => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;

    const data = screen.data;
    const pw = data.panelsWide || 0;
    const ph = data.panelsHigh || 0;
    if(pw === 0 || ph === 0) return;

    // Get Canvas position (pixel-based)
    const canvasX = data.canvasX || 0;
    const canvasY = data.canvasY || 0;

    // Position relative to top-left of all selected screens
    const relativeCanvasX = canvasX - minCanvasX;
    const relativeCanvasY = canvasY - minCanvasY;

    // Convert to Combined view coordinates
    const combinedX = relativeCanvasX * scale;
    const combinedY = relativeCanvasY * scale;

    // Calculate what the default X position would be (side-by-side)
    let defaultX = 0;
    const gap = Math.max(10, Math.min(20, combinedPanelPx / 2));
    for(let i = 0; i < index; i++) {
      const prevScreen = screens[selectedIds[i]];
      if(prevScreen && prevScreen.data) {
        defaultX += (prevScreen.data.panelsWide || 0) * combinedPanelPx + gap;
      }
    }

    // Store as offset from default position
    combinedScreenPositions[screenId] = {
      x: combinedX - defaultX,
      y: combinedY
    };
  });

  saveCombinedPositions();
}

// Update the mirror canvas button state
function updateMirrorCanvasButton() {
  const btn = document.getElementById('mirrorCanvasBtn');
  const status = document.getElementById('mirrorCanvasStatus');

  if(btn) {
    if(combinedMirrorCanvas) {
      btn.classList.add('active');
      btn.style.background = 'var(--primary)';
      btn.style.color = '#fff';
      btn.style.textShadow = '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000';
    } else {
      btn.classList.remove('active');
      btn.style.background = 'transparent';
      btn.style.color = '#9ca3af';
      btn.style.textShadow = 'none';
    }
  }

  if(status) {
    status.textContent = combinedMirrorCanvas ? '✓ Mirroring' : '';
  }
}

// Load positions on startup
loadCombinedPositions();

// Adjust zoom level for combined standard layout
function adjustCombinedZoom(delta) {
  combinedZoomLevel = Math.max(50, Math.min(200, combinedZoomLevel + delta));
  updateCombinedZoomDisplay();
  renderCombinedView();
}

// Set zoom level directly
function setCombinedZoom(level) {
  combinedZoomLevel = Math.max(50, Math.min(200, level));
  updateCombinedZoomDisplay();
  renderCombinedView();
}

// Update zoom display
function updateCombinedZoomDisplay() {
  const input = document.getElementById('combinedZoomInput');
  if(input) {
    input.value = combinedZoomLevel;
  }
}

// Auto-fit zoom to show all screens comfortably
function autoFitCombinedZoom() {
  // When toggling mirror canvas ON, just keep zoom at 100%
  // The mirrored view uses the same panel sizes as non-mirrored at 100% zoom
  // User can manually zoom out if needed
  combinedZoomLevel = 100;
  updateCombinedZoomDisplay();
}

// Get panel and screen at position in Combined standard canvas
function getCombinedPanelAtPosition(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  const canvasX = (clientX - rect.left) * scaleX;
  const canvasY = (clientY - rect.top) * scaleY;

  const allPanels = getAllPanels();

  // Check each screen
  for(const dim of combinedScreenDimensions) {
    let screenX, screenY, drawPanelSize;

    if(combinedMirrorCanvas) {
      // Use canvas positions - convert from pixel coordinates to panel-based layout
      const dataCanvasX = dim.data.canvasX || 0;
      const dataCanvasY = dim.data.canvasY || 0;
      // Get this screen's panel pixel width to properly scale its position
      const panelType = dim.data.panelType || 'CB5_MKII';
      const panelInfo = allPanels[panelType];
      const pixelWidth = panelInfo ? panelInfo.res_x : 176;
      // Convert pixel position to panel units, then to display pixels
      screenX = combinedLeftPadding + (dataCanvasX / pixelWidth) * combinedPanelSize;
      screenY = combinedTopPadding + (dataCanvasY / pixelWidth) * combinedPanelSize;
      // Use same panel size as non-mirrored mode
      drawPanelSize = combinedPanelSize;
    } else {
      // Use custom positions or default horizontal layout
      // Scale both base position and custom offset by zoom factor
      const zoomFactor = combinedZoomLevel / 100;
      const customPos = combinedScreenPositions[dim.screenId] || { x: 0, y: 0 };
      screenX = combinedLeftPadding + (dim.x + customPos.x) * zoomFactor;
      screenY = combinedTopPadding + customPos.y * zoomFactor;
      drawPanelSize = combinedPanelSize; // Already zoomed from renderCombinedView
    }

    // Calculate proper panel dimensions for this screen
    const screenPanelType = dim.data.panelType || 'CB5_MKII';
    const screenHeightRatio = getPanelHeightRatio(screenPanelType);
    const actualPanelWidth = drawPanelSize;
    const actualPanelHeight = drawPanelSize * screenHeightRatio;

    const screenWidth = dim.pw * actualPanelWidth;
    const screenHeight = dim.ph * actualPanelHeight;

    // Check if click is within this screen's bounds
    if(canvasX >= screenX && canvasX < screenX + screenWidth &&
       canvasY >= screenY && canvasY < screenY + screenHeight) {
      const col = Math.floor((canvasX - screenX) / actualPanelWidth);
      const row = Math.floor((canvasY - screenY) / actualPanelHeight);

      if(col >= 0 && col < dim.pw && row >= 0 && row < dim.ph) {
        return {
          screenId: dim.screenId,
          screen: dim.screen,
          data: dim.data,
          col,
          row,
          key: `${col},${row}`
        };
      }
    }
  }
  return null;
}

// Get all panels within a rectangle (for drag selection)
function getCombinedPanelsInRect(canvas, x1, y1, x2, y2) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  const canvasX1 = (Math.min(x1, x2) - rect.left) * scaleX;
  const canvasY1 = (Math.min(y1, y2) - rect.top) * scaleY;
  const canvasX2 = (Math.max(x1, x2) - rect.left) * scaleX;
  const canvasY2 = (Math.max(y1, y2) - rect.top) * scaleY;

  const panels = [];
  const allPanels = getAllPanels();

  // Check each screen
  for(const dim of combinedScreenDimensions) {
    let screenX, screenY, drawPanelSize;

    if(combinedMirrorCanvas) {
      // Use canvas positions - convert from pixel coordinates to panel-based layout
      const dataCanvasX = dim.data.canvasX || 0;
      const dataCanvasY = dim.data.canvasY || 0;
      // Get this screen's panel pixel width to properly scale its position
      const panelType = dim.data.panelType || 'CB5_MKII';
      const panelInfo = allPanels[panelType];
      const pixelWidth = panelInfo ? panelInfo.res_x : 176;
      // Convert pixel position to panel units, then to display pixels
      screenX = combinedLeftPadding + (dataCanvasX / pixelWidth) * combinedPanelSize;
      screenY = combinedTopPadding + (dataCanvasY / pixelWidth) * combinedPanelSize;
      // Use same panel size as non-mirrored mode
      drawPanelSize = combinedPanelSize;
    } else {
      // Use custom positions or default horizontal layout
      // Scale both base position and custom offset by zoom factor
      const zoomFactor = combinedZoomLevel / 100;
      const customPos = combinedScreenPositions[dim.screenId] || { x: 0, y: 0 };
      screenX = combinedLeftPadding + (dim.x + customPos.x) * zoomFactor;
      screenY = combinedTopPadding + customPos.y * zoomFactor;
      drawPanelSize = combinedPanelSize; // Already zoomed from renderCombinedView
    }

    // Check each panel in this screen
    for(let c = 0; c < dim.pw; c++) {
      for(let r = 0; r < dim.ph; r++) {
        const px = screenX + c * drawPanelSize;
        const py = screenY + r * drawPanelSize;
        const px2 = px + drawPanelSize;
        const py2 = py + drawPanelSize;

        // Check if panel overlaps with selection rect
        if(px < canvasX2 && px2 > canvasX1 && py < canvasY2 && py2 > canvasY1) {
          panels.push({
            screenId: dim.screenId,
            screen: dim.screen,
            data: dim.data,
            col: c,
            row: r,
            key: `${c},${r}`
          });
        }
      }
    }
  }
  return panels;
}

// Toggle panel deletion in Combined view (syncs to Complex tab)
function toggleCombinedPanelDelete(screenId, panelKey) {
  const screen = screens[screenId];
  if(!screen || !screen.data) return;

  // Ensure deletedPanels is a Set
  if(!(screen.data.deletedPanels instanceof Set)) {
    if(Array.isArray(screen.data.deletedPanels)) {
      screen.data.deletedPanels = new Set(screen.data.deletedPanels);
    } else {
      screen.data.deletedPanels = new Set();
    }
  }

  // Toggle the panel
  if(screen.data.deletedPanels.has(panelKey)) {
    screen.data.deletedPanels.delete(panelKey);
  } else {
    screen.data.deletedPanels.add(panelKey);
  }

  // If this is the current screen, sync to global deletedPanels
  if(screenId === currentScreenId) {
    deletedPanels = new Set(screen.data.deletedPanels);
    // Recalculate for current screen
    calculate();
  }

  // Re-render combined view
  renderCombinedView();
}

// Show context menu for Combined view panel
function showCombinedPanelContextMenu(x, y, panelInfo) {
  // Remove existing menu if any
  const existingMenu = document.getElementById('combinedPanelContextMenu');
  if(existingMenu) existingMenu.remove();

  const { screenId, screen, data, col, row, key } = panelInfo;

  // Get selected panel count (use multi-selection if available, otherwise single)
  const selectedCount = combinedSelectedPanels.size > 0 ? combinedSelectedPanels.size : 1;
  const panelLabel = selectedCount === 1 ? 'panel' : 'panels';

  // Check if panel is deleted (for single panel)
  let isDeleted = false;
  if(data.deletedPanels instanceof Set) {
    isDeleted = data.deletedPanels.has(key);
  } else if(Array.isArray(data.deletedPanels)) {
    isDeleted = data.deletedPanels.includes(key);
  }

  // Create context menu
  const menu = document.createElement('div');
  menu.id = 'combinedPanelContextMenu';
  menu.style.position = 'fixed';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.background = '#2a2a2a';
  menu.style.border = '2px solid ' + (screen.color || '#10b981');
  menu.style.borderRadius = '6px';
  menu.style.padding = '4px 0';
  menu.style.zIndex = '10000';
  menu.style.minWidth = '220px';
  menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.6)';

  // Header showing selection count
  const header = document.createElement('div');
  if(selectedCount === 1) {
    header.textContent = `${screen.name} - Panel ${col+1}.${row+1}`;
  } else {
    header.textContent = `${selectedCount} panels selected`;
  }
  header.style.padding = '8px 12px';
  header.style.color = screen.color || '#10b981';
  header.style.fontWeight = 'bold';
  header.style.fontSize = '13px';
  header.style.borderBottom = '1px solid #444';
  menu.appendChild(header);

  // Helper to create menu option
  function createMenuOption(text, hoverColor, onClick) {
    const option = document.createElement('div');
    option.textContent = text;
    option.style.padding = '10px 12px';
    option.style.cursor = 'pointer';
    option.style.color = '#e0e0e0';
    option.style.fontSize = '13px';
    option.addEventListener('mouseover', function() {
      option.style.background = hoverColor;
    });
    option.addEventListener('mouseout', function() {
      option.style.background = 'transparent';
    });
    option.addEventListener('click', onClick);
    return option;
  }

  // Assign Custom Circuit # option
  const circuitOption = createMenuOption(
    `Assign Circuit # to ${selectedCount} ${panelLabel}`,
    '#2a4a6a',
    function() {
      menu.remove();
      promptAssignCombinedCircuit();
    }
  );
  menu.appendChild(circuitOption);

  // Assign Custom Data Line # option
  const dataOption = createMenuOption(
    `Assign Data Line # to ${selectedCount} ${panelLabel}`,
    '#4a2a6a',
    function() {
      menu.remove();
      promptAssignCombinedDataLine();
    }
  );
  menu.appendChild(dataOption);

  // Delete/Restore option
  const toggleOption = createMenuOption(
    selectedCount > 1 ? `Delete ${selectedCount} ${panelLabel}` : (isDeleted ? 'Restore Panel' : 'Delete Panel'),
    isDeleted ? '#2a6a2a' : '#6a2a2a',
    function() {
      if(combinedSelectedPanels.size > 0) {
        combinedSelectedPanels.forEach(pkey => {
          const [sid, pk] = pkey.split(':');
          toggleCombinedPanelDelete(sid, pk);
        });
        combinedSelectedPanels.clear();
      } else {
        toggleCombinedPanelDelete(screenId, key);
      }
      menu.remove();
    }
  );
  toggleOption.style.borderTop = '1px solid #444';
  menu.appendChild(toggleOption);

  // Go to screen option (only for single selection)
  if(selectedCount === 1) {
    const goToOption = createMenuOption(
      `Edit in ${screen.name} tab`,
      '#0a66c2',
      function() {
        menu.remove();
        switchToScreen(screenId);
        switchMobileView('complex');
      }
    );
    goToOption.style.borderTop = '1px solid #444';
    menu.appendChild(goToOption);
  }

  document.body.appendChild(menu);

  // Adjust position if menu goes off screen
  const menuRect = menu.getBoundingClientRect();
  if(menuRect.right > window.innerWidth) {
    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
  }
  if(menuRect.bottom > window.innerHeight) {
    menu.style.top = (window.innerHeight - menuRect.height - 10) + 'px';
  }

  // Close menu on click outside
  function closeMenu(e) {
    if(!menu.contains(e.target)) {
      menu.remove();
      document.removeEventListener('click', closeMenu);
      document.removeEventListener('touchstart', closeMenu);
    }
  }
  setTimeout(() => {
    document.addEventListener('click', closeMenu);
    document.addEventListener('touchstart', closeMenu);
  }, 100);
}

// Prompt user for custom circuit number and assign to selected panels
function promptAssignCombinedCircuit() {
  // Get panels to assign (use multi-selection or single selected panel)
  const panelsToAssign = [];
  if(combinedSelectedPanels.size > 0) {
    combinedSelectedPanels.forEach(pkey => {
      const [screenId, panelKey] = pkey.split(':');
      panelsToAssign.push({ screenId, panelKey });
    });
  } else if(combinedSelectedPanel) {
    panelsToAssign.push({
      screenId: combinedSelectedPanel.screenId,
      panelKey: combinedSelectedPanel.key
    });
  }

  if(panelsToAssign.length === 0) return;

  const input = prompt(`Enter circuit number for ${panelsToAssign.length} panel(s):\n(Enter 0 or leave blank to clear custom assignment)`);
  if(input === null) return; // Cancelled

  const circuitNum = parseInt(input);
  const clearAssignment = input.trim() === '' || circuitNum === 0;

  // Group panels by screen for efficient updates
  const panelsByScreen = {};
  panelsToAssign.forEach(p => {
    if(!panelsByScreen[p.screenId]) panelsByScreen[p.screenId] = [];
    panelsByScreen[p.screenId].push(p.panelKey);
  });

  // Apply to each screen's data
  Object.keys(panelsByScreen).forEach(screenId => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;

    // Ensure customCircuitAssignments is a Map
    if(!(screen.data.customCircuitAssignments instanceof Map)) {
      if(Array.isArray(screen.data.customCircuitAssignments)) {
        screen.data.customCircuitAssignments = new Map(screen.data.customCircuitAssignments);
      } else {
        screen.data.customCircuitAssignments = new Map();
      }
    }

    // Update each panel
    panelsByScreen[screenId].forEach(panelKey => {
      if(clearAssignment) {
        screen.data.customCircuitAssignments.delete(panelKey);
      } else {
        screen.data.customCircuitAssignments.set(panelKey, circuitNum);
      }
    });

    // If this is the current screen, sync to global variable
    if(screenId === currentScreenId) {
      customCircuitAssignments = new Map(screen.data.customCircuitAssignments);
      calculate(); // Recalculate layouts
    }
  });

  // Clear selection and re-render
  combinedSelectedPanels.clear();
  combinedSelectedPanel = null;
  renderCombinedView();
}

// Prompt user for custom data line number and assign to selected panels
function promptAssignCombinedDataLine() {
  // Get panels to assign (use multi-selection or single selected panel)
  const panelsToAssign = [];
  if(combinedSelectedPanels.size > 0) {
    combinedSelectedPanels.forEach(pkey => {
      const [screenId, panelKey] = pkey.split(':');
      panelsToAssign.push({ screenId, panelKey });
    });
  } else if(combinedSelectedPanel) {
    panelsToAssign.push({
      screenId: combinedSelectedPanel.screenId,
      panelKey: combinedSelectedPanel.key
    });
  }

  if(panelsToAssign.length === 0) return;

  const input = prompt(`Enter data line number for ${panelsToAssign.length} panel(s):\n(Enter 0 or leave blank to clear custom assignment)`);
  if(input === null) return; // Cancelled

  const dataLineNum = parseInt(input);
  const clearAssignment = input.trim() === '' || dataLineNum === 0;

  // Group panels by screen for efficient updates
  const panelsByScreen = {};
  panelsToAssign.forEach(p => {
    if(!panelsByScreen[p.screenId]) panelsByScreen[p.screenId] = [];
    panelsByScreen[p.screenId].push(p.panelKey);
  });

  // Apply to each screen's data
  Object.keys(panelsByScreen).forEach(screenId => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;

    // Ensure customDataLineAssignments is a Map
    if(!(screen.data.customDataLineAssignments instanceof Map)) {
      if(Array.isArray(screen.data.customDataLineAssignments)) {
        screen.data.customDataLineAssignments = new Map(screen.data.customDataLineAssignments);
      } else {
        screen.data.customDataLineAssignments = new Map();
      }
    }

    // Update each panel
    panelsByScreen[screenId].forEach(panelKey => {
      if(clearAssignment) {
        screen.data.customDataLineAssignments.delete(panelKey);
      } else {
        screen.data.customDataLineAssignments.set(panelKey, dataLineNum);
      }
    });

    // If this is the current screen, sync to global variable
    if(screenId === currentScreenId) {
      customDataLineAssignments = new Map(screen.data.customDataLineAssignments);
      calculate(); // Recalculate layouts
    }
  });

  // Clear selection and re-render
  combinedSelectedPanels.clear();
  combinedSelectedPanel = null;
  renderCombinedView();
}

// Setup Combined standard canvas touch/click handlers
// Unified handler for both screen dragging (Manual Adjust mode) and panel selection
function setupCombinedCanvasHandlers() {
  const canvas = document.getElementById('combinedStandardCanvas');
  if(!canvas) return;

  // Prevent duplicate handlers
  if(canvas.dataset.combinedHandlersSet) return;
  canvas.dataset.combinedHandlersSet = 'true';

  // Touch state
  let touchStartPos = { x: 0, y: 0 };
  let touchLastPos = { x: 0, y: 0 };
  let touchStartPanel = null;
  let touchDragPending = false;

  // Mouse panel selection state
  let mouseSelectStart = { x: 0, y: 0 };
  let isMouseSelecting = false;
  let mouseStartPanel = null;

  // ===== MOUSE HANDLERS (Desktop) =====

  // Mouse down - start drag (if Manual Adjust) or start panel selection
  canvas.addEventListener('mousedown', function(e) {
    if(e.button !== 0) return; // Only left click

    if(combinedManualAdjust) {
      // Manual Adjust mode: drag screens
      const screenDim = getCombinedScreenAtPosition(canvas, e.clientX, e.clientY);
      if(screenDim) {
        combinedDragState.isDragging = true;
        combinedDragState.screenDim = screenDim;
        combinedDragState.startX = e.clientX;
        combinedDragState.startY = e.clientY;
        combinedDragState.startPosX = combinedScreenPositions[screenDim.screenId]?.x || 0;
        combinedDragState.startPosY = combinedScreenPositions[screenDim.screenId]?.y || 0;
        canvas.style.cursor = 'grabbing';
        e.preventDefault();
      }
    } else {
      // Panel selection mode: start selection
      mouseSelectStart.x = e.clientX;
      mouseSelectStart.y = e.clientY;
      isMouseSelecting = true;
      mouseStartPanel = getCombinedPanelAtPosition(canvas, e.clientX, e.clientY);

      // Check for modifier keys (Ctrl/Cmd/Shift for multi-select)
      const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
      if(!isMultiSelect) {
        combinedSelectedPanels.clear();
      }

      // Select clicked panel immediately, or deselect all if clicking empty area
      if(mouseStartPanel) {
        const panelKey = `${mouseStartPanel.screenId}:${mouseStartPanel.key}`;
        if(combinedSelectedPanels.has(panelKey)) {
          combinedSelectedPanels.delete(panelKey);
        } else {
          combinedSelectedPanels.add(panelKey);
        }
      }
      // Always re-render to show selection changes (including deselection)
      combinedSelectedPanel = null; // Clear single selection too
      renderCombinedView();
    }
  });

  // Mouse move - drag screen or extend panel selection
  canvas.addEventListener('mousemove', function(e) {
    if(combinedDragState.isDragging) {
      // Screen dragging
      const dx = e.clientX - combinedDragState.startX;
      const dy = e.clientY - combinedDragState.startY;

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const screenId = combinedDragState.screenDim.screenId;
      if(!combinedScreenPositions[screenId]) {
        combinedScreenPositions[screenId] = { x: 0, y: 0 };
      }
      // Store positions in unzoomed units so they work correctly at any zoom level
      // The drag movement is in screen pixels, convert to canvas pixels, then to unzoomed units
      const zoomFactor = combinedZoomLevel / 100;
      combinedScreenPositions[screenId].x = combinedDragState.startPosX + (dx * scaleX) / zoomFactor;
      combinedScreenPositions[screenId].y = combinedDragState.startPosY + (dy * scaleY) / zoomFactor;

      renderCombinedView();
    } else if(isMouseSelecting) {
      // Panel drag selection
      const dx = Math.abs(e.clientX - mouseSelectStart.x);
      const dy = Math.abs(e.clientY - mouseSelectStart.y);

      // Only do rect selection if dragged more than 5 pixels
      if(dx > 5 || dy > 5) {
        const panels = getCombinedPanelsInRect(canvas, mouseSelectStart.x, mouseSelectStart.y, e.clientX, e.clientY);

        const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
        if(!isMultiSelect) {
          combinedSelectedPanels.clear();
        }

        panels.forEach(p => {
          combinedSelectedPanels.add(`${p.screenId}:${p.key}`);
        });

        renderCombinedView();
      }
    }
  });

  // Mouse up - end drag or selection
  document.addEventListener('mouseup', function(e) {
    if(combinedDragState.isDragging) {
      combinedDragState.isDragging = false;
      combinedDragState.screenDim = null;
      canvas.style.cursor = '';
      saveCombinedPositions();
    }
    isMouseSelecting = false;
    mouseStartPanel = null;
  });

  // Mouse leave - end selection (but not screen drag which uses document)
  canvas.addEventListener('mouseleave', function(e) {
    isMouseSelecting = false;
    mouseStartPanel = null;
  });

  // Right-click - context menu for panel (desktop)
  canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    if(combinedManualAdjust) return; // No panel menu in adjust mode

    const panelInfo = getCombinedPanelAtPosition(canvas, e.clientX, e.clientY);
    if(panelInfo) {
      // If clicked panel is not in selection, clear and select only it
      const panelKey = `${panelInfo.screenId}:${panelInfo.key}`;
      if(!combinedSelectedPanels.has(panelKey)) {
        combinedSelectedPanels.clear();
        combinedSelectedPanels.add(panelKey);
      }
      combinedSelectedPanel = panelInfo;
      renderCombinedView(); // Show highlight
      showCombinedPanelContextMenu(e.clientX, e.clientY, panelInfo);
    }
  });

  // Double-click to quick toggle delete (desktop)
  canvas.addEventListener('dblclick', function(e) {
    if(combinedManualAdjust) return; // No panel actions in adjust mode

    // Delete all selected panels
    if(combinedSelectedPanels.size > 0) {
      combinedSelectedPanels.forEach(key => {
        const [screenId, panelKey] = key.split(':');
        toggleCombinedPanelDelete(screenId, panelKey);
      });
      combinedSelectedPanels.clear();
    } else {
      const panelInfo = getCombinedPanelAtPosition(canvas, e.clientX, e.clientY);
      if(panelInfo) {
        toggleCombinedPanelDelete(panelInfo.screenId, panelInfo.key);
      }
    }
  });

  // ===== TOUCH HANDLERS (Mobile) =====

  canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length !== 1) return;

    const touch = e.touches[0];
    touchStartPos.x = touch.clientX;
    touchStartPos.y = touch.clientY;
    touchLastPos.x = touch.clientX;
    touchLastPos.y = touch.clientY;

    if(combinedManualAdjust) {
      // Manual Adjust mode: immediate drag like Canvas view
      const screenDim = getCombinedScreenAtPosition(canvas, touch.clientX, touch.clientY);
      if(screenDim) {
        combinedDragState.isDragging = true;
        combinedDragState.screenDim = screenDim;
        combinedDragState.startX = touch.clientX;
        combinedDragState.startY = touch.clientY;
        combinedDragState.startPosX = combinedScreenPositions[screenDim.screenId]?.x || 0;
        combinedDragState.startPosY = combinedScreenPositions[screenDim.screenId]?.y || 0;
        e.preventDefault();
      }
    } else {
      // Panel selection mode: track start panel for tap-to-select
      touchStartPanel = getCombinedPanelAtPosition(canvas, touch.clientX, touch.clientY);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', function(e) {
    if(e.touches.length !== 1) return;

    const touch = e.touches[0];
    touchLastPos.x = touch.clientX;
    touchLastPos.y = touch.clientY;

    if(combinedManualAdjust && combinedDragState.isDragging) {
      // Drag screen
      if(!touchDragPending) {
        touchDragPending = true;
        requestAnimationFrame(function() {
          touchDragPending = false;
          if(!combinedDragState.isDragging) return;

          const dx = touchLastPos.x - combinedDragState.startX;
          const dy = touchLastPos.y - combinedDragState.startY;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const screenId = combinedDragState.screenDim.screenId;
          if(!combinedScreenPositions[screenId]) {
            combinedScreenPositions[screenId] = { x: 0, y: 0 };
          }
          combinedScreenPositions[screenId].x = combinedDragState.startPosX + (dx * scaleX);
          combinedScreenPositions[screenId].y = combinedDragState.startPosY + (dy * scaleY);

          renderCombinedView();
        });
      }
      e.preventDefault();
    }
  }, { passive: false });

  canvas.addEventListener('touchend', function(e) {
    if(combinedManualAdjust) {
      // End screen drag
      if(combinedDragState.isDragging) {
        combinedDragState.isDragging = false;
        combinedDragState.screenDim = null;
        saveCombinedPositions();
      }
    } else {
      // Panel selection mode: tap to select, tap again for menu
      const dx = Math.abs(touchLastPos.x - touchStartPos.x);
      const dy = Math.abs(touchLastPos.y - touchStartPos.y);

      // Only process as tap if didn't move much
      if(dx < 15 && dy < 15 && touchStartPanel) {
        const panelKey = `${touchStartPanel.screenId}-${touchStartPanel.key}`;
        const selectedKey = combinedSelectedPanel ? `${combinedSelectedPanel.screenId}-${combinedSelectedPanel.key}` : null;

        if(selectedKey === panelKey) {
          // Panel was already selected - show context menu
          vibrate(30);
          showCombinedPanelContextMenu(touchLastPos.x, touchLastPos.y, touchStartPanel);
        } else {
          // Select this panel (highlight it)
          combinedSelectedPanel = touchStartPanel;
          vibrate(10);
          renderCombinedView(); // Will highlight selected panel
        }
      }
    }

    touchStartPanel = null;
  });

  canvas.addEventListener('touchcancel', function(e) {
    combinedDragState.isDragging = false;
    combinedDragState.screenDim = null;
    touchStartPanel = null;
  });
}

// Initialize combined view - create toggle buttons for each screen
function initCombinedView() {
  const togglesContainer = document.getElementById('combinedScreenToggles');
  if(!togglesContainer) return;

  // Show appropriate hints based on device type
  const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const desktopHints = document.getElementById('combinedHintsDesktop');
  const mobileHints = document.getElementById('combinedHintsMobile');
  if(desktopHints) desktopHints.style.display = isMobile ? 'none' : 'inline';
  if(mobileHints) mobileHints.style.display = isMobile ? 'inline' : 'none';

  // Clear existing toggles
  togglesContainer.innerHTML = '';

  // Create a toggle button for each screen (compact for mobile)
  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    const btn = document.createElement('button');
    btn.className = 'slider-toggle-btn';
    btn.dataset.screenId = screenId;
    btn.style.cssText = 'padding: 4px 12px; min-height: 26px; font-size: 10px; border: 2px solid #000; border-radius: 0; box-shadow: 1px 1px 0px 0px rgba(0,0,0,1); white-space: nowrap; width: fit-content; flex-grow: 0; flex-shrink: 0;';

    // Set button color based on screen color
    if(combinedSelectedScreens.has(screenId)) {
      btn.classList.add('active');
      btn.style.background = screen.color || '#10b981';
      btn.style.color = '#fff';
      btn.style.textShadow = '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000';
    } else {
      btn.style.background = '#333';
      btn.style.color = '#9ca3af';
      btn.style.textShadow = 'none';
    }

    btn.textContent = screen.name;
    btn.onclick = function() {
      toggleCombinedScreen(screenId);
    };

    togglesContainer.appendChild(btn);
  });

  // Render combined view if screens are selected
  if(combinedSelectedScreens.size > 0) {
    renderCombinedView();
  } else {
    // Show placeholder message
    const specsContent = document.getElementById('combinedSpecsContent');
    const gearContent = document.getElementById('combinedGearListContent');
    if(specsContent) specsContent.innerHTML = '<p style="color: #888; text-align: center;">Select screens above to view combined layouts</p>';
    if(gearContent) gearContent.innerHTML = '';

    // Clear canvases
    ['combinedStandardCanvas', 'combinedPowerCanvas', 'combinedDataCanvas', 'combinedStructureCanvas'].forEach(canvasId => {
      const canvas = document.getElementById(canvasId);
      if(canvas) {
        canvas.width = 100;
        canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, 100, 100);
        ctx.fillStyle = '#888';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No screens selected', 50, 50);
      }
    });
  }
}

// Toggle a screen in the combined view
function toggleCombinedScreen(screenId) {
  if(combinedSelectedScreens.has(screenId)) {
    combinedSelectedScreens.delete(screenId);
  } else {
    combinedSelectedScreens.add(screenId);
  }

  // Reset custom positions when toggling screens to keep layout neat
  // (unless in manual adjust mode where user is actively positioning)
  if(!combinedManualAdjust) {
    combinedScreenPositions = {};
    combinedMirrorCanvas = false;
    updateMirrorCanvasButton();
    saveCombinedPositions();
  }

  // Re-initialize to update button states and render
  initCombinedView();
}

// Render the combined view with all selected screens side by side
function renderCombinedView() {
  if(combinedSelectedScreens.size === 0) return;

  // IMPORTANT: Save current screen data first so the combined view has up-to-date info
  // This ensures the current screen's customCircuitAssignments, deletedPanels, etc. are saved
  if(typeof saveCurrentScreenData === 'function') {
    saveCurrentScreenData();
  }

  const allPanels = getAllPanels();
  const selectedScreenIds = Array.from(combinedSelectedScreens);

  // Get available width from the container
  const container = document.getElementById('combinedStandardCanvasWrapper');
  const availableWidth = container ? container.clientWidth - 40 : window.innerWidth - 60; // Account for padding

  // First pass: calculate total panels wide to determine optimal panel size
  let totalPanelsWide = 0;
  let maxPanelsHigh = 0;
  const gapCount = Math.max(0, selectedScreenIds.length - 1);
  const minGap = 10; // Minimum gap between screens

  selectedScreenIds.forEach(screenId => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;
    const pw = screen.data.panelsWide || 0;
    const ph = screen.data.panelsHigh || 0;
    if(pw > 0 && ph > 0) {
      totalPanelsWide += pw;
      maxPanelsHigh = Math.max(maxPanelsHigh, ph);
    }
  });

  if(totalPanelsWide === 0) {
    initCombinedView();
    return;
  }

  // Calculate panel size to fit all screens (with minimum size of 15px, max of 40px)
  const totalGapWidth = gapCount * minGap;
  const maxPanelSize = Math.floor((availableWidth - totalGapWidth) / totalPanelsWide);
  const panelSize = Math.max(15, Math.min(40, maxPanelSize));
  const gap = Math.max(minGap, Math.min(20, panelSize / 2)); // Scale gap with panel size

  // Calculate combined dimensions with dynamic panel size
  let totalWidth = 0;
  let maxHeight = 0;
  const screenDimensions = [];

  selectedScreenIds.forEach((screenId, index) => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;

    const data = screen.data;
    const pw = data.panelsWide || 0;
    const ph = data.panelsHigh || 0;

    if(pw > 0 && ph > 0) {
      const width = pw * panelSize;

      // Calculate actual height accounting for CB5 panel type (2:1 ratio) and half panel rows
      const screenPanelType = data.panelType || 'CB5_MKII';
      const heightRatio = getPanelHeightRatio(screenPanelType);
      const hasCB5HalfRow = data.addCB5HalfRow && screenPanelType === 'CB5_MKII';
      const originalPh = hasCB5HalfRow ? ph - 1 : ph;
      const fullPanelHeight = panelSize * heightRatio;
      const halfPanelHeight = panelSize; // Half panels are square
      const height = hasCB5HalfRow ? (originalPh * fullPanelHeight + halfPanelHeight) : (ph * fullPanelHeight);

      screenDimensions.push({
        screenId,
        screen,
        data,
        pw,
        ph,
        width,
        height,
        x: totalWidth + (index > 0 ? gap : 0)
      });

      totalWidth += width + (index > 0 ? gap : 0);
      maxHeight = Math.max(maxHeight, height);
    }
  });

  if(screenDimensions.length === 0) {
    initCombinedView(); // Will show placeholder
    return;
  }

  // Add padding for bumpers/structure (scale with panel size)
  const topPadding = Math.max(40, panelSize * 1.5);
  const bottomPadding = Math.max(40, panelSize * 1.5);
  const canvasHeight = maxHeight + topPadding + bottomPadding;
  const canvasWidth = totalWidth + 40; // Add side padding

  // Store dimensions globally for click handlers
  combinedScreenDimensions = screenDimensions;
  combinedPanelSize = panelSize * (combinedZoomLevel / 100); // Store zoomed size for hit detection
  combinedTopPadding = topPadding; // Don't scale padding - positions are not zoomed

  // Render each layout type
  renderCombinedStandardLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding);
  renderCombinedPowerLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding);
  renderCombinedDataLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding);
  renderCombinedStructureLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding);

  // Render combined specs and gear list
  renderCombinedSpecs(selectedScreenIds);
  renderCombinedGearList(selectedScreenIds);
}

// Render combined standard layout
function renderCombinedStandardLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding) {
  const canvas = document.getElementById('combinedStandardCanvas');
  if(!canvas) return;

  // Get panel pixel dimensions to calculate scale factor from canvas view to combined view
  const allPanels = getAllPanels();

  // When mirroring, calculate a pixel scale that makes panels the same size as non-mirrored mode
  // We use a single scale factor: zoomedPanelSize / referencePixelWidth
  // This way, at 100% zoom, mirrored panels are the same size as non-mirrored panels
  const zoomedPanelSize = panelSize * (combinedZoomLevel / 100);
  const referencePixelWidth = 176; // CB5 pixel width as reference
  let pixelScale = zoomedPanelSize / referencePixelWidth;
  if(pixelScale < 0.05) pixelScale = 0.05;

  // Store globally for hit detection functions
  combinedPixelScale = pixelScale;

  // Calculate canvas size with positions (use canvas positions only when mirroring is enabled)
  // Start with no assumptions - calculate actual bounds from screen positions
  let minX = Infinity, maxX = 0, minY = Infinity, maxY = 0;
  const zoomFactor = combinedZoomLevel / 100;
  const leftPad = 20; // Use different name to avoid conflict with leftPadding below

  screenDimensions.forEach(dim => {
    let scaledX, scaledY, screenWidth, screenHeight;

    if(combinedMirrorCanvas) {
      // Use canvas positions - convert from pixel coordinates to panel-based layout
      const canvasX = dim.data.canvasX || 0;
      const canvasY = dim.data.canvasY || 0;
      const panelType = dim.data.panelType || 'CB5_MKII';
      const panelInfo = allPanels[panelType];
      const pixelWidth = panelInfo ? panelInfo.res_x : 176;
      scaledX = (canvasX / pixelWidth) * zoomedPanelSize;
      scaledY = (canvasY / pixelWidth) * zoomedPanelSize;
      screenWidth = dim.pw * zoomedPanelSize;
      screenHeight = dim.ph * zoomedPanelSize;
    } else {
      // Use custom positions or default horizontal layout
      // Scale both base position and custom offset by zoom factor
      const customPos = combinedScreenPositions[dim.screenId] || { x: 0, y: 0 };
      scaledX = (dim.x + customPos.x) * zoomFactor;
      scaledY = customPos.y * zoomFactor;
      screenWidth = dim.pw * zoomedPanelSize;
      screenHeight = dim.ph * zoomedPanelSize;
    }

    // Calculate actual screen bounds on canvas
    const screenLeft = leftPad + scaledX;
    const screenRight = screenLeft + screenWidth;
    const screenTop = topPadding + scaledY - 30; // Include label area
    const screenBottom = topPadding + scaledY + screenHeight;

    minX = Math.min(minX, screenLeft);
    maxX = Math.max(maxX, screenRight);
    minY = Math.min(minY, screenTop);
    maxY = Math.max(maxY, screenBottom);
  });

  // Add padding around all content
  const paddingX = 40;
  const paddingY = 60;

  // Canvas must be large enough to show all screens with padding
  // Handle case where screens might have negative positions
  const contentWidth = maxX - Math.min(0, minX) + paddingX;
  const contentHeight = maxY - Math.min(0, minY) + paddingY;

  const adjustedWidth = Math.max(canvasWidth * zoomFactor, contentWidth);
  const adjustedHeight = Math.max(canvasHeight * zoomFactor, contentHeight);

  canvas.width = adjustedWidth;
  canvas.height = adjustedHeight;
  const ctx = canvas.getContext('2d');

  // Black background
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, adjustedWidth, adjustedHeight);

  const leftPadding = 20;

  screenDimensions.forEach(dim => {
    const { screen, data, pw, ph, x, screenId } = dim;

    let screenX, screenY, actualPanelSize;
    if(combinedMirrorCanvas) {
      // Use canvas positions with pixel scale for positioning only
      const canvasX = data.canvasX || 0;
      const canvasY = data.canvasY || 0;
      // Get this screen's panel pixel width to properly scale its position
      const panelType = data.panelType || 'CB5_MKII';
      const panelInfo = allPanels[panelType];
      const pixelWidth = panelInfo ? panelInfo.res_x : 176;
      // Convert pixel position to panel units, then to display pixels
      screenX = leftPadding + (canvasX / pixelWidth) * zoomedPanelSize;
      screenY = topPadding + (canvasY / pixelWidth) * zoomedPanelSize;
      // Use same panel size as non-mirrored mode for consistent appearance
      actualPanelSize = zoomedPanelSize;
    } else {
      // Use custom positions or default horizontal layout
      // Scale both base position and custom offset by zoom factor
      const zoomFactor = combinedZoomLevel / 100;
      const customPos = combinedScreenPositions[screenId] || { x: 0, y: 0 };
      screenX = leftPadding + (x + customPos.x) * zoomFactor;
      screenY = topPadding + customPos.y * zoomFactor;
      actualPanelSize = zoomedPanelSize;
    }

    // Get screen colors for checkerboard pattern (same as original)
    let primaryColor = screen.color || '#808080';
    let secondaryColor = screen.color2 || darkenColor(primaryColor, 30);
    // Convert to pastel for eco-friendly printing
    if (ecoPrintMode) {
      primaryColor = toPastelColor(primaryColor);
      secondaryColor = toPastelColor(secondaryColor);
    }
    // Convert to greyscale for greyscale printing
    if (greyscalePrintMode) {
      primaryColor = toGreyscale(primaryColor);
      secondaryColor = toGreyscale(secondaryColor);
    }

    // Properly convert deletedPanels to Set (may be array from JSON or Set with Array iterator)
    let screenDeletedPanels = new Set();
    if(data.deletedPanels instanceof Set) {
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(Array.isArray(data.deletedPanels)) {
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(data.deletedPanels && typeof data.deletedPanels[Symbol.iterator] === 'function') {
      for(const key of data.deletedPanels) {
        screenDeletedPanels.add(key);
      }
    }

    // Draw panels with checkerboard pattern (same as original)
    // Use actualPanelSize for mirroring mode, zoomedPanelSize for normal mode
    const drawPanelSize = combinedMirrorCanvas ? actualPanelSize : zoomedPanelSize;

    // Calculate panel height for CB5_MKII (rectangular) vs other panels (square)
    const screenPanelType = data.panelType || 'CB5_MKII';
    const screenHeightRatio = getPanelHeightRatio(screenPanelType);
    const drawPanelWidth = drawPanelSize;
    const drawPanelHeight = drawPanelSize * screenHeightRatio;

    // Check if this screen has half panel row enabled
    const screenHasCB5HalfRow = data.addCB5HalfRow && screenPanelType === 'CB5_MKII';
    const screenOriginalPh = screenHasCB5HalfRow ? ph - 1 : ph;
    const halfPanelDrawHeight = drawPanelSize; // Half panels are square

    for(let c = 0; c < pw; c++) {
      for(let r = 0; r < ph; r++) {
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row
        const isHalfPanelRow = screenHasCB5HalfRow && r === screenOriginalPh;
        const currentDrawHeight = isHalfPanelRow ? halfPanelDrawHeight : drawPanelHeight;
        const px = screenX + c * drawPanelWidth;
        const py = screenY + (isHalfPanelRow ? (screenOriginalPh * drawPanelHeight) : (r * drawPanelHeight));

        const hasDeleted = screenDeletedPanels.has(panelKey);
        if(hasDeleted) {
          ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
          ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.setLineDash([]);
          continue;
        }

        // Checkerboard pattern (same as original)
        const isEvenPanel = (c + r) % 2 === 0;
        ctx.fillStyle = isEvenPanel ? primaryColor : secondaryColor;
        ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);

        // Black border
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);

        // Black panel number (scale font with panel size)
        ctx.fillStyle = '#000000';
        const panelFontSize = Math.max(6, Math.min(11, drawPanelSize * 0.28));
        ctx.font = `${panelFontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Only show panel numbers if panels are large enough
        if(drawPanelSize >= 15) {
          ctx.fillText(`${c+1}.${r+1}`, px + drawPanelWidth/2, py + currentDrawHeight/2);
        }
      }
    }

    // Calculate total screen height for label positioning
    const screenTotalHeight = screenHasCB5HalfRow ? (screenOriginalPh * drawPanelHeight + halfPanelDrawHeight) : (ph * drawPanelHeight);

    // Draw screen label (scale font with panel size)
    ctx.fillStyle = '#fff';
    const labelFontSize = Math.max(8, Math.min(14, drawPanelSize * 0.35));
    ctx.font = `bold ${labelFontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(screen.name, screenX + (pw * drawPanelWidth) / 2, screenY - Math.max(6, drawPanelSize * 0.25));
  });

  // Draw selection highlight on top of everything (after all panels drawn)
  // Calculate scaled border properties based on zoom level (zoomFactor already defined above)
  const scaledLineWidth = Math.max(1, Math.round(2 * zoomFactor));
  const scaledOffset = Math.max(1, Math.round(1 * zoomFactor));
  const scaledInset = scaledOffset * 2;

  // First, highlight all multi-selected panels (desktop)
  if(combinedSelectedPanels.size > 0) {
    ctx.strokeStyle = '#FFFF00';
    ctx.lineWidth = scaledLineWidth;
    combinedSelectedPanels.forEach(key => {
      const [screenId, panelKey] = key.split(':');
      const [col, row] = panelKey.split(',').map(Number);
      const selectedDim = screenDimensions.find(d => d.screenId === screenId);
      if(selectedDim) {
        let screenX, screenY, drawPanelSize;
        if(combinedMirrorCanvas) {
          const canvasX = selectedDim.data.canvasX || 0;
          const canvasY = selectedDim.data.canvasY || 0;
          screenX = leftPadding + canvasX * pixelScale;
          screenY = topPadding + canvasY * pixelScale;
          const panelType = selectedDim.data.panelType || 'CB5_MKII';
          const panelInfo = allPanels[panelType];
          const pixelWidth = panelInfo ? panelInfo.res_x : 176;
          drawPanelSize = pixelWidth * pixelScale;
        } else {
          const customPos = combinedScreenPositions[selectedDim.screenId] || { x: 0, y: 0 };
          screenX = leftPadding + (selectedDim.x + customPos.x) * zoomFactor;
          screenY = topPadding + customPos.y * zoomFactor;
          drawPanelSize = zoomedPanelSize;
        }
        // Calculate proper panel dimensions for highlight (skip CB5 half panels)
        const screenPanelType = selectedDim.data.panelType || 'CB5_MKII';
        const screenHeightRatio = getPanelHeightRatio(screenPanelType);
        const hasCB5HalfRow = selectedDim.data.addCB5HalfRow && screenPanelType === 'CB5_MKII';
        const originalPh = hasCB5HalfRow ? selectedDim.ph - 1 : selectedDim.ph;
        const isHalfPanelRow = hasCB5HalfRow && row === originalPh;
        
        let highlightWidth, highlightHeight;
        if (isHalfPanelRow) {
          // Keep square highlight for CB5 half panels (as requested)
          highlightWidth = drawPanelSize;
          highlightHeight = drawPanelSize;
        } else {
          // Use rectangular highlight for CB5 full panels and other rectangular panels
          highlightWidth = drawPanelSize;
          highlightHeight = drawPanelSize * screenHeightRatio;
        }
        
        const px = screenX + col * highlightWidth;
        // For CB5 with half panel row, calculate Y position properly
        let py;
        if (hasCB5HalfRow) {
          if (isHalfPanelRow) {
            // Half panel row is at the bottom
            py = screenY + originalPh * (drawPanelSize * screenHeightRatio);
          } else {
            // Full panels use rectangular height
            py = screenY + row * (drawPanelSize * screenHeightRatio);
          }
        } else {
          // No half panel row - use calculated highlight height
          py = screenY + row * highlightHeight;
        }
        ctx.strokeRect(px + scaledOffset, py + scaledOffset, highlightWidth - scaledInset, highlightHeight - scaledInset);
      }
    });
  }

  // Also highlight single selected panel (mobile)
  if(combinedSelectedPanel && combinedSelectedPanels.size === 0) {
    const selectedDim = screenDimensions.find(d => d.screenId === combinedSelectedPanel.screenId);
    if(selectedDim) {
      let screenX, screenY, drawPanelSize;
      if(combinedMirrorCanvas) {
        const canvasX = selectedDim.data.canvasX || 0;
        const canvasY = selectedDim.data.canvasY || 0;
        screenX = leftPadding + canvasX * pixelScale;
        screenY = topPadding + canvasY * pixelScale;
        const panelType = selectedDim.data.panelType || 'CB5_MKII';
        const panelInfo = allPanels[panelType];
        const pixelWidth = panelInfo ? panelInfo.res_x : 176;
        drawPanelSize = pixelWidth * pixelScale;
      } else {
        const customPos = combinedScreenPositions[selectedDim.screenId] || { x: 0, y: 0 };
        screenX = leftPadding + (selectedDim.x + customPos.x) * zoomFactor;
        screenY = topPadding + customPos.y * zoomFactor;
        drawPanelSize = zoomedPanelSize;
      }
      const col = combinedSelectedPanel.col;
      const row = combinedSelectedPanel.row;
      const px = screenX + col * drawPanelSize;
      const py = screenY + row * drawPanelSize;

      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = scaledLineWidth;
      ctx.strokeRect(px + scaledOffset, py + scaledOffset, drawPanelSize - scaledInset, drawPanelSize - scaledInset);
    }
  }
}

// Render combined power layout
function renderCombinedPowerLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding) {
  const canvas = document.getElementById('combinedPowerCanvas');
  if(!canvas) return;

  // Add SOCA label height at the top
  const socaLabelHeight = 60;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight + socaLabelHeight;
  const ctx = canvas.getContext('2d');

  // Fill label area with white background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvasWidth, socaLabelHeight);

  // Black background for panel area
  ctx.fillStyle = '#000';
  ctx.fillRect(0, socaLabelHeight, canvasWidth, canvasHeight);

  // Draw black border at bottom of SOCA label area
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, socaLabelHeight);
  ctx.lineTo(canvasWidth, socaLabelHeight);
  ctx.stroke();

  const leftPadding = 20;

  screenDimensions.forEach(dim => {
    const { screen, data, pw, ph, x, screenId } = dim;
    // Use the default x position from screenDimensions (no custom positioning)
    const screenX = leftPadding + x;
    const screenY = topPadding + socaLabelHeight;

    // Properly convert deletedPanels to Set (may be array from JSON or Set with Array iterator)
    let screenDeletedPanels = new Set();
    if(data.deletedPanels instanceof Set) {
      // It's already a Set, copy it
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(Array.isArray(data.deletedPanels)) {
      // It's an array (from JSON)
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(data.deletedPanels && typeof data.deletedPanels[Symbol.iterator] === 'function') {
      // It's some other iterable
      for(const key of data.deletedPanels) {
        screenDeletedPanels.add(key);
      }
    }

    // Properly convert customCircuitAssignments to Map (may be array from JSON)
    let screenCustomCircuits = new Map();
    if(data.customCircuitAssignments instanceof Map) {
      data.customCircuitAssignments.forEach((val, key) => screenCustomCircuits.set(key, val));
    } else if(Array.isArray(data.customCircuitAssignments)) {
      data.customCircuitAssignments.forEach(([key, val]) => screenCustomCircuits.set(key, val));
    } else if(data.customCircuitAssignments && typeof data.customCircuitAssignments.entries === 'function') {
      for(const [key, val] of data.customCircuitAssignments.entries()) {
        screenCustomCircuits.set(key, val);
      }
    }

    // Get panels per circuit - need to calculate like original if not set
    const allPanelsData = getAllPanels();
    const panelType = data.panelType || 'CB5_MKII';
    const panelInfo = allPanelsData[panelType];
    const voltage = parseInt(data.voltage) || 208;
    const breaker = parseInt(data.breaker) || 20;
    const powerType = data.powerType || 'max';
    const perPanelW = powerType === 'max' ? (panelInfo?.power_max_w || 500) : (panelInfo?.power_avg_w || 250);
    const circuitCapacityW = voltage * breaker;
    const calculatedPanelsPerCircuit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
    const userMaxPanelsPerCircuit = parseInt(data.maxPanelsPerCircuit);
    const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;

    // Build list of all panels in order (column by column, top to bottom) - SAME AS ORIGINAL
    const orderedPanels = [];
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
        if(!hasDeleted) {
          const hasCustom = screenCustomCircuits.has ? screenCustomCircuits.has(panelKey) : false;
          orderedPanels.push({
            key: panelKey,
            col: c,
            row: r,
            isCustom: hasCustom,
            customCircuit: hasCustom ? screenCustomCircuits.get(panelKey) - 1 : null
          });
        }
      }
    }

    // Collect all custom circuit numbers that are in use
    const usedCustomCircuits = new Set();
    orderedPanels.forEach(p => {
      if(p.isCustom) {
        usedCustomCircuits.add(p.customCircuit);
      }
    });

    // Assign circuit numbers using same logic as original
    const panelToCircuit = new Map();
    let autoCircuitCounter = 0;
    let panelsInCurrentAutoCircuit = 0;

    orderedPanels.forEach(panel => {
      if(panel.isCustom) {
        panelToCircuit.set(panel.key, panel.customCircuit);
      } else {
        while(usedCustomCircuits.has(autoCircuitCounter)) {
          autoCircuitCounter++;
        }
        panelToCircuit.set(panel.key, autoCircuitCounter);
        panelsInCurrentAutoCircuit++;

        if(panelsInCurrentAutoCircuit >= panelsPerCircuit) {
          autoCircuitCounter++;
          panelsInCurrentAutoCircuit = 0;
          while(usedCustomCircuits.has(autoCircuitCounter)) {
            autoCircuitCounter++;
          }
        }
      }
    });

    // Calculate panel dimensions for CB5_MKII (rectangular) vs other panels (square)
    const screenHeightRatio = getPanelHeightRatio(panelType);
    const drawPanelWidth = panelSize;
    const drawPanelHeight = panelSize * screenHeightRatio;

    // Check if this screen has half panel row enabled
    const screenHasCB5HalfRow = data.addCB5HalfRow && panelType === 'CB5_MKII';
    const screenOriginalPh = screenHasCB5HalfRow ? ph - 1 : ph;
    const halfPanelDrawHeight = panelSize; // Half panels are square

    // Draw all panels using resistor colors (same as original)
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row
        const isHalfPanelRow = screenHasCB5HalfRow && r === screenOriginalPh;
        const currentDrawHeight = isHalfPanelRow ? halfPanelDrawHeight : drawPanelHeight;
        const px = screenX + c * drawPanelWidth;
        const py = screenY + (isHalfPanelRow ? (screenOriginalPh * drawPanelHeight) : (r * drawPanelHeight));

        const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
        if(hasDeleted) {
          ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
          ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.setLineDash([]);
          continue;
        }

        const circuitNum = panelToCircuit.get(panelKey);
        if(circuitNum === undefined) continue;

        // Use colorForIndex for resistor colors (same as original)
        const socaGroup = Math.floor(circuitNum / 6);
        const colorIndex = circuitNum % 6;
        const colors = colorForIndex(colorIndex);

        // Lighten the color based on SOCA group (same as original)
        const lightenPercent = socaGroup * 0.15;
        const fillColor = lightenColor(colors.solid, lightenPercent);

        ctx.fillStyle = fillColor;
        ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
      }
    }

    // Draw SOCA labels for this screen
    let maxCircuitNum = 0;
    panelToCircuit.forEach(circuitNum => {
      if(circuitNum > maxCircuitNum) maxCircuitNum = circuitNum;
    });
    const totalCircuits = maxCircuitNum + 1;
    const socaGroups = Math.ceil(totalCircuits / 6);

    // Build circuit to panels map
    const circuitPanelMap = new Map();
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
        if(hasDeleted) continue;

        const circuitNum = panelToCircuit.get(panelKey);
        if(circuitNum !== undefined) {
          if(!circuitPanelMap.has(circuitNum)) {
            circuitPanelMap.set(circuitNum, []);
          }
          circuitPanelMap.get(circuitNum).push({
            c: c,
            r: r,
            x: screenX + c * drawPanelWidth
          });
        }
      }
    }

    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.font = 'bold 14px Arial';
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for(let s = 0; s < socaGroups; s++){
      const startCircuit = s * 6;
      const endCircuit = Math.min((s + 1) * 6 - 1, totalCircuits - 1);

      let minX = Infinity;
      let maxX = -Infinity;

      for(let circuit = startCircuit; circuit <= endCircuit; circuit++) {
        if(circuitPanelMap.has(circuit)) {
          const panels = circuitPanelMap.get(circuit);
          panels.forEach(p => {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
          });
        }
      }

      if(minX === Infinity) continue;

      const lineY = 35;
      const startX = minX;
      const endX = maxX + drawPanelWidth;
      const midX = (startX + endX) / 2;

      // Draw horizontal line
      ctx.beginPath();
      ctx.moveTo(startX, lineY);
      ctx.lineTo(endX, lineY);
      ctx.stroke();

      // Draw vertical ticks
      ctx.beginPath();
      ctx.moveTo(startX, lineY - 8);
      ctx.lineTo(startX, lineY + 8);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(endX, lineY - 8);
      ctx.lineTo(endX, lineY + 8);
      ctx.stroke();

      // Draw SOCA label
      ctx.fillText(`SOCA ${s + 1}`, midX, lineY - 18);
    }

    // Draw screen label (white text above the panels, like data layout)
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(screen.name, screenX + (pw * panelSize) / 2, screenY - 10);
  });
}

// Render combined data layout
function renderCombinedDataLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding) {
  const canvas = document.getElementById('combinedDataCanvas');
  if(!canvas) return;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext('2d');

  // Black background
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);

  const leftPadding = 20;

  screenDimensions.forEach(dim => {
    const { screen, data, pw, ph, x, screenId } = dim;
    // Use the default x position from screenDimensions (no custom positioning)
    const screenX = leftPadding + x;
    const screenY = topPadding;

    // Properly convert deletedPanels to Set (may be array from JSON or Set with Array iterator)
    let screenDeletedPanels = new Set();
    if(data.deletedPanels instanceof Set) {
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(Array.isArray(data.deletedPanels)) {
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(data.deletedPanels && typeof data.deletedPanels[Symbol.iterator] === 'function') {
      for(const key of data.deletedPanels) {
        screenDeletedPanels.add(key);
      }
    }

    // Properly convert customDataLineAssignments to Map (may be array from JSON)
    let screenCustomDataLines = new Map();
    if(data.customDataLineAssignments instanceof Map) {
      data.customDataLineAssignments.forEach((val, key) => screenCustomDataLines.set(key, val));
    } else if(Array.isArray(data.customDataLineAssignments)) {
      data.customDataLineAssignments.forEach(([key, val]) => screenCustomDataLines.set(key, val));
    } else if(data.customDataLineAssignments && typeof data.customDataLineAssignments.entries === 'function') {
      for(const [key, val] of data.customDataLineAssignments.entries()) {
        screenCustomDataLines.set(key, val);
      }
    }

    const panelsPerDataLine = data.maxPanelsPerData || 48;
    const startDir = data.dataStartDir || 'top';

    // Calculate panel dimensions for CB5_MKII (rectangular) vs other panels (square)
    const screenPanelType = data.panelType || 'CB5_MKII';
    const screenHeightRatio = getPanelHeightRatio(screenPanelType);
    const drawPanelWidth = panelSize;
    const drawPanelHeight = panelSize * screenHeightRatio;

    // Check if this screen has half panel row enabled
    const screenHasCB5HalfRow = data.addCB5HalfRow && screenPanelType === 'CB5_MKII';
    const screenOriginalPh = screenHasCB5HalfRow ? ph - 1 : ph;
    const halfPanelDrawHeight = panelSize; // Half panels are square

    // Build data line assignments using serpentine pattern (same as original)
    const panelToDataLine = new Map();

    // Collect all custom data line numbers that are in use
    const usedCustomDataLines = new Set();
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(screenCustomDataLines.has(panelKey)) {
          usedCustomDataLines.add(screenCustomDataLines.get(panelKey) - 1);
        }
      }
    }

    // Build serpentine path based on data start direction
    const serp = [];
    if(startDir === 'all_top') {
      for(let c=0; c<pw; c++){
        for(let r=0; r<ph; r++) {
          const panelKey = `${c},${r}`;
          const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
          if(!hasDeleted) {
            serp.push({c, r, key: panelKey});
          }
        }
      }
    } else if(startDir === 'all_bottom') {
      for(let c=0; c<pw; c++){
        for(let r=ph-1; r>=0; r--) {
          const panelKey = `${c},${r}`;
          const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
          if(!hasDeleted) {
            serp.push({c, r, key: panelKey});
          }
        }
      }
    } else {
      // Serpentine pattern for 'top' and 'bottom'
      const startFromTop = (startDir === 'top');
      for(let c=0; c<pw; c++){
        const goingDown = startFromTop ? (c % 2 === 0) : (c % 2 === 1);
        if(goingDown) {
          for(let r=0; r<ph; r++) {
            const panelKey = `${c},${r}`;
            const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
            if(!hasDeleted) {
              serp.push({c, r, key: panelKey});
            }
          }
        } else {
          for(let r=ph-1; r>=0; r--) {
            const panelKey = `${c},${r}`;
            const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
            if(!hasDeleted) {
              serp.push({c, r, key: panelKey});
            }
          }
        }
      }
    }

    // Assign data lines
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;

    serp.forEach(panel => {
      const hasCustom = screenCustomDataLines.has ? screenCustomDataLines.has(panel.key) : false;
      if(hasCustom) {
        panelToDataLine.set(panel.key, screenCustomDataLines.get(panel.key) - 1);
      } else {
        while(usedCustomDataLines.has(autoDataLineCounter)) {
          autoDataLineCounter++;
        }
        panelToDataLine.set(panel.key, autoDataLineCounter);
        panelsInCurrentAutoDataLine++;

        if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
          autoDataLineCounter++;
          panelsInCurrentAutoDataLine = 0;
          while(usedCustomDataLines.has(autoDataLineCounter)) {
            autoDataLineCounter++;
          }
        }
      }
    });

    // Draw all panels using resistor colors (same as original)
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row
        const isHalfPanelRow = screenHasCB5HalfRow && r === screenOriginalPh;
        const currentDrawHeight = isHalfPanelRow ? halfPanelDrawHeight : drawPanelHeight;
        const px = screenX + c * drawPanelWidth;
        const py = screenY + (isHalfPanelRow ? (screenOriginalPh * drawPanelHeight) : (r * drawPanelHeight));

        const hasDeleted = screenDeletedPanels.has ? screenDeletedPanels.has(panelKey) : false;
        if(hasDeleted) {
          ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
          ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.strokeStyle = (ecoPrintMode || greyscalePrintMode) ? '#cccccc' : '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.setLineDash([]);
          continue;
        }

        const dataLineNum = panelToDataLine.get(panelKey);
        if(dataLineNum === undefined) continue;

        // Use colorForIndex for resistor colors (same as original)
        const colors = colorForIndex(dataLineNum);

        ctx.fillStyle = colors.fill;
        ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
      }
    }

    // Draw screen label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(screen.name, screenX + (pw * drawPanelWidth) / 2, screenY - 10);
  });
}

// Render combined structure layout
function renderCombinedStructureLayout(screenDimensions, canvasWidth, canvasHeight, panelSize, topPadding) {
  const canvas = document.getElementById('combinedStructureCanvas');
  if(!canvas) return;

  // Add extra height for bumpers at top and bottom
  const bumperHeight = Math.max(25, panelSize * 0.7);
  canvas.width = canvasWidth;
  canvas.height = canvasHeight + bumperHeight * 2 + 20; // Extra space for bumpers
  const ctx = canvas.getContext('2d');

  // Dark background (same as original structure layout)
  ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#ffffff' : '#1a1a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const leftPadding = 20;

  screenDimensions.forEach(dim => {
    const { screen, data, pw, ph, x, screenId } = dim;
    // Use the default x position from screenDimensions (no custom positioning)
    const screenX = leftPadding + x;
    const structureType = data.structureType || 'hanging';

    // Properly convert deletedPanels to Set (may be array from JSON or Set with Array iterator)
    let screenDeletedPanels = new Set();
    if(data.deletedPanels instanceof Set) {
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(Array.isArray(data.deletedPanels)) {
      data.deletedPanels.forEach(key => screenDeletedPanels.add(key));
    } else if(data.deletedPanels && typeof data.deletedPanels[Symbol.iterator] === 'function') {
      for(const key of data.deletedPanels) {
        screenDeletedPanels.add(key);
      }
    }

    const screenBumpers = data.bumpers || [];

    // Calculate panel dimensions for CB5_MKII (rectangular) vs other panels (square)
    const screenPanelType = data.panelType || 'CB5_MKII';
    const screenHeightRatio = getPanelHeightRatio(screenPanelType);
    const drawPanelWidth = panelSize;
    const drawPanelHeight = panelSize * screenHeightRatio;

    // Check if this screen has half panel row enabled
    const screenHasCB5HalfRow = data.addCB5HalfRow && screenPanelType === 'CB5_MKII';
    const screenOriginalPh = screenHasCB5HalfRow ? ph - 1 : ph;
    const halfPanelDrawHeight = panelSize; // Half panels are square

    // Calculate total screen height (accounting for half panel row if present)
    const screenTotalHeight = screenHasCB5HalfRow ? (screenOriginalPh * drawPanelHeight + halfPanelDrawHeight) : (ph * drawPanelHeight);

    // Determine if we have top or bottom bumpers based on structure type
    const isHanging = structureType === 'hanging' || structureType === 'hybrid';
    const isGround = structureType === 'ground' || structureType === 'floor';

    // Check if there are any top or bottom bumpers
    const hasTopBumpers = screenBumpers.some(b => b.position === 'top');
    const hasBottomBumpers = screenBumpers.some(b => b.position === 'bottom');

    // Calculate panel Y position based on bumper placement (no custom positioning)
    let panelYOffset = topPadding;
    if(hasTopBumpers) {
      panelYOffset += bumperHeight + 5;
    }

    // Draw panels first (white background with black outline, same as original)
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;

        // Determine if this row is the half panel row
        const isHalfPanelRow = screenHasCB5HalfRow && r === screenOriginalPh;
        const currentDrawHeight = isHalfPanelRow ? halfPanelDrawHeight : drawPanelHeight;
        const px = screenX + c * drawPanelWidth;
        const py = panelYOffset + (isHalfPanelRow ? (screenOriginalPh * drawPanelHeight) : (r * drawPanelHeight));

        const hasDeleted = screenDeletedPanels.has(panelKey);
        if(hasDeleted) {
          // Deleted panels show dashed outline
          ctx.strokeStyle = '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
          ctx.setLineDash([]);
          continue;
        }

        // White background for panels (same as original)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(px, py, drawPanelWidth, currentDrawHeight);

        // Black outline
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(px, py, drawPanelWidth, currentDrawHeight);
      }
    }

    // Draw bumpers from screen data using proper bumper structure
    if(screenBumpers.length > 0) {
      screenBumpers.forEach(bumper => {
        // Calculate bumper width based on type
        let bumperWidthCols = 1;
        if(bumper.type === '2w') {
          bumperWidthCols = 2;
        } else if(bumper.type === '4w') {
          // 4W bumpers span from startCol to endCol
          bumperWidthCols = (bumper.endCol - bumper.startCol) || 2;
        }

        const bumperX = screenX + bumper.startCol * drawPanelWidth;
        const bumperWidthPx = bumperWidthCols * drawPanelWidth;
        let bumperY;

        if(bumper.position === 'top') {
          // Top bumpers
          bumperY = topPadding;
        } else {
          // Bottom bumpers - use total screen height which accounts for half panel row
          bumperY = panelYOffset + screenTotalHeight + 5;
        }

        // Use colors matching original: green for top 2W, orange for bottom, blue for 1W, orange for 4W
        let fillColor = '#4CAF50'; // Default green
        if(bumper.type === '1w') {
          fillColor = '#2196F3'; // Blue for 1W
        } else if(bumper.type === '4w') {
          fillColor = '#FF6B35'; // Orange for 4W
        } else if(bumper.position === 'bottom') {
          fillColor = '#FF9800'; // Orange for bottom bumpers
        }

        // Draw bumper
        ctx.fillStyle = fillColor;
        ctx.fillRect(bumperX, bumperY, bumperWidthPx, bumperHeight);

        // Black outline
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(bumperX, bumperY, bumperWidthPx, bumperHeight);

        // Bumper label (black for eco print, white otherwise)
        ctx.fillStyle = (ecoPrintMode || greyscalePrintMode) ? '#000000' : '#FFFFFF';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = bumper.type ? bumper.type.toUpperCase() : '2W';
        ctx.fillText(label, bumperX + bumperWidthPx/2, bumperY + bumperHeight/2);
      });
    }

    // Draw screen label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    let labelY;
    if(hasTopBumpers) {
      labelY = topPadding - 15;
    } else {
      labelY = panelYOffset - 15;
    }
    ctx.fillText(screen.name, screenX + (pw * drawPanelWidth) / 2, labelY);
  });
}

// Render combined specifications
function renderCombinedSpecs(selectedScreenIds) {
  const specsContent = document.getElementById('combinedSpecsContent');
  if(!specsContent) return;

  let totalPixels = 0;
  let totalPowerW = 0;
  let totalWeight = 0;
  let totalWidth = 0;
  let maxHeight = 0;
  let totalDataLines = 0;
  let totalAmps = 0;
  let totalAmpsPerPhase = 0;

  // Track panels by type
  const panelsByType = {};

  const allPanels = getAllPanels();

  selectedScreenIds.forEach(screenId => {
    const screen = screens[screenId];
    if(!screen || !screen.data) return;

    const data = screen.data;
    const calcData = screen.calculatedData || {};
    const pw = data.panelsWide || 0;
    const ph = data.panelsHigh || 0;
    const panelType = data.panelType || 'CB5_MKII';
    const panel = allPanels[panelType];

    if(!panel || pw === 0 || ph === 0) return;

    // Count deleted panels properly
    let deletedCount = 0;
    if(data.deletedPanels instanceof Set) {
      deletedCount = data.deletedPanels.size;
    } else if(Array.isArray(data.deletedPanels)) {
      deletedCount = data.deletedPanels.length;
    }

    // Count active panels (exclude deleted)
    const activePanels = calcData.activePanels || ((pw * ph) - deletedCount);

    // CB5 half panel row
    const hasCB5HalfRow = data.addCB5HalfRow && panelType === 'CB5_MKII';

    // Track panels by type
    const panelDisplayName = `${panel.brand} ${panel.name}`;
    if(!panelsByType[panelDisplayName]) {
      panelsByType[panelDisplayName] = 0;
    }
    panelsByType[panelDisplayName] += activePanels;

    // Add half panel row to panel count
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      if(halfPanel) {
        const halfDisplayName = `${halfPanel.brand} ${halfPanel.name}`;
        if(!panelsByType[halfDisplayName]) panelsByType[halfDisplayName] = 0;
        panelsByType[halfDisplayName] += pw;
      }
    }

    // Pixels - use stored value or calculate
    totalPixels += calcData.totalPixels || (activePanels * panel.res_x * panel.res_y);

    // Power - use combined toggle state
    const powerPerPanel = combinedPowerType === 'max' ? (panel.power_max_w || 0) : (panel.power_avg_w || 0);
    let screenPowerW = activePanels * powerPerPanel;
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      if(halfPanel) {
        screenPowerW += pw * (combinedPowerType === 'max' ? (halfPanel.power_max_w || 0) : (halfPanel.power_avg_w || 0));
      }
    }
    totalPowerW += screenPowerW;

    // Amps - use per-screen voltage with combined phase toggle
    const voltage = parseInt(data.voltage) || 208;
    const screenAmps = voltage > 0 ? screenPowerW / voltage : 0;
    totalAmps += screenAmps;
    totalAmpsPerPhase += combinedPhase === 3 ? screenAmps / 1.732 : screenAmps;

    // Weight - use stored calculated data (panels + structure)
    if('panelWeightOnlyKg' in calcData) {
      // Use stored breakdown: panels + bumpers + plates + ground support + floor frames
      const panelWeightKg = calcData.panelWeightOnlyKg || 0;
      const bumperWeightKg = calcData.bumperWeightKg || 0;
      const platesWeightKg = calcData.platesWeightKg || 0;
      const groundSupportWeightKg = calcData.groundSupportWeightKg || 0;
      const floorFramesWeightKg = (calcData.floorFrames && calcData.floorFrames.totalWeightKg) || 0;
      totalWeight += panelWeightKg + bumperWeightKg + platesWeightKg + groundSupportWeightKg + floorFramesWeightKg;
    } else {
      // Fallback: panel weight only
      const screenUseConnectingPlates = (panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF') && data.connectionMethod === 'plates';
      totalWeight += activePanels * getPanelWeight(panelType, screenUseConnectingPlates);
      if(hasCB5HalfRow) {
        totalWeight += pw * getPanelWeight('CB5_MKII_HALF', screenUseConnectingPlates);
      }
    }

    // Data lines - use stored calculated value
    totalDataLines += calcData.dataLines || Math.ceil(activePanels / (parseInt(data.maxPanelsPerData) || 48));

    // Dimensions
    totalWidth += pw * (panel.width_m || 0.5);
    let screenHeight = ph * (panel.height_m || 0.5);
    if(hasCB5HalfRow) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      if(halfPanel) screenHeight += halfPanel.height_m || 0;
    }
    maxHeight = Math.max(maxHeight, screenHeight);
  });

  // Calculate total panels
  const totalPanels = Object.values(panelsByType).reduce((sum, count) => sum + count, 0);

  const isImperial = displayLengthUnit === 'ft';
  const weightUnit = displayWeightUnit;

  // Format values
  const widthDisplay = isImperial ? (totalWidth * 3.28084).toFixed(2) + ' ft' : totalWidth.toFixed(2) + ' m';
  const heightDisplay = isImperial ? (maxHeight * 3.28084).toFixed(2) + ' ft' : maxHeight.toFixed(2) + ' m';
  const weightDisplay = weightUnit === 'lbs' ? (totalWeight * 2.20462).toFixed(1) + ' lbs' : totalWeight.toFixed(1) + ' kg';

  // Helper to shorten panel type names for display
  function shortenPanelName(fullName) {
    // Remove "ROE Visual" prefix, keep brand abbreviation
    let short = fullName.replace('ROE Visual ', 'ROE ');
    // Remove full names, keep model numbers (e.g., "Black Pearl BP2 V2" -> "BP2 V2")
    short = short.replace('Black Pearl ', '');
    short = short.replace('Black Onyx ', '');
    short = short.replace('Black Marble ', '');
    short = short.replace('Carbon ', '');
    short = short.replace(' (Matte)', '');
    short = short.replace(' Half Panel', ' Half');
    return short;
  }

  // Build panels display
  let panelsDisplay = `${totalPanels}`;
  const panelTypes = Object.keys(panelsByType);
  if(panelTypes.length === 1) {
    panelsDisplay += ` (${shortenPanelName(panelTypes[0])})`;
  } else if(panelTypes.length > 1) {
    panelsDisplay += '<br>';
    panelTypes.forEach(type => {
      panelsDisplay += `<span style="font-size: 0.85em; color: #ccc; padding-left: 8px;">• ${panelsByType[type]}x ${shortenPanelName(type)}</span><br>`;
    });
  }

  // Two-column layout with green title above white value (vertically stacked)
  let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">';

  // Left column: Total Screens, Total Panels, Total Pixels, Total Weight
  html += '<div style="display: flex; flex-direction: column; gap: 12px;">';
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Total Screens</div><div style="color: #fff;">${selectedScreenIds.length}</div></div>`;
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Total Panels</div><div style="color: #fff;">${panelsDisplay}</div></div>`;
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Total Pixels</div><div style="color: #fff;">${totalPixels.toLocaleString()}</div></div>`;
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Total Weight</div><div style="color: #fff;">${weightDisplay}</div></div>`;
  html += '</div>';

  // Right column: Dimensions, Power, Amps, Amps/Phase, Data Lines
  html += '<div style="display: flex; flex-direction: column; gap: 12px;">';
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Dimensions</div><div style="color: #fff;">${widthDisplay} × ${heightDisplay}</div></div>`;
  const powerLabel = combinedPowerType === 'max' ? 'Power (Max)' : 'Power (Avg)';
  const phaseLabel = combinedPhase === 3 ? 'Amps/Phase (3Ø)' : 'Total Amps (1Ø)';
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">${powerLabel}</div><div style="color: #fff;">${totalPowerW.toLocaleString()} W</div></div>`;
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Total Amps</div><div style="color: #fff;">${totalAmps.toFixed(1)} A</div></div>`;
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">${phaseLabel}</div><div style="color: #fff;">${totalAmpsPerPhase.toFixed(1)} A</div></div>`;
  html += `<div><div style="color: #10b981; font-family: 'Roboto Condensed', sans-serif; font-weight: 700; font-size: 0.9em;">Data Lines</div><div style="color: #fff;">${totalDataLines}</div></div>`;
  html += '</div>';

  html += '</div>';

  specsContent.innerHTML = html;
}

// Render combined gear list - matches PDF export format with categories
function renderCombinedGearList(selectedScreenIds) {
  const gearContent = document.getElementById('combinedGearListContent');
  if(!gearContent) return;

  const allPanels = getAllPanels();

  // Aggregate gear from all selected screens
  const panelsByType = {}; // { 'Brand Name': count }
  let totalCircuits = 0;
  let totalDataLines = 0;
  let totalProcessors = 0;
  let total1wBumpers = 0;
  let total2wBumpers = 0;
  let total4wBumpers = 0;
  let totalPlates2way = 0;
  let totalPlates4way = 0;
  let totalShackles = 0;
  let totalCheeseye = 0;
  let totalSocaSplays = 0;
  let totalTrue1Twofers = 0;
  let totalDataJumpers = 0;
  let totalDataCrossJumpers = 0;
  let totalCat5Couplers = 0;
  let totalPowerJumpers = 0;

  // Ground support
  let totalRearTruss = 0;
  let totalBaseTruss = 0;
  let totalBridgeClamps = 0;
  let totalRearBridgeAdapters = 0;
  let totalSandbags = 0;
  let totalSwivelCheeseboroughs = 0;
  let totalPipes = 0;

  // Floor frames
  let totalFrame1x1 = 0;
  let totalFrame2x1 = 0;
  let totalFrame2x2 = 0;
  let totalFrame3x2 = 0;

  // Track panel info for jumpers
  let hasJumpersBuiltin = false;
  let dataJumperLen = '';
  let dataCrossJumperLen = '';
  let powerJumperLen = '';
  let needsShacklesAndCheeseye = false;
  let hasHangingScreen = false;
  let hasFloorScreen = false;

  selectedScreenIds.forEach(screenId => {
    const screen = screens[screenId];
    if(!screen) return;

    const data = screen.data || {};
    const calculatedData = screen.calculatedData || {};

    const pw = data.panelsWide || 0;
    const ph = data.panelsHigh || 0;
    const panelType = data.panelType || 'CB5_MKII';
    const panel = allPanels[panelType];

    if(!panel || pw === 0 || ph === 0) return;

    // Count panels per type, accounting for CB5 half row
    const hasCB5HalfRow = data.addCB5HalfRow && panelType === 'CB5_MKII';
    const fullRows = hasCB5HalfRow ? ph - 1 : ph;
    const fullPanelCount = pw * fullRows;
    const halfPanelCount = hasCB5HalfRow ? pw : 0;

    const panelLabel = `${panel.brand} ${panel.name}`;
    panelsByType[panelLabel] = (panelsByType[panelLabel] || 0) + fullPanelCount;
    if(halfPanelCount > 0) {
      const halfPanel = allPanels['CB5_MKII_HALF'];
      const halfLabel = halfPanel ? `${halfPanel.brand} ${halfPanel.name}` : `${panel.brand} CB5 MKII Half Panel`;
      panelsByType[halfLabel] = (panelsByType[halfLabel] || 0) + halfPanelCount;
    }

    // Count deleted panels for jumper calculations
    let deletedCount = 0;
    if(data.deletedPanels instanceof Set) {
      deletedCount = data.deletedPanels.size;
    } else if(Array.isArray(data.deletedPanels)) {
      deletedCount = data.deletedPanels.length;
    }
    const activePanels = (pw * ph) - deletedCount;

    // Use calculated data if available
    if(calculatedData.circuits) totalCircuits += calculatedData.circuits;
    if(calculatedData.dataLines) totalDataLines += calculatedData.dataLines;
    if(calculatedData.processors) totalProcessors += calculatedData.processors;
    if(calculatedData.socaCount) totalSocaSplays += calculatedData.socaCount;

    // Count bumpers from screen's bumper data
    const screenBumpers = data.bumpers || [];
    const useBumpers = data.useBumpers !== false;
    let screenBumper1w = 0;
    let screenBumper2w = 0;
    screenBumpers.forEach(b => {
      if(b.type === '1w') { total1wBumpers++; screenBumper1w++; }
      else if(b.type === '2w') { total2wBumpers++; screenBumper2w++; }
      else if(b.type === '4w') total4wBumpers++;
    });

    // Estimate plates
    totalPlates2way += Math.max(0, (pw - 2));
    totalPlates4way += data.use4WayBumpers ? Math.floor(pw / 2) : 0;

    // Shackles and Cheeseye
    const needsShackles = ['CB5_MKII', 'CB5_MKII_HALF', 'MC7H', 'INFILED_AMT8_3'].includes(panelType);
    const structureType = data.structureType || 'hanging';
    const isHanging = structureType === 'hanging';
    if(isHanging) hasHangingScreen = true;
    if(structureType === 'floor') hasFloorScreen = true;

    if(needsShackles && isHanging && useBumpers) {
      needsShacklesAndCheeseye = true;
      if(panelType === 'INFILED_AMT8_3') {
        totalShackles += screenBumper1w + (screenBumper2w * 2);
        totalCheeseye += screenBumper1w + (screenBumper2w * 2);
      } else {
        totalShackles += screenBumper1w + screenBumper2w;
        totalCheeseye += screenBumper1w + screenBumper2w;
      }
    }

    // Ground support from calculated data
    if(calculatedData.groundSupport) {
      const gs = calculatedData.groundSupport;
      totalRearTruss += gs.totalRearTruss || 0;
      totalBaseTruss += gs.totalBaseTruss || 0;
      totalBridgeClamps += gs.totalBridgeClamps || 0;
      totalRearBridgeAdapters += gs.totalRearBridgeClampAdapters || 0;
      totalSandbags += gs.totalSandbags || 0;
      totalSwivelCheeseboroughs += gs.totalSwivelCheeseboroughs || 0;
      totalPipes += gs.totalPipes || 0;
    }

    // Floor frames from calculated data
    if(calculatedData.floorFrames) {
      const ff = calculatedData.floorFrames;
      totalFrame1x1 += ff.frame_1x1 || 0;
      totalFrame2x1 += ff.frame_2x1 || 0;
      totalFrame2x2 += ff.frame_2x2 || 0;
      totalFrame3x2 += ff.frame_3x2 || 0;
    }

    // Panel-specific info for data/power jumpers
    if(panel.jumpers_builtin) hasJumpersBuiltin = true;
    if(panel.data_jumper_ft && !dataJumperLen) dataJumperLen = panel.data_jumper_ft;
    if(panel.data_cross_jumper_ft && !dataCrossJumperLen) dataCrossJumperLen = panel.data_cross_jumper_ft;
    if(panel.power_jumper_ft && !powerJumperLen) powerJumperLen = panel.power_jumper_ft;

    // Data and power jumpers
    if(!panel.jumpers_builtin && panel.data_jumper_ft) {
      totalDataJumpers += activePanels;
    }
    if(!panel.jumpers_builtin && panel.power_jumper_ft) {
      totalPowerJumpers += activePanels;
    }
    if(calculatedData.dataCrossJumperCount) {
      totalDataCrossJumpers += calculatedData.dataCrossJumperCount;
    }
    if(panel.jumpers_builtin) {
      const screenDataLines = calculatedData.dataLines || 0;
      const screenCrossJumpers = calculatedData.dataCrossJumperCount || 0;
      totalCat5Couplers += screenDataLines + screenCrossJumpers;
    }

    // True1 Twofers
    const columnsPerCircuit = calculatedData.columnsPerCircuit || 1;
    const circuitsNeeded = calculatedData.circuits || 0;
    if(columnsPerCircuit > 1) {
      totalTrue1Twofers += circuitsNeeded * columnsPerCircuit;
    }
  });

  // Helper to add a gear line only if value > 0
  function addGearLine(label, value) {
    if(value > 0) {
      return `<div style="margin-left: 12px;"><strong>${label}</strong> ${value}</div>`;
    }
    return '';
  }

  // Helper to add a section header
  function addGearHeader(title) {
    return `<div style="font-weight: bold; color: #10b981; margin-top: 12px; margin-bottom: 4px;">${title}</div>`;
  }

  let html = '<div style="line-height: 1.8; font-size: 14px;">';

  // Equipment Section
  html += addGearHeader('Equipment');
  html += addGearLine('Processors:', totalProcessors);
  for(const [panelLabel, count] of Object.entries(panelsByType)) {
    if(count > 0) {
      html += `<div style="margin-left: 12px;"><strong>${panelLabel}:</strong> ${count}</div>`;
    }
  }
  html += addGearLine('Power Circuits:', totalCircuits);
  html += addGearLine('Data Lines:', totalDataLines);

  // Rigging Hardware Section
  const hasRiggingHardware = total1wBumpers > 0 || total2wBumpers > 0 || total4wBumpers > 0 ||
                             totalPlates2way > 0 || totalPlates4way > 0 || totalShackles > 0 || totalCheeseye > 0;
  if(hasRiggingHardware) {
    html += addGearHeader('Rigging Hardware');
    html += addGearLine('1W Bumpers:', total1wBumpers);
    html += addGearLine('2W Bumpers:', total2wBumpers);
    html += addGearLine('4W Bumpers:', total4wBumpers);
    html += addGearLine('4W Connecting Plates:', totalPlates4way);
    html += addGearLine('2W Connecting Plates:', totalPlates2way);
    html += addGearLine('5/8" Shackles:', totalShackles);
    html += addGearLine('Cheeseye:', totalCheeseye);
  }

  // Ground Support Section
  const hasGroundSupport = totalRearTruss > 0 || totalBaseTruss > 0 || totalBridgeClamps > 0 ||
                           totalRearBridgeAdapters > 0 || totalSandbags > 0 || totalSwivelCheeseboroughs > 0 || totalPipes > 0;
  if(hasGroundSupport) {
    html += addGearHeader('Ground Support');
    html += addGearLine('Rear Truss:', totalRearTruss);
    html += addGearLine('Base Truss:', totalBaseTruss);
    html += addGearLine('Bridge Clamps:', totalBridgeClamps);
    html += addGearLine('Rear Bridge Adapter:', totalRearBridgeAdapters);
    html += addGearLine('Sandbags:', totalSandbags);
    html += addGearLine('Swivel Cheeseborough:', totalSwivelCheeseboroughs);
    html += addGearLine('Pipes:', totalPipes);
  }

  // Floor Hardware Section
  const hasFloorHardware = totalFrame1x1 > 0 || totalFrame2x1 > 0 || totalFrame2x2 > 0 || totalFrame3x2 > 0;
  if(hasFloorHardware) {
    html += addGearHeader('Floor Hardware');
    html += addGearLine('3×2 Frame:', totalFrame3x2);
    html += addGearLine('2×2 Frame:', totalFrame2x2);
    html += addGearLine('2×1 Frame:', totalFrame2x1);
    html += addGearLine('1×1 Frame:', totalFrame1x1);
  }

  // Data Cables Section
  const hasDataCables = totalDataJumpers > 0 || totalDataCrossJumpers > 0 || totalCat5Couplers > 0;
  if(hasDataCables) {
    html += addGearHeader('Data Cables');
    if(totalDataJumpers > 0 && dataJumperLen) {
      html += addGearLine(`Data Jumpers ${dataJumperLen}:`, totalDataJumpers);
    }
    if(totalDataCrossJumpers > 0 && dataCrossJumperLen) {
      html += addGearLine(`Data Cross Jumpers ${dataCrossJumperLen}:`, totalDataCrossJumpers);
    }
    html += addGearLine('Cat5 Couplers:', totalCat5Couplers);
  }

  // Power Cables Section
  const hasPowerCables = totalSocaSplays > 0 || totalPowerJumpers > 0 || totalTrue1Twofers > 0;
  if(hasPowerCables) {
    html += addGearHeader('Power Cables');
    if(totalPowerJumpers > 0 && powerJumperLen) {
      html += addGearLine(`Power Jumpers ${powerJumperLen}:`, totalPowerJumpers);
    }
    html += addGearLine('Soca Splays:', totalSocaSplays);
    html += addGearLine('True1 Twofer:', totalTrue1Twofers);
  }

  // Cabling Section - per-screen cable length calculations
  let hasCablingData = false;
  selectedScreenIds.forEach(screenId => {
    const screen = screens[screenId];
    if(!screen) return;
    const cabling = calculateCabling(screenId);
    if(!cabling) return;
    hasCablingData = true;
  });

  if(hasCablingData) {
    html += addGearHeader('Cable Runs');
    selectedScreenIds.forEach(screenId => {
      const screen = screens[screenId];
      if(!screen) return;
      const cabling = screen.calculatedData?.cabling;
      if(!cabling) return;

      html += `<div style="margin-top: 8px; margin-left: 4px; padding: 8px; background: #3a2a2a; border-radius: 4px; border-left: 3px solid ${screen.color};">`;
      html += `<div style="font-weight: bold; color: #c27676; margin-bottom: 4px;">${screen.name}</div>`;

      // SOCA
      if(cabling.socaCables.length > 0) {
        const socaByLength = {};
        cabling.socaCables.forEach(s => {
          if(!socaByLength[s.roundedFt]) socaByLength[s.roundedFt] = 0;
          socaByLength[s.roundedFt]++;
        });
        html += `<div style="margin-left: 8px; color: #ff9800;"><strong>SOCA:</strong></div>`;
        for(const [len, count] of Object.entries(socaByLength).sort((a,b) => a[0] - b[0])) {
          html += `<div style="margin-left: 16px;">${count}x ${len}'</div>`;
        }
      }

      // Data cables (including knockout bridge cables)
      const primaryCables = cabling.dataCables.filter(c => !c.backup);
      const backupCables = cabling.dataCables.filter(c => c.backup);
      const knockoutCables = cabling.knockoutBridgeCables || [];
      if(primaryCables.length > 0 || knockoutCables.length > 0) {
        const allDataByLength = {};
        primaryCables.forEach(c => {
          if(!allDataByLength[c.roundedFt]) allDataByLength[c.roundedFt] = 0;
          allDataByLength[c.roundedFt]++;
        });
        knockoutCables.forEach(c => {
          if(!allDataByLength[c.roundedFt]) allDataByLength[c.roundedFt] = 0;
          allDataByLength[c.roundedFt]++;
        });
        html += `<div style="margin-left: 8px; color: #4ecdc4;"><strong>Data:</strong></div>`;
        for(const [len, count] of Object.entries(allDataByLength).sort((a,b) => a[0] - b[0])) {
          html += `<div style="margin-left: 16px;">${count}x ${len}'</div>`;
        }
        if(backupCables.length > 0) {
          html += `<div style="margin-left: 16px; color: #999;">+ ${backupCables.length}x Backup</div>`;
        }
      }

      // Dist box cables
      if(cabling.distBoxCables.length > 0) {
        const boxType = cabling.distBoxCables[0]?.type === 'fiber' ? 'Fiber' : 'Cat6A';
        const boxLen = cabling.distBoxCables[0]?.roundedFt || 0;
        html += `<div style="margin-left: 8px; color: #e040fb;"><strong>Proc→Dist Box:</strong> ${cabling.distBoxCables.length}x ${boxType} ${boxLen}'</div>`;
      }

      // Server cable
      html += `<div style="margin-left: 8px; color: #78909c;"><strong>Server→Proc:</strong> ${cabling.serverCable.lengthFt}'</div>`;
      html += `</div>`;
    });
  }

  html += '</div>';

  gearContent.innerHTML = html;
}

</script>

<!-- Bottom Navigation - Toggle for Complex/Simple/Combined + Canvas button -->
<nav class="bottom-nav">
  <div class="nav-mode-toggle">
    <button class="nav-toggle-btn active" data-mode="complex" onclick="switchAppMode('complex')">
      <span>Complex</span>
    </button>
    <button class="nav-toggle-btn" data-mode="simple" onclick="switchAppMode('simple')">
      <span>Simple</span>
    </button>
    <button class="nav-toggle-btn" data-mode="combined" onclick="switchAppMode('combined')">
      <span>Combined</span>
    </button>
    <button class="nav-toggle-btn" data-mode="gear" onclick="switchAppMode('gear')">
      <span>Gear</span>
    </button>
  </div>
  <button class="nav-item" data-view="canvas" onclick="switchMobileView('canvas')">
    <span class="nav-item-label">Canvas</span>
  </button>
</nav>

<script>
// ==================== MOBILE-SPECIFIC JAVASCRIPT ====================

// Mobile Menu Functions
function toggleMobileMenu() {
  const overlay = document.getElementById('mobileMenuOverlay');
  overlay.classList.toggle('active');
  document.body.style.overflow = overlay.classList.contains('active') ? 'hidden' : '';
}

function closeMobileMenu() {
  const overlay = document.getElementById('mobileMenuOverlay');
  overlay.classList.remove('active');
  document.body.style.overflow = '';
}

// Hard refresh - reloads the app with cache bypass
function hardRefreshApp() {
  // Get the version we're updating to from the banner
  const banner = document.getElementById('updateBanner');
  const targetVersion = banner && banner.dataset.version;

  // Set dismissed version to target so banner won't reappear during refresh cycle
  if (targetVersion) {
    localStorage.setItem('dismissedUpdateVersion', targetVersion);
  }

  // Simple cache-busting reload
  const url = new URL(window.location.origin + window.location.pathname);
  url.searchParams.set('_v', Date.now());
  window.location.href = url.toString();
}

// Mobile View Switching
let currentMobileView = 'simple';
let currentAppMode = 'simple'; // Track complex vs simple mode
let currentMobileLayout = 'standard'; // Track which layout is showing in layouts view

// Switch between Complex, Simple, and Combined app modes
function switchAppMode(mode) {
  currentAppMode = mode;

  // Update toggle button states
  document.querySelectorAll('.nav-toggle-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });

  // Switch to the appropriate view
  if(mode === 'complex') {
    switchMobileView('complex');
  } else if(mode === 'simple') {
    switchMobileView('simple');
  } else if(mode === 'combined') {
    switchMobileView('combined');
  } else if(mode === 'gear') {
    switchMobileView('gear');
  }
}

function switchMobileView(view) {
  currentMobileView = view;

  // Update nav items (for canvas button)
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.toggle('active', item.dataset.view === view);
  });

  // Update toggle buttons based on view
  if(view === 'complex' || view === 'simple' || view === 'combined' || view === 'gear') {
    document.querySelectorAll('.nav-toggle-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.mode === view);
    });
  }

  // Get all containers
  const mainContainer = document.querySelector('.main-container');
  const resultsEl = document.getElementById('results');
  const specWarningEl = document.getElementById('specWarning');
  const screenTabsContainer = document.getElementById('screenTabsContainer');
  const layoutsTogglesContainer = document.getElementById('layoutsTogglesContainer');
  const canvasContainer = document.getElementById('canvasContainer');
  const canvasTabsEl = document.getElementById('canvasTabsContainer');
  const combinedContainer = document.getElementById('combinedContainer');
  const gearListContainer = document.getElementById('gearListContainer');

  // Layout containers
  const standardContainer = document.getElementById('standardContainer');
  const powerContainer = document.getElementById('powerContainer');
  const dataContainer = document.getElementById('dataContainer');
  const structureContainer = document.getElementById('structureContainer');

  // Config sections (for simple mode hiding)
  const powerSection = document.getElementById('powerSection');
  const structureSection = document.getElementById('structureSection');
  const dataDirectionRow = document.getElementById('dataDirectionRow');
  const dataTogglesRow = document.getElementById('dataTogglesRow');

  // Hide all first
  if(mainContainer) mainContainer.style.display = 'none';
  if(resultsEl) resultsEl.style.display = 'none';
  if(specWarningEl) specWarningEl.style.display = 'none';
  if(screenTabsContainer) screenTabsContainer.style.display = 'none';
  if(layoutsTogglesContainer) layoutsTogglesContainer.style.display = 'none';
  if(standardContainer) standardContainer.style.display = 'none';
  if(powerContainer) powerContainer.style.display = 'none';
  if(dataContainer) dataContainer.style.display = 'none';
  if(structureContainer) structureContainer.style.display = 'none';
  if(canvasContainer) canvasContainer.style.display = 'none';
  if(canvasTabsEl) canvasTabsEl.style.display = 'none';
  if(combinedContainer) combinedContainer.style.display = 'none';
  if(gearListContainer) gearListContainer.style.display = 'none';

  switch(view) {
    case 'complex':
      // Show full app - all sections visible
      if(mainContainer) mainContainer.style.display = 'block';
      if(resultsEl) resultsEl.style.display = 'block';
      if(specWarningEl) specWarningEl.style.display = 'block';
      if(screenTabsContainer) screenTabsContainer.style.display = 'flex';
      // Show all config sections
      if(powerSection) powerSection.style.display = 'block';
      if(structureSection) structureSection.style.display = 'block';
      if(dataDirectionRow) dataDirectionRow.style.display = 'block';
      if(dataTogglesRow) dataTogglesRow.style.display = 'flex';
      break;

    case 'simple':
      // Simple mode - show config, specs, canvas. No layouts, no cabling, no structure
      if(mainContainer) mainContainer.style.display = 'block';
      if(resultsEl) resultsEl.style.display = 'block';
      if(specWarningEl) specWarningEl.style.display = 'block';
      if(screenTabsContainer) screenTabsContainer.style.display = 'flex';
      // Show power section
      if(powerSection) powerSection.style.display = 'block';
      // Hide structure
      if(structureSection) structureSection.style.display = 'none';
      // Simplify data section
      if(dataDirectionRow) dataDirectionRow.style.display = 'none';
      if(dataTogglesRow) dataTogglesRow.style.display = 'none';
      // No layouts in simple mode (standardContainer, powerContainer, dataContainer, structureContainer already hidden)
      break;

    case 'combined':
      // Show combined view with screen toggle buttons
      if(combinedContainer) combinedContainer.style.display = 'block';
      // Save current screen data first to ensure deletedPanels is synced
      if(typeof saveCurrentScreenData === 'function') {
        saveCurrentScreenData();
      }
      // Initialize combined view
      if(typeof initCombinedView === 'function') {
        initCombinedView();
      }
      break;

    case 'gear':
      // Show gear list tab
      if(gearListContainer) gearListContainer.style.display = 'block';
      // Save current screen data first
      if(typeof saveCurrentScreenData === 'function') {
        saveCurrentScreenData();
      }
      // Initialize gear view with screen toggles
      if(typeof initGearView === 'function') {
        initGearView();
      }
      break;

    case 'canvas':
      // Show canvas view with all canvas options (no screen tabs on canvas page)
      if(canvasTabsEl) canvasTabsEl.style.display = 'flex';
      if(canvasContainer) canvasContainer.style.display = 'block';
      // Explicitly call showCanvasView to draw the canvas
      if(typeof showCanvasView === 'function') {
        showCanvasView();
      }
      break;
  }

  // Trigger recalculation to ensure canvases render
  if(typeof calculate === 'function') {
    calculate();
  }
}

// Track collapsed state of layout containers
const collapsedLayouts = new Set();

// Toggle collapse/expand state of a layout container
function toggleLayoutCollapse(containerId) {
  const container = document.getElementById(containerId);
  if (!container) return;

  // Map container ID to content ID
  const contentIdMap = {
    'standardContainer': 'standardContent',
    'powerContainer': 'powerContent',
    'dataContainer': 'dataContent',
    'structureContainer': 'structureContent',
    'combinedStandardContainer': 'combinedStandardContent',
    'combinedPowerContainer': 'combinedPowerContent',
    'combinedDataContainer': 'combinedDataContent',
    'combinedStructureContainer': 'combinedStructureContent',
    'combinedSpecsContainer': 'combinedSpecsContent'
  };

  const contentId = contentIdMap[containerId];
  const content = document.getElementById(contentId);
  const btn = document.getElementById(containerId.replace('Container', 'CollapseBtn'));

  if (!content) return;

  if (collapsedLayouts.has(containerId)) {
    // Expand
    collapsedLayouts.delete(containerId);
    content.classList.remove('collapsed');
    container.classList.remove('collapsed');
    if (btn) btn.classList.remove('collapsed');
  } else {
    // Collapse
    collapsedLayouts.add(containerId);
    content.classList.add('collapsed');
    container.classList.add('collapsed');
    if (btn) btn.classList.add('collapsed');
  }
}

// Switch between layouts within the Layouts view
function showMobileLayout(layout) {
  currentMobileLayout = layout;

  // Update toggle buttons
  document.querySelectorAll('.layouts-toggle-container .toggle-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  const activeBtn = document.getElementById('layoutToggle' + layout.charAt(0).toUpperCase() + layout.slice(1));
  if(activeBtn) activeBtn.classList.add('active');

  // Hide all layout containers
  const standardContainer = document.getElementById('standardContainer');
  const powerContainer = document.getElementById('powerContainer');
  const dataContainer = document.getElementById('dataContainer');
  const structureContainer = document.getElementById('structureContainer');

  if(standardContainer) standardContainer.style.display = 'none';
  if(powerContainer) powerContainer.style.display = 'none';
  if(dataContainer) dataContainer.style.display = 'none';
  if(structureContainer) structureContainer.style.display = 'none';

  // Show the selected layout
  switch(layout) {
    case 'standard':
      if(standardContainer) standardContainer.style.display = 'block';
      break;
    case 'power':
      if(powerContainer) powerContainer.style.display = 'block';
      break;
    case 'data':
      if(dataContainer) dataContainer.style.display = 'block';
      break;
    case 'structure':
      if(structureContainer) structureContainer.style.display = 'block';
      break;
  }

  // Regenerate the layout
  if(typeof generateLayout === 'function') {
    generateLayout(layout);
  }
}

// PWA Install Prompt
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  // Show install button
  const installBtn = document.getElementById('installPwaBtn');
  if(installBtn) installBtn.style.display = 'block';
});

function installPwa() {
  if(deferredPrompt) {
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then((choiceResult) => {
      if(choiceResult.outcome === 'accepted') {
        console.log('User accepted PWA install');
      }
      deferredPrompt = null;
      const installBtn = document.getElementById('installPwaBtn');
      if(installBtn) installBtn.style.display = 'none';
    });
  }
}

// Unregister any existing service workers (cleanup from previous versions)
// Service workers were causing update issues, so we've removed them
if('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(registrations => {
    registrations.forEach(reg => {
      reg.unregister().then(() => console.log('SW unregistered'));
    });
  });
  // Also clear any old caches
  if('caches' in window) {
    caches.keys().then(names => {
      names.forEach(name => {
        if(name.startsWith('led-calc-mobile-')) {
          caches.delete(name);
        }
      });
    });
  }
}

// Collapsible Sections - runs after page fully loads
function initMobileUI() {
  console.log('Initializing mobile UI...');

  // Add section-content wrapper to all section boxes that don't have one
  document.querySelectorAll('.section-box').forEach(box => {
    const title = box.querySelector('.section-title');
    if(title && !box.querySelector('.section-content')) {
      // Wrap non-title children in section-content
      const children = Array.from(box.children).filter(child => !child.classList.contains('section-title'));
      if(children.length > 0) {
        const content = document.createElement('div');
        content.className = 'section-content';
        children.forEach(child => content.appendChild(child));
        box.appendChild(content);
      }
    }

    // Add click/touch handler for collapsing
    if(title) {
      title.addEventListener('click', function(e) {
        e.stopPropagation();
        box.classList.toggle('collapsed');
      });
    }
  });

  // Initialize on simple view (default mode)
  switchMobileView('simple');

  // Make sure calculate runs
  if(typeof calculate === 'function') {
    setTimeout(calculate, 100);
  }

  // Setup Combined canvas handlers for panel selection and screen dragging
  if(typeof setupCombinedCanvasHandlers === 'function') {
    setupCombinedCanvasHandlers();
  }
  if(typeof setupCombinedDragHandlers === 'function') {
    setupCombinedDragHandlers();
  }

  // Check for updates after UI loads
  setTimeout(checkForUpdates, 500);

  console.log('Mobile UI initialized');
}

// Run initialization when DOM is ready
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initMobileUI);
} else {
  // DOM already loaded, run now
  initMobileUI();
}

// Touch gesture support for canvases
let touchStartX = 0;
let touchStartY = 0;
let touchStartDistance = 0;
let initialZoom = 1;

function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Add touch handlers to canvases
function initializeTouchCanvas(canvasId) {
  const canvas = document.getElementById(canvasId);
  if(!canvas) return;

  canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length === 2) {
      // Pinch start
      touchStartDistance = getTouchDistance(e.touches);
      initialZoom = canvasZoomLevel || 1;
      e.preventDefault();
    } else if(e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }, {passive: false});

  canvas.addEventListener('touchmove', function(e) {
    if(e.touches.length === 2 && touchStartDistance > 0) {
      // Pinch zoom
      const currentDistance = getTouchDistance(e.touches);
      const scale = currentDistance / touchStartDistance;
      const newZoom = Math.min(3, Math.max(0.5, initialZoom * scale));

      if(typeof setCanvasZoom === 'function') {
        setCanvasZoom(newZoom * 100);
      }
      e.preventDefault();
    }
  }, {passive: false});

  canvas.addEventListener('touchend', function(e) {
    touchStartDistance = 0;
  });
}

// Initialize touch on all canvases after load
window.addEventListener('load', function() {
  ['standardCanvas', 'powerCanvas', 'dataCanvas', 'structureCanvas', 'canvasView'].forEach(initializeTouchCanvas);
});

// Long-press for context menu (replaces right-click)
let longPressTimer = null;
let longPressTriggered = false;
let longPressTouchStart = {x: 0, y: 0};

function setupMobileLongPress() {
  console.log('Setting up mobile long-press handlers...');

  // Standard Canvas - long press for panel context menu
  const standardCanvas = document.getElementById('standardCanvas');
  if(standardCanvas) {
    standardCanvas.addEventListener('touchstart', function(e) {
      if(e.touches.length !== 1) return;

      longPressTriggered = false;
      longPressTouchStart.x = e.touches[0].clientX;
      longPressTouchStart.y = e.touches[0].clientY;

      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        vibrate(50);

        // Get panel at touch position
        const panel = getPanelAtPosition(standardCanvas, longPressTouchStart.x, longPressTouchStart.y);
        if(panel) {
          // Select the panel if not already selected
          if(!selectedPanels.has(panel.key)) {
            selectedPanels.clear();
            selectedPanels.add(panel.key);
            generateLayout('standard');
          }
          // Show context menu
          showContextMenu(longPressTouchStart.x, longPressTouchStart.y);
        }
      }, 600);
    }, {passive: true});

    standardCanvas.addEventListener('touchmove', function(e) {
      if(longPressTimer) {
        const dx = Math.abs(e.touches[0].clientX - longPressTouchStart.x);
        const dy = Math.abs(e.touches[0].clientY - longPressTouchStart.y);
        if(dx > 10 || dy > 10) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      }
    }, {passive: true});

    standardCanvas.addEventListener('touchend', function(e) {
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      // Prevent click if long press was triggered
      if(longPressTriggered) {
        e.preventDefault();
        longPressTriggered = false;
      }
    });

    console.log('Standard canvas long-press enabled');
  }

  // Structure Canvas - long press for empty area context menu (to add bumpers)
  // Note: Bumper tap/drag is handled by setupBumperTouchDrag()
  const structureCanvas = document.getElementById('structureCanvas');
  if(structureCanvas) {
    structureCanvas.addEventListener('touchstart', function(e) {
      if(e.touches.length !== 1) return;

      longPressTriggered = false;
      longPressTouchStart.x = e.touches[0].clientX;
      longPressTouchStart.y = e.touches[0].clientY;

      // Check if touching a bumper - if so, let setupBumperTouchDrag handle it
      const bumper = getBumperAtMouse(structureCanvas, longPressTouchStart.x, longPressTouchStart.y);
      if(bumper && manualBumperMode) {
        // Bumper touch is handled by setupBumperTouchDrag
        return;
      }

      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        vibrate(50);

        if(!manualBumperMode) {
          // Auto-enable manual mode on long press
          toggleManualBumperMode();
        }

        // Check if in bumper area for adding (empty space, not on a bumper)
        const rect = structureCanvas.getBoundingClientRect();
        const y = (longPressTouchStart.y - rect.top) * (structureCanvas.height / rect.height);
        const x = (longPressTouchStart.x - rect.left) * (structureCanvas.width / rect.width);

        const pw = parseInt(document.getElementById('panelsWide').value) || 0;
        const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
        const size = panelSize; // Use global panelSize for consistent sizing
        const bumperHeight = Math.max(30, size * 0.8);

        const column = Math.floor(x / size);

        if(showTopBumper && y < bumperHeight && column >= 0 && column < pw) {
          showEmptyAreaContextMenu('top', column, longPressTouchStart.x, longPressTouchStart.y);
        } else if(showBottomBumper) {
          const bottomStart = (showTopBumper ? bumperHeight : 0) + (ph * size);
          if(y >= bottomStart && column >= 0 && column < pw) {
            showEmptyAreaContextMenu('bottom', column, longPressTouchStart.x, longPressTouchStart.y);
          }
        }
      }, 600);
    }, {passive: true});

    structureCanvas.addEventListener('touchmove', function(e) {
      if(longPressTimer) {
        const dx = Math.abs(e.touches[0].clientX - longPressTouchStart.x);
        const dy = Math.abs(e.touches[0].clientY - longPressTouchStart.y);
        if(dx > 10 || dy > 10) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      }
    }, {passive: true});

    structureCanvas.addEventListener('touchend', function(e) {
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      if(longPressTriggered) {
        e.preventDefault();
        longPressTriggered = false;
      }
    });

    console.log('Structure canvas long-press enabled');
  }

  // Setup bumper touch drag support for manual mode
  setupBumperTouchDrag();
}

// Touch drag support for bumpers in structure layout manual mode
// Behavior: TAP = show context menu, HOLD then drag = move bumper
function setupBumperTouchDrag() {
  const canvas = document.getElementById('structureCanvas');
  if(!canvas || canvas._bumperTouchSetup) return;
  canvas._bumperTouchSetup = true;

  // Behavior: 1 tap = select bumper, 2nd tap on selected = menu, hold+drag = move
  let touchDragBumper = null;
  let touchDragStartCol = -1;
  let touchDragOffsetX = 0;
  let touchStartX = 0;
  let touchStartY = 0;
  let isTouchDragging = false;
  let isDragEnabled = false; // Only allow drag after hold delay
  let holdTimer = null;
  let touchedBumper = null;
  let wasAlreadySelected = false;

  canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length !== 1) return;
    if(!manualBumperMode) return;

    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;

    // Check if touching a bumper
    const bumper = getBumperAtMouse(canvas, touch.clientX, touch.clientY);
    touchedBumper = bumper;

    if(bumper) {
      // Check if bumper was already selected BEFORE we potentially select it
      wasAlreadySelected = selectedBumpers.has(bumper.id);

      // Start hold timer - after 300ms, enable dragging
      holdTimer = setTimeout(() => {
        isDragEnabled = true;
        vibrate(30); // Haptic feedback to indicate drag mode enabled

        // Prepare for drag
        touchDragBumper = bumper;
        touchDragStartCol = bumper.startCol;

        // Calculate drag offset
        const rect = canvas.getBoundingClientRect();
        const touchX = (touchStartX - rect.left) * (canvas.width / rect.width);
        touchDragOffsetX = touchX - (bumper.startCol * panelSize);
      }, 300);
    }
  }, {passive: true});

  canvas.addEventListener('touchmove', function(e) {
    if(!manualBumperMode) return;
    if(e.touches.length !== 1) return;

    const touch = e.touches[0];
    const dx = Math.abs(touch.clientX - touchStartX);
    const dy = Math.abs(touch.clientY - touchStartY);

    // If moved before hold timer, cancel the hold (this was a scroll/swipe)
    if(!isDragEnabled && (dx > 10 || dy > 10)) {
      if(holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
      }
      // Cancel long press timer too
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      return;
    }

    // Only drag if hold delay passed and we have a bumper
    if(!isDragEnabled || !touchDragBumper) return;

    isTouchDragging = true;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);

    const newCol = Math.floor((touchX - touchDragOffsetX) / currentPanelWidth);
    const pw = parseInt(document.getElementById('panelsWide').value) || 0;

    // Constrain to valid columns
    if(newCol >= 0 && newCol < pw) {
      const bumperWidth = touchDragBumper.endCol - touchDragBumper.startCol;
      const maxStartCol = Math.max(0, pw - 1 - bumperWidth);
      const constrainedCol = Math.max(0, Math.min(newCol, maxStartCol));

      if(constrainedCol !== touchDragBumper.startCol) {
        const colDelta = constrainedCol - touchDragBumper.startCol;
        touchDragBumper.startCol = constrainedCol;
        touchDragBumper.endCol = touchDragBumper.endCol + colDelta;

        generateStructureLayout();
      }
    }
  }, {passive: false});

  canvas.addEventListener('touchend', function(e) {
    // Cancel hold timer
    if(holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }

    if(manualBumperMode) {
      if(isTouchDragging && touchDragBumper) {
        // Bumper was dragged - save state if moved
        if(touchDragStartCol !== -1 && touchDragStartCol !== touchDragBumper.startCol) {
          saveStructureState();
          vibrate(30);
        }
        // Update weight and calculations
        updateWeightDisplay();
        calculate();
        updateStructureUndoRedoButtons();
      } else if(!isDragEnabled && touchedBumper) {
        // Quick tap (no drag) - check if bumper was already selected
        if(wasAlreadySelected) {
          // 2nd tap on selected bumper - show context menu
          vibrate(20);
          showBumperContextMenu(touchedBumper, touchStartX, touchStartY);
        } else {
          // 1st tap - select the bumper
          selectedBumpers.clear();
          selectedBumpers.add(touchedBumper.id);
          updateStructureSelectionInfo();
          generateStructureLayout();
        }
      }
    }

    // Reset all state
    touchDragBumper = null;
    touchDragStartCol = -1;
    isTouchDragging = false;
    isDragEnabled = false;
    touchedBumper = null;
    wasAlreadySelected = false;
  });

  canvas.addEventListener('touchcancel', function(e) {
    if(holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }
    touchDragBumper = null;
    touchDragStartCol = -1;
    isTouchDragging = false;
    isDragEnabled = false;
    touchedBumper = null;
    wasAlreadySelected = false;
  });

  console.log('Bumper touch drag enabled (tap=select, 2nd tap=menu, hold+drag=move)');
}

// Haptic feedback helper
function vibrate(pattern = 10) {
  if('vibrate' in navigator) {
    navigator.vibrate(pattern);
  }
}

// Initialize long-press after page loads
window.addEventListener('load', function() {
  setTimeout(setupMobileLongPress, 500);
});

console.log('Mobile v1 JavaScript loaded');
</script>

</body>
</html>
